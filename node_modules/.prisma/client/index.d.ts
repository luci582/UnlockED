
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model Skill
 * 
 */
export type Skill = $Result.DefaultSelection<Prisma.$SkillPayload>
/**
 * Model CourseSkill
 * 
 */
export type CourseSkill = $Result.DefaultSelection<Prisma.$CourseSkillPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model ReviewVote
 * 
 */
export type ReviewVote = $Result.DefaultSelection<Prisma.$ReviewVotePayload>
/**
 * Model ReviewHelpfulVote
 * 
 */
export type ReviewHelpfulVote = $Result.DefaultSelection<Prisma.$ReviewHelpfulVotePayload>
/**
 * Model ReviewSkillRating
 * 
 */
export type ReviewSkillRating = $Result.DefaultSelection<Prisma.$ReviewSkillRatingPayload>
/**
 * Model CourseEnrollment
 * 
 */
export type CourseEnrollment = $Result.DefaultSelection<Prisma.$CourseEnrollmentPayload>
/**
 * Model UserSkillProficiency
 * 
 */
export type UserSkillProficiency = $Result.DefaultSelection<Prisma.$UserSkillProficiencyPayload>
/**
 * Model SkillPrerequisite
 * 
 */
export type SkillPrerequisite = $Result.DefaultSelection<Prisma.$SkillPrerequisitePayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model CourseCategory
 * 
 */
export type CourseCategory = $Result.DefaultSelection<Prisma.$CourseCategoryPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model CourseTag
 * 
 */
export type CourseTag = $Result.DefaultSelection<Prisma.$CourseTagPayload>
/**
 * Model CourseModule
 * 
 */
export type CourseModule = $Result.DefaultSelection<Prisma.$CourseModulePayload>
/**
 * Model Achievement
 * 
 */
export type Achievement = $Result.DefaultSelection<Prisma.$AchievementPayload>
/**
 * Model UserAchievement
 * 
 */
export type UserAchievement = $Result.DefaultSelection<Prisma.$UserAchievementPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model ProgressReport
 * 
 */
export type ProgressReport = $Result.DefaultSelection<Prisma.$ProgressReportPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Difficulty: {
  BEGINNER: 'BEGINNER',
  INTERMEDIATE: 'INTERMEDIATE',
  ADVANCED: 'ADVANCED',
  EXPERT: 'EXPERT'
};

export type Difficulty = (typeof Difficulty)[keyof typeof Difficulty]


export const UserRole: {
  STUDENT: 'STUDENT',
  INSTRUCTOR: 'INSTRUCTOR',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const SkillLevel: {
  LIGHT: 'LIGHT',
  MEDIUM: 'MEDIUM',
  HEAVY: 'HEAVY',
  VERY_HEAVY: 'VERY_HEAVY'
};

export type SkillLevel = (typeof SkillLevel)[keyof typeof SkillLevel]


export const CourseStatus: {
  DRAFT: 'DRAFT',
  PUBLISHED: 'PUBLISHED',
  ARCHIVED: 'ARCHIVED',
  UNDER_REVIEW: 'UNDER_REVIEW'
};

export type CourseStatus = (typeof CourseStatus)[keyof typeof CourseStatus]


export const AchievementType: {
  REVIEW_COUNT: 'REVIEW_COUNT',
  COURSE_COMPLETION: 'COURSE_COMPLETION',
  STREAK: 'STREAK',
  RATING_QUALITY: 'RATING_QUALITY',
  FIRST_REVIEW: 'FIRST_REVIEW',
  HELPFUL_REVIEWS: 'HELPFUL_REVIEWS',
  SKILL_MASTERY: 'SKILL_MASTERY',
  COMMUNITY_CONTRIBUTOR: 'COMMUNITY_CONTRIBUTOR'
};

export type AchievementType = (typeof AchievementType)[keyof typeof AchievementType]

}

export type Difficulty = $Enums.Difficulty

export const Difficulty: typeof $Enums.Difficulty

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type SkillLevel = $Enums.SkillLevel

export const SkillLevel: typeof $Enums.SkillLevel

export type CourseStatus = $Enums.CourseStatus

export const CourseStatus: typeof $Enums.CourseStatus

export type AchievementType = $Enums.AchievementType

export const AchievementType: typeof $Enums.AchievementType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.skill`: Exposes CRUD operations for the **Skill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Skills
    * const skills = await prisma.skill.findMany()
    * ```
    */
  get skill(): Prisma.SkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseSkill`: Exposes CRUD operations for the **CourseSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseSkills
    * const courseSkills = await prisma.courseSkill.findMany()
    * ```
    */
  get courseSkill(): Prisma.CourseSkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reviewVote`: Exposes CRUD operations for the **ReviewVote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReviewVotes
    * const reviewVotes = await prisma.reviewVote.findMany()
    * ```
    */
  get reviewVote(): Prisma.ReviewVoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reviewHelpfulVote`: Exposes CRUD operations for the **ReviewHelpfulVote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReviewHelpfulVotes
    * const reviewHelpfulVotes = await prisma.reviewHelpfulVote.findMany()
    * ```
    */
  get reviewHelpfulVote(): Prisma.ReviewHelpfulVoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reviewSkillRating`: Exposes CRUD operations for the **ReviewSkillRating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReviewSkillRatings
    * const reviewSkillRatings = await prisma.reviewSkillRating.findMany()
    * ```
    */
  get reviewSkillRating(): Prisma.ReviewSkillRatingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseEnrollment`: Exposes CRUD operations for the **CourseEnrollment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseEnrollments
    * const courseEnrollments = await prisma.courseEnrollment.findMany()
    * ```
    */
  get courseEnrollment(): Prisma.CourseEnrollmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSkillProficiency`: Exposes CRUD operations for the **UserSkillProficiency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSkillProficiencies
    * const userSkillProficiencies = await prisma.userSkillProficiency.findMany()
    * ```
    */
  get userSkillProficiency(): Prisma.UserSkillProficiencyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.skillPrerequisite`: Exposes CRUD operations for the **SkillPrerequisite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SkillPrerequisites
    * const skillPrerequisites = await prisma.skillPrerequisite.findMany()
    * ```
    */
  get skillPrerequisite(): Prisma.SkillPrerequisiteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseCategory`: Exposes CRUD operations for the **CourseCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseCategories
    * const courseCategories = await prisma.courseCategory.findMany()
    * ```
    */
  get courseCategory(): Prisma.CourseCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseTag`: Exposes CRUD operations for the **CourseTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseTags
    * const courseTags = await prisma.courseTag.findMany()
    * ```
    */
  get courseTag(): Prisma.CourseTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseModule`: Exposes CRUD operations for the **CourseModule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseModules
    * const courseModules = await prisma.courseModule.findMany()
    * ```
    */
  get courseModule(): Prisma.CourseModuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.achievement`: Exposes CRUD operations for the **Achievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Achievements
    * const achievements = await prisma.achievement.findMany()
    * ```
    */
  get achievement(): Prisma.AchievementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAchievement`: Exposes CRUD operations for the **UserAchievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAchievements
    * const userAchievements = await prisma.userAchievement.findMany()
    * ```
    */
  get userAchievement(): Prisma.UserAchievementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.progressReport`: Exposes CRUD operations for the **ProgressReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProgressReports
    * const progressReports = await prisma.progressReport.findMany()
    * ```
    */
  get progressReport(): Prisma.ProgressReportDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.12.0
   * Query Engine version: 8047c96bbd92db98a2abc7c9323ce77c02c89dbc
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Course: 'Course',
    Skill: 'Skill',
    CourseSkill: 'CourseSkill',
    Review: 'Review',
    ReviewVote: 'ReviewVote',
    ReviewHelpfulVote: 'ReviewHelpfulVote',
    ReviewSkillRating: 'ReviewSkillRating',
    CourseEnrollment: 'CourseEnrollment',
    UserSkillProficiency: 'UserSkillProficiency',
    SkillPrerequisite: 'SkillPrerequisite',
    Category: 'Category',
    CourseCategory: 'CourseCategory',
    Tag: 'Tag',
    CourseTag: 'CourseTag',
    CourseModule: 'CourseModule',
    Achievement: 'Achievement',
    UserAchievement: 'UserAchievement',
    Notification: 'Notification',
    ProgressReport: 'ProgressReport'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "course" | "skill" | "courseSkill" | "review" | "reviewVote" | "reviewHelpfulVote" | "reviewSkillRating" | "courseEnrollment" | "userSkillProficiency" | "skillPrerequisite" | "category" | "courseCategory" | "tag" | "courseTag" | "courseModule" | "achievement" | "userAchievement" | "notification" | "progressReport"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      Skill: {
        payload: Prisma.$SkillPayload<ExtArgs>
        fields: Prisma.SkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findFirst: {
            args: Prisma.SkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findMany: {
            args: Prisma.SkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          create: {
            args: Prisma.SkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          createMany: {
            args: Prisma.SkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          delete: {
            args: Prisma.SkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          update: {
            args: Prisma.SkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          deleteMany: {
            args: Prisma.SkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          upsert: {
            args: Prisma.SkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          aggregate: {
            args: Prisma.SkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkill>
          }
          groupBy: {
            args: Prisma.SkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkillCountArgs<ExtArgs>
            result: $Utils.Optional<SkillCountAggregateOutputType> | number
          }
        }
      }
      CourseSkill: {
        payload: Prisma.$CourseSkillPayload<ExtArgs>
        fields: Prisma.CourseSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseSkillPayload>
          }
          findFirst: {
            args: Prisma.CourseSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseSkillPayload>
          }
          findMany: {
            args: Prisma.CourseSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseSkillPayload>[]
          }
          create: {
            args: Prisma.CourseSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseSkillPayload>
          }
          createMany: {
            args: Prisma.CourseSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseSkillPayload>[]
          }
          delete: {
            args: Prisma.CourseSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseSkillPayload>
          }
          update: {
            args: Prisma.CourseSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseSkillPayload>
          }
          deleteMany: {
            args: Prisma.CourseSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseSkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseSkillPayload>[]
          }
          upsert: {
            args: Prisma.CourseSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseSkillPayload>
          }
          aggregate: {
            args: Prisma.CourseSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseSkill>
          }
          groupBy: {
            args: Prisma.CourseSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseSkillCountArgs<ExtArgs>
            result: $Utils.Optional<CourseSkillCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      ReviewVote: {
        payload: Prisma.$ReviewVotePayload<ExtArgs>
        fields: Prisma.ReviewVoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewVoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewVotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewVoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewVotePayload>
          }
          findFirst: {
            args: Prisma.ReviewVoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewVotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewVoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewVotePayload>
          }
          findMany: {
            args: Prisma.ReviewVoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewVotePayload>[]
          }
          create: {
            args: Prisma.ReviewVoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewVotePayload>
          }
          createMany: {
            args: Prisma.ReviewVoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewVoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewVotePayload>[]
          }
          delete: {
            args: Prisma.ReviewVoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewVotePayload>
          }
          update: {
            args: Prisma.ReviewVoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewVotePayload>
          }
          deleteMany: {
            args: Prisma.ReviewVoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewVoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewVoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewVotePayload>[]
          }
          upsert: {
            args: Prisma.ReviewVoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewVotePayload>
          }
          aggregate: {
            args: Prisma.ReviewVoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviewVote>
          }
          groupBy: {
            args: Prisma.ReviewVoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewVoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewVoteCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewVoteCountAggregateOutputType> | number
          }
        }
      }
      ReviewHelpfulVote: {
        payload: Prisma.$ReviewHelpfulVotePayload<ExtArgs>
        fields: Prisma.ReviewHelpfulVoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewHelpfulVoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewHelpfulVotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewHelpfulVoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewHelpfulVotePayload>
          }
          findFirst: {
            args: Prisma.ReviewHelpfulVoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewHelpfulVotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewHelpfulVoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewHelpfulVotePayload>
          }
          findMany: {
            args: Prisma.ReviewHelpfulVoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewHelpfulVotePayload>[]
          }
          create: {
            args: Prisma.ReviewHelpfulVoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewHelpfulVotePayload>
          }
          createMany: {
            args: Prisma.ReviewHelpfulVoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewHelpfulVoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewHelpfulVotePayload>[]
          }
          delete: {
            args: Prisma.ReviewHelpfulVoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewHelpfulVotePayload>
          }
          update: {
            args: Prisma.ReviewHelpfulVoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewHelpfulVotePayload>
          }
          deleteMany: {
            args: Prisma.ReviewHelpfulVoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewHelpfulVoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewHelpfulVoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewHelpfulVotePayload>[]
          }
          upsert: {
            args: Prisma.ReviewHelpfulVoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewHelpfulVotePayload>
          }
          aggregate: {
            args: Prisma.ReviewHelpfulVoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviewHelpfulVote>
          }
          groupBy: {
            args: Prisma.ReviewHelpfulVoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewHelpfulVoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewHelpfulVoteCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewHelpfulVoteCountAggregateOutputType> | number
          }
        }
      }
      ReviewSkillRating: {
        payload: Prisma.$ReviewSkillRatingPayload<ExtArgs>
        fields: Prisma.ReviewSkillRatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewSkillRatingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewSkillRatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewSkillRatingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewSkillRatingPayload>
          }
          findFirst: {
            args: Prisma.ReviewSkillRatingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewSkillRatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewSkillRatingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewSkillRatingPayload>
          }
          findMany: {
            args: Prisma.ReviewSkillRatingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewSkillRatingPayload>[]
          }
          create: {
            args: Prisma.ReviewSkillRatingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewSkillRatingPayload>
          }
          createMany: {
            args: Prisma.ReviewSkillRatingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewSkillRatingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewSkillRatingPayload>[]
          }
          delete: {
            args: Prisma.ReviewSkillRatingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewSkillRatingPayload>
          }
          update: {
            args: Prisma.ReviewSkillRatingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewSkillRatingPayload>
          }
          deleteMany: {
            args: Prisma.ReviewSkillRatingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewSkillRatingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewSkillRatingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewSkillRatingPayload>[]
          }
          upsert: {
            args: Prisma.ReviewSkillRatingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewSkillRatingPayload>
          }
          aggregate: {
            args: Prisma.ReviewSkillRatingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviewSkillRating>
          }
          groupBy: {
            args: Prisma.ReviewSkillRatingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewSkillRatingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewSkillRatingCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewSkillRatingCountAggregateOutputType> | number
          }
        }
      }
      CourseEnrollment: {
        payload: Prisma.$CourseEnrollmentPayload<ExtArgs>
        fields: Prisma.CourseEnrollmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseEnrollmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseEnrollmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseEnrollmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseEnrollmentPayload>
          }
          findFirst: {
            args: Prisma.CourseEnrollmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseEnrollmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseEnrollmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseEnrollmentPayload>
          }
          findMany: {
            args: Prisma.CourseEnrollmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseEnrollmentPayload>[]
          }
          create: {
            args: Prisma.CourseEnrollmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseEnrollmentPayload>
          }
          createMany: {
            args: Prisma.CourseEnrollmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseEnrollmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseEnrollmentPayload>[]
          }
          delete: {
            args: Prisma.CourseEnrollmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseEnrollmentPayload>
          }
          update: {
            args: Prisma.CourseEnrollmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseEnrollmentPayload>
          }
          deleteMany: {
            args: Prisma.CourseEnrollmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseEnrollmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseEnrollmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseEnrollmentPayload>[]
          }
          upsert: {
            args: Prisma.CourseEnrollmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseEnrollmentPayload>
          }
          aggregate: {
            args: Prisma.CourseEnrollmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseEnrollment>
          }
          groupBy: {
            args: Prisma.CourseEnrollmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseEnrollmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseEnrollmentCountArgs<ExtArgs>
            result: $Utils.Optional<CourseEnrollmentCountAggregateOutputType> | number
          }
        }
      }
      UserSkillProficiency: {
        payload: Prisma.$UserSkillProficiencyPayload<ExtArgs>
        fields: Prisma.UserSkillProficiencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSkillProficiencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillProficiencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSkillProficiencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillProficiencyPayload>
          }
          findFirst: {
            args: Prisma.UserSkillProficiencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillProficiencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSkillProficiencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillProficiencyPayload>
          }
          findMany: {
            args: Prisma.UserSkillProficiencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillProficiencyPayload>[]
          }
          create: {
            args: Prisma.UserSkillProficiencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillProficiencyPayload>
          }
          createMany: {
            args: Prisma.UserSkillProficiencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSkillProficiencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillProficiencyPayload>[]
          }
          delete: {
            args: Prisma.UserSkillProficiencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillProficiencyPayload>
          }
          update: {
            args: Prisma.UserSkillProficiencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillProficiencyPayload>
          }
          deleteMany: {
            args: Prisma.UserSkillProficiencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSkillProficiencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSkillProficiencyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillProficiencyPayload>[]
          }
          upsert: {
            args: Prisma.UserSkillProficiencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillProficiencyPayload>
          }
          aggregate: {
            args: Prisma.UserSkillProficiencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSkillProficiency>
          }
          groupBy: {
            args: Prisma.UserSkillProficiencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSkillProficiencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSkillProficiencyCountArgs<ExtArgs>
            result: $Utils.Optional<UserSkillProficiencyCountAggregateOutputType> | number
          }
        }
      }
      SkillPrerequisite: {
        payload: Prisma.$SkillPrerequisitePayload<ExtArgs>
        fields: Prisma.SkillPrerequisiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkillPrerequisiteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPrerequisitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkillPrerequisiteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPrerequisitePayload>
          }
          findFirst: {
            args: Prisma.SkillPrerequisiteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPrerequisitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkillPrerequisiteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPrerequisitePayload>
          }
          findMany: {
            args: Prisma.SkillPrerequisiteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPrerequisitePayload>[]
          }
          create: {
            args: Prisma.SkillPrerequisiteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPrerequisitePayload>
          }
          createMany: {
            args: Prisma.SkillPrerequisiteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SkillPrerequisiteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPrerequisitePayload>[]
          }
          delete: {
            args: Prisma.SkillPrerequisiteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPrerequisitePayload>
          }
          update: {
            args: Prisma.SkillPrerequisiteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPrerequisitePayload>
          }
          deleteMany: {
            args: Prisma.SkillPrerequisiteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkillPrerequisiteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SkillPrerequisiteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPrerequisitePayload>[]
          }
          upsert: {
            args: Prisma.SkillPrerequisiteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPrerequisitePayload>
          }
          aggregate: {
            args: Prisma.SkillPrerequisiteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkillPrerequisite>
          }
          groupBy: {
            args: Prisma.SkillPrerequisiteGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillPrerequisiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkillPrerequisiteCountArgs<ExtArgs>
            result: $Utils.Optional<SkillPrerequisiteCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      CourseCategory: {
        payload: Prisma.$CourseCategoryPayload<ExtArgs>
        fields: Prisma.CourseCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCategoryPayload>
          }
          findFirst: {
            args: Prisma.CourseCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCategoryPayload>
          }
          findMany: {
            args: Prisma.CourseCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCategoryPayload>[]
          }
          create: {
            args: Prisma.CourseCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCategoryPayload>
          }
          createMany: {
            args: Prisma.CourseCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCategoryPayload>[]
          }
          delete: {
            args: Prisma.CourseCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCategoryPayload>
          }
          update: {
            args: Prisma.CourseCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCategoryPayload>
          }
          deleteMany: {
            args: Prisma.CourseCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCategoryPayload>[]
          }
          upsert: {
            args: Prisma.CourseCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCategoryPayload>
          }
          aggregate: {
            args: Prisma.CourseCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseCategory>
          }
          groupBy: {
            args: Prisma.CourseCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCategoryCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      CourseTag: {
        payload: Prisma.$CourseTagPayload<ExtArgs>
        fields: Prisma.CourseTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagPayload>
          }
          findFirst: {
            args: Prisma.CourseTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagPayload>
          }
          findMany: {
            args: Prisma.CourseTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagPayload>[]
          }
          create: {
            args: Prisma.CourseTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagPayload>
          }
          createMany: {
            args: Prisma.CourseTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagPayload>[]
          }
          delete: {
            args: Prisma.CourseTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagPayload>
          }
          update: {
            args: Prisma.CourseTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagPayload>
          }
          deleteMany: {
            args: Prisma.CourseTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagPayload>[]
          }
          upsert: {
            args: Prisma.CourseTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagPayload>
          }
          aggregate: {
            args: Prisma.CourseTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseTag>
          }
          groupBy: {
            args: Prisma.CourseTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseTagCountArgs<ExtArgs>
            result: $Utils.Optional<CourseTagCountAggregateOutputType> | number
          }
        }
      }
      CourseModule: {
        payload: Prisma.$CourseModulePayload<ExtArgs>
        fields: Prisma.CourseModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>
          }
          findFirst: {
            args: Prisma.CourseModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>
          }
          findMany: {
            args: Prisma.CourseModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>[]
          }
          create: {
            args: Prisma.CourseModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>
          }
          createMany: {
            args: Prisma.CourseModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseModuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>[]
          }
          delete: {
            args: Prisma.CourseModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>
          }
          update: {
            args: Prisma.CourseModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>
          }
          deleteMany: {
            args: Prisma.CourseModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseModuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>[]
          }
          upsert: {
            args: Prisma.CourseModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>
          }
          aggregate: {
            args: Prisma.CourseModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseModule>
          }
          groupBy: {
            args: Prisma.CourseModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseModuleCountArgs<ExtArgs>
            result: $Utils.Optional<CourseModuleCountAggregateOutputType> | number
          }
        }
      }
      Achievement: {
        payload: Prisma.$AchievementPayload<ExtArgs>
        fields: Prisma.AchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findFirst: {
            args: Prisma.AchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findMany: {
            args: Prisma.AchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          create: {
            args: Prisma.AchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          createMany: {
            args: Prisma.AchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          delete: {
            args: Prisma.AchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          update: {
            args: Prisma.AchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          deleteMany: {
            args: Prisma.AchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AchievementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          upsert: {
            args: Prisma.AchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          aggregate: {
            args: Prisma.AchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievement>
          }
          groupBy: {
            args: Prisma.AchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AchievementCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementCountAggregateOutputType> | number
          }
        }
      }
      UserAchievement: {
        payload: Prisma.$UserAchievementPayload<ExtArgs>
        fields: Prisma.UserAchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          findFirst: {
            args: Prisma.UserAchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          findMany: {
            args: Prisma.UserAchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          create: {
            args: Prisma.UserAchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          createMany: {
            args: Prisma.UserAchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          delete: {
            args: Prisma.UserAchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          update: {
            args: Prisma.UserAchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          deleteMany: {
            args: Prisma.UserAchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserAchievementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          upsert: {
            args: Prisma.UserAchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          aggregate: {
            args: Prisma.UserAchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAchievement>
          }
          groupBy: {
            args: Prisma.UserAchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAchievementCountArgs<ExtArgs>
            result: $Utils.Optional<UserAchievementCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      ProgressReport: {
        payload: Prisma.$ProgressReportPayload<ExtArgs>
        fields: Prisma.ProgressReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgressReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgressReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressReportPayload>
          }
          findFirst: {
            args: Prisma.ProgressReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgressReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressReportPayload>
          }
          findMany: {
            args: Prisma.ProgressReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressReportPayload>[]
          }
          create: {
            args: Prisma.ProgressReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressReportPayload>
          }
          createMany: {
            args: Prisma.ProgressReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgressReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressReportPayload>[]
          }
          delete: {
            args: Prisma.ProgressReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressReportPayload>
          }
          update: {
            args: Prisma.ProgressReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressReportPayload>
          }
          deleteMany: {
            args: Prisma.ProgressReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgressReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProgressReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressReportPayload>[]
          }
          upsert: {
            args: Prisma.ProgressReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressReportPayload>
          }
          aggregate: {
            args: Prisma.ProgressReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgressReport>
          }
          groupBy: {
            args: Prisma.ProgressReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgressReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgressReportCountArgs<ExtArgs>
            result: $Utils.Optional<ProgressReportCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    course?: CourseOmit
    skill?: SkillOmit
    courseSkill?: CourseSkillOmit
    review?: ReviewOmit
    reviewVote?: ReviewVoteOmit
    reviewHelpfulVote?: ReviewHelpfulVoteOmit
    reviewSkillRating?: ReviewSkillRatingOmit
    courseEnrollment?: CourseEnrollmentOmit
    userSkillProficiency?: UserSkillProficiencyOmit
    skillPrerequisite?: SkillPrerequisiteOmit
    category?: CategoryOmit
    courseCategory?: CourseCategoryOmit
    tag?: TagOmit
    courseTag?: CourseTagOmit
    courseModule?: CourseModuleOmit
    achievement?: AchievementOmit
    userAchievement?: UserAchievementOmit
    notification?: NotificationOmit
    progressReport?: ProgressReportOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    reviews: number
    reviewVotes: number
    enrollments: number
    achievements: number
    notifications: number
    courses: number
    skillProficiencies: number
    reviewHelpfulVotes: number
    progressReports: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs
    reviewVotes?: boolean | UserCountOutputTypeCountReviewVotesArgs
    enrollments?: boolean | UserCountOutputTypeCountEnrollmentsArgs
    achievements?: boolean | UserCountOutputTypeCountAchievementsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    courses?: boolean | UserCountOutputTypeCountCoursesArgs
    skillProficiencies?: boolean | UserCountOutputTypeCountSkillProficienciesArgs
    reviewHelpfulVotes?: boolean | UserCountOutputTypeCountReviewHelpfulVotesArgs
    progressReports?: boolean | UserCountOutputTypeCountProgressReportsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewVoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseEnrollmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSkillProficienciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSkillProficiencyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewHelpfulVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewHelpfulVoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProgressReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgressReportWhereInput
  }


  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    reviews: number
    skills: number
    enrollments: number
    categories: number
    tags: number
    modules: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | CourseCountOutputTypeCountReviewsArgs
    skills?: boolean | CourseCountOutputTypeCountSkillsArgs
    enrollments?: boolean | CourseCountOutputTypeCountEnrollmentsArgs
    categories?: boolean | CourseCountOutputTypeCountCategoriesArgs
    tags?: boolean | CourseCountOutputTypeCountTagsArgs
    modules?: boolean | CourseCountOutputTypeCountModulesArgs
  }

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseSkillWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseEnrollmentWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseCategoryWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseTagWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseModuleWhereInput
  }


  /**
   * Count Type SkillCountOutputType
   */

  export type SkillCountOutputType = {
    courses: number
    userProficiencies: number
    prerequisiteFor: number
    prerequisites: number
    reviewRatings: number
  }

  export type SkillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | SkillCountOutputTypeCountCoursesArgs
    userProficiencies?: boolean | SkillCountOutputTypeCountUserProficienciesArgs
    prerequisiteFor?: boolean | SkillCountOutputTypeCountPrerequisiteForArgs
    prerequisites?: boolean | SkillCountOutputTypeCountPrerequisitesArgs
    reviewRatings?: boolean | SkillCountOutputTypeCountReviewRatingsArgs
  }

  // Custom InputTypes
  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillCountOutputType
     */
    select?: SkillCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseSkillWhereInput
  }

  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountUserProficienciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSkillProficiencyWhereInput
  }

  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountPrerequisiteForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillPrerequisiteWhereInput
  }

  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountPrerequisitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillPrerequisiteWhereInput
  }

  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountReviewRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewSkillRatingWhereInput
  }


  /**
   * Count Type ReviewCountOutputType
   */

  export type ReviewCountOutputType = {
    votes: number
    helpfulVotes: number
    skillRatings: number
  }

  export type ReviewCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    votes?: boolean | ReviewCountOutputTypeCountVotesArgs
    helpfulVotes?: boolean | ReviewCountOutputTypeCountHelpfulVotesArgs
    skillRatings?: boolean | ReviewCountOutputTypeCountSkillRatingsArgs
  }

  // Custom InputTypes
  /**
   * ReviewCountOutputType without action
   */
  export type ReviewCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewCountOutputType
     */
    select?: ReviewCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReviewCountOutputType without action
   */
  export type ReviewCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewVoteWhereInput
  }

  /**
   * ReviewCountOutputType without action
   */
  export type ReviewCountOutputTypeCountHelpfulVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewHelpfulVoteWhereInput
  }

  /**
   * ReviewCountOutputType without action
   */
  export type ReviewCountOutputTypeCountSkillRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewSkillRatingWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    children: number
    courses: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | CategoryCountOutputTypeCountChildrenArgs
    courses?: boolean | CategoryCountOutputTypeCountCoursesArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseCategoryWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    courses: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | TagCountOutputTypeCountCoursesArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseTagWhereInput
  }


  /**
   * Count Type AchievementCountOutputType
   */

  export type AchievementCountOutputType = {
    users: number
  }

  export type AchievementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | AchievementCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementCountOutputType
     */
    select?: AchievementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    totalPoints: number | null
    reviewStreak: number | null
  }

  export type UserSumAggregateOutputType = {
    totalPoints: number | null
    reviewStreak: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    firstName: string | null
    lastName: string | null
    profileImage: string | null
    bio: string | null
    role: $Enums.UserRole | null
    isVerified: boolean | null
    verificationToken: string | null
    passwordHash: string | null
    totalPoints: number | null
    reviewStreak: number | null
    lastActiveAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    firstName: string | null
    lastName: string | null
    profileImage: string | null
    bio: string | null
    role: $Enums.UserRole | null
    isVerified: boolean | null
    verificationToken: string | null
    passwordHash: string | null
    totalPoints: number | null
    reviewStreak: number | null
    lastActiveAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    username: number
    firstName: number
    lastName: number
    profileImage: number
    bio: number
    role: number
    isVerified: number
    verificationToken: number
    passwordHash: number
    totalPoints: number
    reviewStreak: number
    lastActiveAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    totalPoints?: true
    reviewStreak?: true
  }

  export type UserSumAggregateInputType = {
    totalPoints?: true
    reviewStreak?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    firstName?: true
    lastName?: true
    profileImage?: true
    bio?: true
    role?: true
    isVerified?: true
    verificationToken?: true
    passwordHash?: true
    totalPoints?: true
    reviewStreak?: true
    lastActiveAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    firstName?: true
    lastName?: true
    profileImage?: true
    bio?: true
    role?: true
    isVerified?: true
    verificationToken?: true
    passwordHash?: true
    totalPoints?: true
    reviewStreak?: true
    lastActiveAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    firstName?: true
    lastName?: true
    profileImage?: true
    bio?: true
    role?: true
    isVerified?: true
    verificationToken?: true
    passwordHash?: true
    totalPoints?: true
    reviewStreak?: true
    lastActiveAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    username: string
    firstName: string
    lastName: string
    profileImage: string | null
    bio: string | null
    role: $Enums.UserRole
    isVerified: boolean
    verificationToken: string | null
    passwordHash: string
    totalPoints: number
    reviewStreak: number
    lastActiveAt: Date
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    profileImage?: boolean
    bio?: boolean
    role?: boolean
    isVerified?: boolean
    verificationToken?: boolean
    passwordHash?: boolean
    totalPoints?: boolean
    reviewStreak?: boolean
    lastActiveAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    reviewVotes?: boolean | User$reviewVotesArgs<ExtArgs>
    enrollments?: boolean | User$enrollmentsArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    courses?: boolean | User$coursesArgs<ExtArgs>
    skillProficiencies?: boolean | User$skillProficienciesArgs<ExtArgs>
    reviewHelpfulVotes?: boolean | User$reviewHelpfulVotesArgs<ExtArgs>
    progressReports?: boolean | User$progressReportsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    profileImage?: boolean
    bio?: boolean
    role?: boolean
    isVerified?: boolean
    verificationToken?: boolean
    passwordHash?: boolean
    totalPoints?: boolean
    reviewStreak?: boolean
    lastActiveAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    profileImage?: boolean
    bio?: boolean
    role?: boolean
    isVerified?: boolean
    verificationToken?: boolean
    passwordHash?: boolean
    totalPoints?: boolean
    reviewStreak?: boolean
    lastActiveAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    profileImage?: boolean
    bio?: boolean
    role?: boolean
    isVerified?: boolean
    verificationToken?: boolean
    passwordHash?: boolean
    totalPoints?: boolean
    reviewStreak?: boolean
    lastActiveAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "username" | "firstName" | "lastName" | "profileImage" | "bio" | "role" | "isVerified" | "verificationToken" | "passwordHash" | "totalPoints" | "reviewStreak" | "lastActiveAt" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    reviewVotes?: boolean | User$reviewVotesArgs<ExtArgs>
    enrollments?: boolean | User$enrollmentsArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    courses?: boolean | User$coursesArgs<ExtArgs>
    skillProficiencies?: boolean | User$skillProficienciesArgs<ExtArgs>
    reviewHelpfulVotes?: boolean | User$reviewHelpfulVotesArgs<ExtArgs>
    progressReports?: boolean | User$progressReportsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      reviewVotes: Prisma.$ReviewVotePayload<ExtArgs>[]
      enrollments: Prisma.$CourseEnrollmentPayload<ExtArgs>[]
      achievements: Prisma.$UserAchievementPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      courses: Prisma.$CoursePayload<ExtArgs>[]
      skillProficiencies: Prisma.$UserSkillProficiencyPayload<ExtArgs>[]
      reviewHelpfulVotes: Prisma.$ReviewHelpfulVotePayload<ExtArgs>[]
      progressReports: Prisma.$ProgressReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      username: string
      firstName: string
      lastName: string
      profileImage: string | null
      bio: string | null
      role: $Enums.UserRole
      isVerified: boolean
      verificationToken: string | null
      passwordHash: string
      totalPoints: number
      reviewStreak: number
      lastActiveAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewVotes<T extends User$reviewVotesArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewVotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enrollments<T extends User$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    achievements<T extends User$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, User$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    courses<T extends User$coursesArgs<ExtArgs> = {}>(args?: Subset<T, User$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    skillProficiencies<T extends User$skillProficienciesArgs<ExtArgs> = {}>(args?: Subset<T, User$skillProficienciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSkillProficiencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewHelpfulVotes<T extends User$reviewHelpfulVotesArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewHelpfulVotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewHelpfulVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    progressReports<T extends User$progressReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$progressReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgressReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly profileImage: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly verificationToken: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly totalPoints: FieldRef<"User", 'Int'>
    readonly reviewStreak: FieldRef<"User", 'Int'>
    readonly lastActiveAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.reviews
   */
  export type User$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.reviewVotes
   */
  export type User$reviewVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
    where?: ReviewVoteWhereInput
    orderBy?: ReviewVoteOrderByWithRelationInput | ReviewVoteOrderByWithRelationInput[]
    cursor?: ReviewVoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewVoteScalarFieldEnum | ReviewVoteScalarFieldEnum[]
  }

  /**
   * User.enrollments
   */
  export type User$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseEnrollment
     */
    omit?: CourseEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
    where?: CourseEnrollmentWhereInput
    orderBy?: CourseEnrollmentOrderByWithRelationInput | CourseEnrollmentOrderByWithRelationInput[]
    cursor?: CourseEnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseEnrollmentScalarFieldEnum | CourseEnrollmentScalarFieldEnum[]
  }

  /**
   * User.achievements
   */
  export type User$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    cursor?: UserAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.courses
   */
  export type User$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * User.skillProficiencies
   */
  export type User$skillProficienciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkillProficiency
     */
    select?: UserSkillProficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkillProficiency
     */
    omit?: UserSkillProficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillProficiencyInclude<ExtArgs> | null
    where?: UserSkillProficiencyWhereInput
    orderBy?: UserSkillProficiencyOrderByWithRelationInput | UserSkillProficiencyOrderByWithRelationInput[]
    cursor?: UserSkillProficiencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSkillProficiencyScalarFieldEnum | UserSkillProficiencyScalarFieldEnum[]
  }

  /**
   * User.reviewHelpfulVotes
   */
  export type User$reviewHelpfulVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewHelpfulVote
     */
    select?: ReviewHelpfulVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewHelpfulVote
     */
    omit?: ReviewHelpfulVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewHelpfulVoteInclude<ExtArgs> | null
    where?: ReviewHelpfulVoteWhereInput
    orderBy?: ReviewHelpfulVoteOrderByWithRelationInput | ReviewHelpfulVoteOrderByWithRelationInput[]
    cursor?: ReviewHelpfulVoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewHelpfulVoteScalarFieldEnum | ReviewHelpfulVoteScalarFieldEnum[]
  }

  /**
   * User.progressReports
   */
  export type User$progressReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressReport
     */
    select?: ProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressReport
     */
    omit?: ProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressReportInclude<ExtArgs> | null
    where?: ProgressReportWhereInput
    orderBy?: ProgressReportOrderByWithRelationInput | ProgressReportOrderByWithRelationInput[]
    cursor?: ProgressReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgressReportScalarFieldEnum | ProgressReportScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseAvgAggregateOutputType = {
    price: Decimal | null
    rating: Decimal | null
    reviewCount: number | null
    enrollmentCount: number | null
  }

  export type CourseSumAggregateOutputType = {
    price: Decimal | null
    rating: Decimal | null
    reviewCount: number | null
    enrollmentCount: number | null
  }

  export type CourseMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    shortDescription: string | null
    imageUrl: string | null
    thumbnailUrl: string | null
    courseUrl: string | null
    instructor: string | null
    institution: string | null
    duration: string | null
    difficulty: $Enums.Difficulty | null
    status: $Enums.CourseStatus | null
    price: Decimal | null
    isFree: boolean | null
    language: string | null
    rating: Decimal | null
    reviewCount: number | null
    enrollmentCount: number | null
    isActive: boolean | null
    lastUpdated: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type CourseMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    shortDescription: string | null
    imageUrl: string | null
    thumbnailUrl: string | null
    courseUrl: string | null
    instructor: string | null
    institution: string | null
    duration: string | null
    difficulty: $Enums.Difficulty | null
    status: $Enums.CourseStatus | null
    price: Decimal | null
    isFree: boolean | null
    language: string | null
    rating: Decimal | null
    reviewCount: number | null
    enrollmentCount: number | null
    isActive: boolean | null
    lastUpdated: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    title: number
    description: number
    shortDescription: number
    imageUrl: number
    thumbnailUrl: number
    courseUrl: number
    instructor: number
    institution: number
    duration: number
    difficulty: number
    status: number
    price: number
    isFree: number
    language: number
    rating: number
    reviewCount: number
    enrollmentCount: number
    isActive: number
    prerequisites: number
    learningOutcomes: number
    syllabus: number
    lastUpdated: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type CourseAvgAggregateInputType = {
    price?: true
    rating?: true
    reviewCount?: true
    enrollmentCount?: true
  }

  export type CourseSumAggregateInputType = {
    price?: true
    rating?: true
    reviewCount?: true
    enrollmentCount?: true
  }

  export type CourseMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    shortDescription?: true
    imageUrl?: true
    thumbnailUrl?: true
    courseUrl?: true
    instructor?: true
    institution?: true
    duration?: true
    difficulty?: true
    status?: true
    price?: true
    isFree?: true
    language?: true
    rating?: true
    reviewCount?: true
    enrollmentCount?: true
    isActive?: true
    lastUpdated?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    shortDescription?: true
    imageUrl?: true
    thumbnailUrl?: true
    courseUrl?: true
    instructor?: true
    institution?: true
    duration?: true
    difficulty?: true
    status?: true
    price?: true
    isFree?: true
    language?: true
    rating?: true
    reviewCount?: true
    enrollmentCount?: true
    isActive?: true
    lastUpdated?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    shortDescription?: true
    imageUrl?: true
    thumbnailUrl?: true
    courseUrl?: true
    instructor?: true
    institution?: true
    duration?: true
    difficulty?: true
    status?: true
    price?: true
    isFree?: true
    language?: true
    rating?: true
    reviewCount?: true
    enrollmentCount?: true
    isActive?: true
    prerequisites?: true
    learningOutcomes?: true
    syllabus?: true
    lastUpdated?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _avg?: CourseAvgAggregateInputType
    _sum?: CourseSumAggregateInputType
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: string
    title: string
    description: string
    shortDescription: string | null
    imageUrl: string | null
    thumbnailUrl: string | null
    courseUrl: string
    instructor: string
    institution: string | null
    duration: string | null
    difficulty: $Enums.Difficulty
    status: $Enums.CourseStatus
    price: Decimal | null
    isFree: boolean
    language: string
    rating: Decimal | null
    reviewCount: number
    enrollmentCount: number
    isActive: boolean
    prerequisites: string[]
    learningOutcomes: string[]
    syllabus: JsonValue | null
    lastUpdated: Date | null
    createdAt: Date
    updatedAt: Date
    createdById: string
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    shortDescription?: boolean
    imageUrl?: boolean
    thumbnailUrl?: boolean
    courseUrl?: boolean
    instructor?: boolean
    institution?: boolean
    duration?: boolean
    difficulty?: boolean
    status?: boolean
    price?: boolean
    isFree?: boolean
    language?: boolean
    rating?: boolean
    reviewCount?: boolean
    enrollmentCount?: boolean
    isActive?: boolean
    prerequisites?: boolean
    learningOutcomes?: boolean
    syllabus?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    reviews?: boolean | Course$reviewsArgs<ExtArgs>
    skills?: boolean | Course$skillsArgs<ExtArgs>
    enrollments?: boolean | Course$enrollmentsArgs<ExtArgs>
    categories?: boolean | Course$categoriesArgs<ExtArgs>
    tags?: boolean | Course$tagsArgs<ExtArgs>
    modules?: boolean | Course$modulesArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    shortDescription?: boolean
    imageUrl?: boolean
    thumbnailUrl?: boolean
    courseUrl?: boolean
    instructor?: boolean
    institution?: boolean
    duration?: boolean
    difficulty?: boolean
    status?: boolean
    price?: boolean
    isFree?: boolean
    language?: boolean
    rating?: boolean
    reviewCount?: boolean
    enrollmentCount?: boolean
    isActive?: boolean
    prerequisites?: boolean
    learningOutcomes?: boolean
    syllabus?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    shortDescription?: boolean
    imageUrl?: boolean
    thumbnailUrl?: boolean
    courseUrl?: boolean
    instructor?: boolean
    institution?: boolean
    duration?: boolean
    difficulty?: boolean
    status?: boolean
    price?: boolean
    isFree?: boolean
    language?: boolean
    rating?: boolean
    reviewCount?: boolean
    enrollmentCount?: boolean
    isActive?: boolean
    prerequisites?: boolean
    learningOutcomes?: boolean
    syllabus?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    shortDescription?: boolean
    imageUrl?: boolean
    thumbnailUrl?: boolean
    courseUrl?: boolean
    instructor?: boolean
    institution?: boolean
    duration?: boolean
    difficulty?: boolean
    status?: boolean
    price?: boolean
    isFree?: boolean
    language?: boolean
    rating?: boolean
    reviewCount?: boolean
    enrollmentCount?: boolean
    isActive?: boolean
    prerequisites?: boolean
    learningOutcomes?: boolean
    syllabus?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type CourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "shortDescription" | "imageUrl" | "thumbnailUrl" | "courseUrl" | "instructor" | "institution" | "duration" | "difficulty" | "status" | "price" | "isFree" | "language" | "rating" | "reviewCount" | "enrollmentCount" | "isActive" | "prerequisites" | "learningOutcomes" | "syllabus" | "lastUpdated" | "createdAt" | "updatedAt" | "createdById", ExtArgs["result"]["course"]>
  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    reviews?: boolean | Course$reviewsArgs<ExtArgs>
    skills?: boolean | Course$skillsArgs<ExtArgs>
    enrollments?: boolean | Course$enrollmentsArgs<ExtArgs>
    categories?: boolean | Course$categoriesArgs<ExtArgs>
    tags?: boolean | Course$tagsArgs<ExtArgs>
    modules?: boolean | Course$modulesArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CourseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      skills: Prisma.$CourseSkillPayload<ExtArgs>[]
      enrollments: Prisma.$CourseEnrollmentPayload<ExtArgs>[]
      categories: Prisma.$CourseCategoryPayload<ExtArgs>[]
      tags: Prisma.$CourseTagPayload<ExtArgs>[]
      modules: Prisma.$CourseModulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      shortDescription: string | null
      imageUrl: string | null
      thumbnailUrl: string | null
      courseUrl: string
      instructor: string
      institution: string | null
      duration: string | null
      difficulty: $Enums.Difficulty
      status: $Enums.CourseStatus
      price: Prisma.Decimal | null
      isFree: boolean
      language: string
      rating: Prisma.Decimal | null
      reviewCount: number
      enrollmentCount: number
      isActive: boolean
      prerequisites: string[]
      learningOutcomes: string[]
      syllabus: Prisma.JsonValue | null
      lastUpdated: Date | null
      createdAt: Date
      updatedAt: Date
      createdById: string
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courses and returns the data saved in the database.
     * @param {CourseCreateManyAndReturnArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses and returns the data updated in the database.
     * @param {CourseUpdateManyAndReturnArgs} args - Arguments to update many Courses.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reviews<T extends Course$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Course$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    skills<T extends Course$skillsArgs<ExtArgs> = {}>(args?: Subset<T, Course$skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseSkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enrollments<T extends Course$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Course$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categories<T extends Course$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Course$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Course$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Course$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    modules<T extends Course$modulesArgs<ExtArgs> = {}>(args?: Subset<T, Course$modulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */
  interface CourseFieldRefs {
    readonly id: FieldRef<"Course", 'String'>
    readonly title: FieldRef<"Course", 'String'>
    readonly description: FieldRef<"Course", 'String'>
    readonly shortDescription: FieldRef<"Course", 'String'>
    readonly imageUrl: FieldRef<"Course", 'String'>
    readonly thumbnailUrl: FieldRef<"Course", 'String'>
    readonly courseUrl: FieldRef<"Course", 'String'>
    readonly instructor: FieldRef<"Course", 'String'>
    readonly institution: FieldRef<"Course", 'String'>
    readonly duration: FieldRef<"Course", 'String'>
    readonly difficulty: FieldRef<"Course", 'Difficulty'>
    readonly status: FieldRef<"Course", 'CourseStatus'>
    readonly price: FieldRef<"Course", 'Decimal'>
    readonly isFree: FieldRef<"Course", 'Boolean'>
    readonly language: FieldRef<"Course", 'String'>
    readonly rating: FieldRef<"Course", 'Decimal'>
    readonly reviewCount: FieldRef<"Course", 'Int'>
    readonly enrollmentCount: FieldRef<"Course", 'Int'>
    readonly isActive: FieldRef<"Course", 'Boolean'>
    readonly prerequisites: FieldRef<"Course", 'String[]'>
    readonly learningOutcomes: FieldRef<"Course", 'String[]'>
    readonly syllabus: FieldRef<"Course", 'Json'>
    readonly lastUpdated: FieldRef<"Course", 'DateTime'>
    readonly createdAt: FieldRef<"Course", 'DateTime'>
    readonly updatedAt: FieldRef<"Course", 'DateTime'>
    readonly createdById: FieldRef<"Course", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course createManyAndReturn
   */
  export type CourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
  }

  /**
   * Course updateManyAndReturn
   */
  export type CourseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to delete.
     */
    limit?: number
  }

  /**
   * Course.reviews
   */
  export type Course$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Course.skills
   */
  export type Course$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseSkill
     */
    select?: CourseSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseSkill
     */
    omit?: CourseSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseSkillInclude<ExtArgs> | null
    where?: CourseSkillWhereInput
    orderBy?: CourseSkillOrderByWithRelationInput | CourseSkillOrderByWithRelationInput[]
    cursor?: CourseSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseSkillScalarFieldEnum | CourseSkillScalarFieldEnum[]
  }

  /**
   * Course.enrollments
   */
  export type Course$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseEnrollment
     */
    omit?: CourseEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
    where?: CourseEnrollmentWhereInput
    orderBy?: CourseEnrollmentOrderByWithRelationInput | CourseEnrollmentOrderByWithRelationInput[]
    cursor?: CourseEnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseEnrollmentScalarFieldEnum | CourseEnrollmentScalarFieldEnum[]
  }

  /**
   * Course.categories
   */
  export type Course$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCategory
     */
    select?: CourseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseCategory
     */
    omit?: CourseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCategoryInclude<ExtArgs> | null
    where?: CourseCategoryWhereInput
    orderBy?: CourseCategoryOrderByWithRelationInput | CourseCategoryOrderByWithRelationInput[]
    cursor?: CourseCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseCategoryScalarFieldEnum | CourseCategoryScalarFieldEnum[]
  }

  /**
   * Course.tags
   */
  export type Course$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTag
     */
    omit?: CourseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
    where?: CourseTagWhereInput
    orderBy?: CourseTagOrderByWithRelationInput | CourseTagOrderByWithRelationInput[]
    cursor?: CourseTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseTagScalarFieldEnum | CourseTagScalarFieldEnum[]
  }

  /**
   * Course.modules
   */
  export type Course$modulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    where?: CourseModuleWhereInput
    orderBy?: CourseModuleOrderByWithRelationInput | CourseModuleOrderByWithRelationInput[]
    cursor?: CourseModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseModuleScalarFieldEnum | CourseModuleScalarFieldEnum[]
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model Skill
   */

  export type AggregateSkill = {
    _count: SkillCountAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  export type SkillMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: string | null
    icon: string | null
    color: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SkillMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: string | null
    icon: string | null
    color: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SkillCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    icon: number
    color: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SkillMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    icon?: true
    color?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SkillMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    icon?: true
    color?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SkillCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    icon?: true
    color?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skill to aggregate.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Skills
    **/
    _count?: true | SkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillMaxAggregateInputType
  }

  export type GetSkillAggregateType<T extends SkillAggregateArgs> = {
        [P in keyof T & keyof AggregateSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkill[P]>
      : GetScalarType<T[P], AggregateSkill[P]>
  }




  export type SkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillWhereInput
    orderBy?: SkillOrderByWithAggregationInput | SkillOrderByWithAggregationInput[]
    by: SkillScalarFieldEnum[] | SkillScalarFieldEnum
    having?: SkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillCountAggregateInputType | true
    _min?: SkillMinAggregateInputType
    _max?: SkillMaxAggregateInputType
  }

  export type SkillGroupByOutputType = {
    id: string
    name: string
    description: string | null
    category: string | null
    icon: string | null
    color: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: SkillCountAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  type GetSkillGroupByPayload<T extends SkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillGroupByOutputType[P]>
            : GetScalarType<T[P], SkillGroupByOutputType[P]>
        }
      >
    >


  export type SkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    icon?: boolean
    color?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courses?: boolean | Skill$coursesArgs<ExtArgs>
    userProficiencies?: boolean | Skill$userProficienciesArgs<ExtArgs>
    prerequisiteFor?: boolean | Skill$prerequisiteForArgs<ExtArgs>
    prerequisites?: boolean | Skill$prerequisitesArgs<ExtArgs>
    reviewRatings?: boolean | Skill$reviewRatingsArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    icon?: boolean
    color?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    icon?: boolean
    color?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    icon?: boolean
    color?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "category" | "icon" | "color" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["skill"]>
  export type SkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | Skill$coursesArgs<ExtArgs>
    userProficiencies?: boolean | Skill$userProficienciesArgs<ExtArgs>
    prerequisiteFor?: boolean | Skill$prerequisiteForArgs<ExtArgs>
    prerequisites?: boolean | Skill$prerequisitesArgs<ExtArgs>
    reviewRatings?: boolean | Skill$reviewRatingsArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Skill"
    objects: {
      courses: Prisma.$CourseSkillPayload<ExtArgs>[]
      userProficiencies: Prisma.$UserSkillProficiencyPayload<ExtArgs>[]
      prerequisiteFor: Prisma.$SkillPrerequisitePayload<ExtArgs>[]
      prerequisites: Prisma.$SkillPrerequisitePayload<ExtArgs>[]
      reviewRatings: Prisma.$ReviewSkillRatingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      category: string | null
      icon: string | null
      color: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["skill"]>
    composites: {}
  }

  type SkillGetPayload<S extends boolean | null | undefined | SkillDefaultArgs> = $Result.GetResult<Prisma.$SkillPayload, S>

  type SkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SkillCountAggregateInputType | true
    }

  export interface SkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Skill'], meta: { name: 'Skill' } }
    /**
     * Find zero or one Skill that matches the filter.
     * @param {SkillFindUniqueArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkillFindUniqueArgs>(args: SelectSubset<T, SkillFindUniqueArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Skill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SkillFindUniqueOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkillFindUniqueOrThrowArgs>(args: SelectSubset<T, SkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkillFindFirstArgs>(args?: SelectSubset<T, SkillFindFirstArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkillFindFirstOrThrowArgs>(args?: SelectSubset<T, SkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Skills
     * const skills = await prisma.skill.findMany()
     * 
     * // Get first 10 Skills
     * const skills = await prisma.skill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillWithIdOnly = await prisma.skill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkillFindManyArgs>(args?: SelectSubset<T, SkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Skill.
     * @param {SkillCreateArgs} args - Arguments to create a Skill.
     * @example
     * // Create one Skill
     * const Skill = await prisma.skill.create({
     *   data: {
     *     // ... data to create a Skill
     *   }
     * })
     * 
     */
    create<T extends SkillCreateArgs>(args: SelectSubset<T, SkillCreateArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Skills.
     * @param {SkillCreateManyArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skill = await prisma.skill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkillCreateManyArgs>(args?: SelectSubset<T, SkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Skills and returns the data saved in the database.
     * @param {SkillCreateManyAndReturnArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skill = await prisma.skill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Skills and only return the `id`
     * const skillWithIdOnly = await prisma.skill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SkillCreateManyAndReturnArgs>(args?: SelectSubset<T, SkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Skill.
     * @param {SkillDeleteArgs} args - Arguments to delete one Skill.
     * @example
     * // Delete one Skill
     * const Skill = await prisma.skill.delete({
     *   where: {
     *     // ... filter to delete one Skill
     *   }
     * })
     * 
     */
    delete<T extends SkillDeleteArgs>(args: SelectSubset<T, SkillDeleteArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Skill.
     * @param {SkillUpdateArgs} args - Arguments to update one Skill.
     * @example
     * // Update one Skill
     * const skill = await prisma.skill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkillUpdateArgs>(args: SelectSubset<T, SkillUpdateArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Skills.
     * @param {SkillDeleteManyArgs} args - Arguments to filter Skills to delete.
     * @example
     * // Delete a few Skills
     * const { count } = await prisma.skill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkillDeleteManyArgs>(args?: SelectSubset<T, SkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Skills
     * const skill = await prisma.skill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkillUpdateManyArgs>(args: SelectSubset<T, SkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills and returns the data updated in the database.
     * @param {SkillUpdateManyAndReturnArgs} args - Arguments to update many Skills.
     * @example
     * // Update many Skills
     * const skill = await prisma.skill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Skills and only return the `id`
     * const skillWithIdOnly = await prisma.skill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SkillUpdateManyAndReturnArgs>(args: SelectSubset<T, SkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Skill.
     * @param {SkillUpsertArgs} args - Arguments to update or create a Skill.
     * @example
     * // Update or create a Skill
     * const skill = await prisma.skill.upsert({
     *   create: {
     *     // ... data to create a Skill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Skill we want to update
     *   }
     * })
     */
    upsert<T extends SkillUpsertArgs>(args: SelectSubset<T, SkillUpsertArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillCountArgs} args - Arguments to filter Skills to count.
     * @example
     * // Count the number of Skills
     * const count = await prisma.skill.count({
     *   where: {
     *     // ... the filter for the Skills we want to count
     *   }
     * })
    **/
    count<T extends SkillCountArgs>(
      args?: Subset<T, SkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillAggregateArgs>(args: Subset<T, SkillAggregateArgs>): Prisma.PrismaPromise<GetSkillAggregateType<T>>

    /**
     * Group by Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillGroupByArgs['orderBy'] }
        : { orderBy?: SkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Skill model
   */
  readonly fields: SkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Skill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courses<T extends Skill$coursesArgs<ExtArgs> = {}>(args?: Subset<T, Skill$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseSkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userProficiencies<T extends Skill$userProficienciesArgs<ExtArgs> = {}>(args?: Subset<T, Skill$userProficienciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSkillProficiencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prerequisiteFor<T extends Skill$prerequisiteForArgs<ExtArgs> = {}>(args?: Subset<T, Skill$prerequisiteForArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPrerequisitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prerequisites<T extends Skill$prerequisitesArgs<ExtArgs> = {}>(args?: Subset<T, Skill$prerequisitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPrerequisitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewRatings<T extends Skill$reviewRatingsArgs<ExtArgs> = {}>(args?: Subset<T, Skill$reviewRatingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewSkillRatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Skill model
   */
  interface SkillFieldRefs {
    readonly id: FieldRef<"Skill", 'String'>
    readonly name: FieldRef<"Skill", 'String'>
    readonly description: FieldRef<"Skill", 'String'>
    readonly category: FieldRef<"Skill", 'String'>
    readonly icon: FieldRef<"Skill", 'String'>
    readonly color: FieldRef<"Skill", 'String'>
    readonly isActive: FieldRef<"Skill", 'Boolean'>
    readonly createdAt: FieldRef<"Skill", 'DateTime'>
    readonly updatedAt: FieldRef<"Skill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Skill findUnique
   */
  export type SkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill findUniqueOrThrow
   */
  export type SkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill findFirst
   */
  export type SkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill findFirstOrThrow
   */
  export type SkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill findMany
   */
  export type SkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skills to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill create
   */
  export type SkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to create a Skill.
     */
    data: XOR<SkillCreateInput, SkillUncheckedCreateInput>
  }

  /**
   * Skill createMany
   */
  export type SkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Skills.
     */
    data: SkillCreateManyInput | SkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Skill createManyAndReturn
   */
  export type SkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * The data used to create many Skills.
     */
    data: SkillCreateManyInput | SkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Skill update
   */
  export type SkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to update a Skill.
     */
    data: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
    /**
     * Choose, which Skill to update.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill updateMany
   */
  export type SkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Skills.
     */
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyInput>
    /**
     * Filter which Skills to update
     */
    where?: SkillWhereInput
    /**
     * Limit how many Skills to update.
     */
    limit?: number
  }

  /**
   * Skill updateManyAndReturn
   */
  export type SkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * The data used to update Skills.
     */
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyInput>
    /**
     * Filter which Skills to update
     */
    where?: SkillWhereInput
    /**
     * Limit how many Skills to update.
     */
    limit?: number
  }

  /**
   * Skill upsert
   */
  export type SkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The filter to search for the Skill to update in case it exists.
     */
    where: SkillWhereUniqueInput
    /**
     * In case the Skill found by the `where` argument doesn't exist, create a new Skill with this data.
     */
    create: XOR<SkillCreateInput, SkillUncheckedCreateInput>
    /**
     * In case the Skill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
  }

  /**
   * Skill delete
   */
  export type SkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter which Skill to delete.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill deleteMany
   */
  export type SkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skills to delete
     */
    where?: SkillWhereInput
    /**
     * Limit how many Skills to delete.
     */
    limit?: number
  }

  /**
   * Skill.courses
   */
  export type Skill$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseSkill
     */
    select?: CourseSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseSkill
     */
    omit?: CourseSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseSkillInclude<ExtArgs> | null
    where?: CourseSkillWhereInput
    orderBy?: CourseSkillOrderByWithRelationInput | CourseSkillOrderByWithRelationInput[]
    cursor?: CourseSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseSkillScalarFieldEnum | CourseSkillScalarFieldEnum[]
  }

  /**
   * Skill.userProficiencies
   */
  export type Skill$userProficienciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkillProficiency
     */
    select?: UserSkillProficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkillProficiency
     */
    omit?: UserSkillProficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillProficiencyInclude<ExtArgs> | null
    where?: UserSkillProficiencyWhereInput
    orderBy?: UserSkillProficiencyOrderByWithRelationInput | UserSkillProficiencyOrderByWithRelationInput[]
    cursor?: UserSkillProficiencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSkillProficiencyScalarFieldEnum | UserSkillProficiencyScalarFieldEnum[]
  }

  /**
   * Skill.prerequisiteFor
   */
  export type Skill$prerequisiteForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillPrerequisite
     */
    select?: SkillPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillPrerequisite
     */
    omit?: SkillPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillPrerequisiteInclude<ExtArgs> | null
    where?: SkillPrerequisiteWhereInput
    orderBy?: SkillPrerequisiteOrderByWithRelationInput | SkillPrerequisiteOrderByWithRelationInput[]
    cursor?: SkillPrerequisiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkillPrerequisiteScalarFieldEnum | SkillPrerequisiteScalarFieldEnum[]
  }

  /**
   * Skill.prerequisites
   */
  export type Skill$prerequisitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillPrerequisite
     */
    select?: SkillPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillPrerequisite
     */
    omit?: SkillPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillPrerequisiteInclude<ExtArgs> | null
    where?: SkillPrerequisiteWhereInput
    orderBy?: SkillPrerequisiteOrderByWithRelationInput | SkillPrerequisiteOrderByWithRelationInput[]
    cursor?: SkillPrerequisiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkillPrerequisiteScalarFieldEnum | SkillPrerequisiteScalarFieldEnum[]
  }

  /**
   * Skill.reviewRatings
   */
  export type Skill$reviewRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewSkillRating
     */
    select?: ReviewSkillRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewSkillRating
     */
    omit?: ReviewSkillRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewSkillRatingInclude<ExtArgs> | null
    where?: ReviewSkillRatingWhereInput
    orderBy?: ReviewSkillRatingOrderByWithRelationInput | ReviewSkillRatingOrderByWithRelationInput[]
    cursor?: ReviewSkillRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewSkillRatingScalarFieldEnum | ReviewSkillRatingScalarFieldEnum[]
  }

  /**
   * Skill without action
   */
  export type SkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
  }


  /**
   * Model CourseSkill
   */

  export type AggregateCourseSkill = {
    _count: CourseSkillCountAggregateOutputType | null
    _avg: CourseSkillAvgAggregateOutputType | null
    _sum: CourseSkillSumAggregateOutputType | null
    _min: CourseSkillMinAggregateOutputType | null
    _max: CourseSkillMaxAggregateOutputType | null
  }

  export type CourseSkillAvgAggregateOutputType = {
    percentage: number | null
  }

  export type CourseSkillSumAggregateOutputType = {
    percentage: number | null
  }

  export type CourseSkillMinAggregateOutputType = {
    id: string | null
    courseId: string | null
    skillId: string | null
    level: $Enums.SkillLevel | null
    isCore: boolean | null
    percentage: number | null
    createdAt: Date | null
  }

  export type CourseSkillMaxAggregateOutputType = {
    id: string | null
    courseId: string | null
    skillId: string | null
    level: $Enums.SkillLevel | null
    isCore: boolean | null
    percentage: number | null
    createdAt: Date | null
  }

  export type CourseSkillCountAggregateOutputType = {
    id: number
    courseId: number
    skillId: number
    level: number
    isCore: number
    percentage: number
    createdAt: number
    _all: number
  }


  export type CourseSkillAvgAggregateInputType = {
    percentage?: true
  }

  export type CourseSkillSumAggregateInputType = {
    percentage?: true
  }

  export type CourseSkillMinAggregateInputType = {
    id?: true
    courseId?: true
    skillId?: true
    level?: true
    isCore?: true
    percentage?: true
    createdAt?: true
  }

  export type CourseSkillMaxAggregateInputType = {
    id?: true
    courseId?: true
    skillId?: true
    level?: true
    isCore?: true
    percentage?: true
    createdAt?: true
  }

  export type CourseSkillCountAggregateInputType = {
    id?: true
    courseId?: true
    skillId?: true
    level?: true
    isCore?: true
    percentage?: true
    createdAt?: true
    _all?: true
  }

  export type CourseSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseSkill to aggregate.
     */
    where?: CourseSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseSkills to fetch.
     */
    orderBy?: CourseSkillOrderByWithRelationInput | CourseSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseSkills
    **/
    _count?: true | CourseSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseSkillMaxAggregateInputType
  }

  export type GetCourseSkillAggregateType<T extends CourseSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseSkill[P]>
      : GetScalarType<T[P], AggregateCourseSkill[P]>
  }




  export type CourseSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseSkillWhereInput
    orderBy?: CourseSkillOrderByWithAggregationInput | CourseSkillOrderByWithAggregationInput[]
    by: CourseSkillScalarFieldEnum[] | CourseSkillScalarFieldEnum
    having?: CourseSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseSkillCountAggregateInputType | true
    _avg?: CourseSkillAvgAggregateInputType
    _sum?: CourseSkillSumAggregateInputType
    _min?: CourseSkillMinAggregateInputType
    _max?: CourseSkillMaxAggregateInputType
  }

  export type CourseSkillGroupByOutputType = {
    id: string
    courseId: string
    skillId: string
    level: $Enums.SkillLevel
    isCore: boolean
    percentage: number | null
    createdAt: Date
    _count: CourseSkillCountAggregateOutputType | null
    _avg: CourseSkillAvgAggregateOutputType | null
    _sum: CourseSkillSumAggregateOutputType | null
    _min: CourseSkillMinAggregateOutputType | null
    _max: CourseSkillMaxAggregateOutputType | null
  }

  type GetCourseSkillGroupByPayload<T extends CourseSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseSkillGroupByOutputType[P]>
            : GetScalarType<T[P], CourseSkillGroupByOutputType[P]>
        }
      >
    >


  export type CourseSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    skillId?: boolean
    level?: boolean
    isCore?: boolean
    percentage?: boolean
    createdAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseSkill"]>

  export type CourseSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    skillId?: boolean
    level?: boolean
    isCore?: boolean
    percentage?: boolean
    createdAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseSkill"]>

  export type CourseSkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    skillId?: boolean
    level?: boolean
    isCore?: boolean
    percentage?: boolean
    createdAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseSkill"]>

  export type CourseSkillSelectScalar = {
    id?: boolean
    courseId?: boolean
    skillId?: boolean
    level?: boolean
    isCore?: boolean
    percentage?: boolean
    createdAt?: boolean
  }

  export type CourseSkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courseId" | "skillId" | "level" | "isCore" | "percentage" | "createdAt", ExtArgs["result"]["courseSkill"]>
  export type CourseSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type CourseSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type CourseSkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }

  export type $CourseSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseSkill"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      skill: Prisma.$SkillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      courseId: string
      skillId: string
      level: $Enums.SkillLevel
      isCore: boolean
      percentage: number | null
      createdAt: Date
    }, ExtArgs["result"]["courseSkill"]>
    composites: {}
  }

  type CourseSkillGetPayload<S extends boolean | null | undefined | CourseSkillDefaultArgs> = $Result.GetResult<Prisma.$CourseSkillPayload, S>

  type CourseSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseSkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseSkillCountAggregateInputType | true
    }

  export interface CourseSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseSkill'], meta: { name: 'CourseSkill' } }
    /**
     * Find zero or one CourseSkill that matches the filter.
     * @param {CourseSkillFindUniqueArgs} args - Arguments to find a CourseSkill
     * @example
     * // Get one CourseSkill
     * const courseSkill = await prisma.courseSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseSkillFindUniqueArgs>(args: SelectSubset<T, CourseSkillFindUniqueArgs<ExtArgs>>): Prisma__CourseSkillClient<$Result.GetResult<Prisma.$CourseSkillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourseSkill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseSkillFindUniqueOrThrowArgs} args - Arguments to find a CourseSkill
     * @example
     * // Get one CourseSkill
     * const courseSkill = await prisma.courseSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseSkillClient<$Result.GetResult<Prisma.$CourseSkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseSkillFindFirstArgs} args - Arguments to find a CourseSkill
     * @example
     * // Get one CourseSkill
     * const courseSkill = await prisma.courseSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseSkillFindFirstArgs>(args?: SelectSubset<T, CourseSkillFindFirstArgs<ExtArgs>>): Prisma__CourseSkillClient<$Result.GetResult<Prisma.$CourseSkillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseSkillFindFirstOrThrowArgs} args - Arguments to find a CourseSkill
     * @example
     * // Get one CourseSkill
     * const courseSkill = await prisma.courseSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseSkillClient<$Result.GetResult<Prisma.$CourseSkillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourseSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseSkills
     * const courseSkills = await prisma.courseSkill.findMany()
     * 
     * // Get first 10 CourseSkills
     * const courseSkills = await prisma.courseSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseSkillWithIdOnly = await prisma.courseSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseSkillFindManyArgs>(args?: SelectSubset<T, CourseSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseSkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourseSkill.
     * @param {CourseSkillCreateArgs} args - Arguments to create a CourseSkill.
     * @example
     * // Create one CourseSkill
     * const CourseSkill = await prisma.courseSkill.create({
     *   data: {
     *     // ... data to create a CourseSkill
     *   }
     * })
     * 
     */
    create<T extends CourseSkillCreateArgs>(args: SelectSubset<T, CourseSkillCreateArgs<ExtArgs>>): Prisma__CourseSkillClient<$Result.GetResult<Prisma.$CourseSkillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourseSkills.
     * @param {CourseSkillCreateManyArgs} args - Arguments to create many CourseSkills.
     * @example
     * // Create many CourseSkills
     * const courseSkill = await prisma.courseSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseSkillCreateManyArgs>(args?: SelectSubset<T, CourseSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseSkills and returns the data saved in the database.
     * @param {CourseSkillCreateManyAndReturnArgs} args - Arguments to create many CourseSkills.
     * @example
     * // Create many CourseSkills
     * const courseSkill = await prisma.courseSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseSkills and only return the `id`
     * const courseSkillWithIdOnly = await prisma.courseSkill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseSkillPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CourseSkill.
     * @param {CourseSkillDeleteArgs} args - Arguments to delete one CourseSkill.
     * @example
     * // Delete one CourseSkill
     * const CourseSkill = await prisma.courseSkill.delete({
     *   where: {
     *     // ... filter to delete one CourseSkill
     *   }
     * })
     * 
     */
    delete<T extends CourseSkillDeleteArgs>(args: SelectSubset<T, CourseSkillDeleteArgs<ExtArgs>>): Prisma__CourseSkillClient<$Result.GetResult<Prisma.$CourseSkillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourseSkill.
     * @param {CourseSkillUpdateArgs} args - Arguments to update one CourseSkill.
     * @example
     * // Update one CourseSkill
     * const courseSkill = await prisma.courseSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseSkillUpdateArgs>(args: SelectSubset<T, CourseSkillUpdateArgs<ExtArgs>>): Prisma__CourseSkillClient<$Result.GetResult<Prisma.$CourseSkillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourseSkills.
     * @param {CourseSkillDeleteManyArgs} args - Arguments to filter CourseSkills to delete.
     * @example
     * // Delete a few CourseSkills
     * const { count } = await prisma.courseSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseSkillDeleteManyArgs>(args?: SelectSubset<T, CourseSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseSkills
     * const courseSkill = await prisma.courseSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseSkillUpdateManyArgs>(args: SelectSubset<T, CourseSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseSkills and returns the data updated in the database.
     * @param {CourseSkillUpdateManyAndReturnArgs} args - Arguments to update many CourseSkills.
     * @example
     * // Update many CourseSkills
     * const courseSkill = await prisma.courseSkill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CourseSkills and only return the `id`
     * const courseSkillWithIdOnly = await prisma.courseSkill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseSkillUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseSkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseSkillPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CourseSkill.
     * @param {CourseSkillUpsertArgs} args - Arguments to update or create a CourseSkill.
     * @example
     * // Update or create a CourseSkill
     * const courseSkill = await prisma.courseSkill.upsert({
     *   create: {
     *     // ... data to create a CourseSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseSkill we want to update
     *   }
     * })
     */
    upsert<T extends CourseSkillUpsertArgs>(args: SelectSubset<T, CourseSkillUpsertArgs<ExtArgs>>): Prisma__CourseSkillClient<$Result.GetResult<Prisma.$CourseSkillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourseSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseSkillCountArgs} args - Arguments to filter CourseSkills to count.
     * @example
     * // Count the number of CourseSkills
     * const count = await prisma.courseSkill.count({
     *   where: {
     *     // ... the filter for the CourseSkills we want to count
     *   }
     * })
    **/
    count<T extends CourseSkillCountArgs>(
      args?: Subset<T, CourseSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseSkillAggregateArgs>(args: Subset<T, CourseSkillAggregateArgs>): Prisma.PrismaPromise<GetCourseSkillAggregateType<T>>

    /**
     * Group by CourseSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseSkillGroupByArgs['orderBy'] }
        : { orderBy?: CourseSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseSkill model
   */
  readonly fields: CourseSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    skill<T extends SkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillDefaultArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseSkill model
   */
  interface CourseSkillFieldRefs {
    readonly id: FieldRef<"CourseSkill", 'String'>
    readonly courseId: FieldRef<"CourseSkill", 'String'>
    readonly skillId: FieldRef<"CourseSkill", 'String'>
    readonly level: FieldRef<"CourseSkill", 'SkillLevel'>
    readonly isCore: FieldRef<"CourseSkill", 'Boolean'>
    readonly percentage: FieldRef<"CourseSkill", 'Int'>
    readonly createdAt: FieldRef<"CourseSkill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CourseSkill findUnique
   */
  export type CourseSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseSkill
     */
    select?: CourseSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseSkill
     */
    omit?: CourseSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseSkillInclude<ExtArgs> | null
    /**
     * Filter, which CourseSkill to fetch.
     */
    where: CourseSkillWhereUniqueInput
  }

  /**
   * CourseSkill findUniqueOrThrow
   */
  export type CourseSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseSkill
     */
    select?: CourseSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseSkill
     */
    omit?: CourseSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseSkillInclude<ExtArgs> | null
    /**
     * Filter, which CourseSkill to fetch.
     */
    where: CourseSkillWhereUniqueInput
  }

  /**
   * CourseSkill findFirst
   */
  export type CourseSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseSkill
     */
    select?: CourseSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseSkill
     */
    omit?: CourseSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseSkillInclude<ExtArgs> | null
    /**
     * Filter, which CourseSkill to fetch.
     */
    where?: CourseSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseSkills to fetch.
     */
    orderBy?: CourseSkillOrderByWithRelationInput | CourseSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseSkills.
     */
    cursor?: CourseSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseSkills.
     */
    distinct?: CourseSkillScalarFieldEnum | CourseSkillScalarFieldEnum[]
  }

  /**
   * CourseSkill findFirstOrThrow
   */
  export type CourseSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseSkill
     */
    select?: CourseSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseSkill
     */
    omit?: CourseSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseSkillInclude<ExtArgs> | null
    /**
     * Filter, which CourseSkill to fetch.
     */
    where?: CourseSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseSkills to fetch.
     */
    orderBy?: CourseSkillOrderByWithRelationInput | CourseSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseSkills.
     */
    cursor?: CourseSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseSkills.
     */
    distinct?: CourseSkillScalarFieldEnum | CourseSkillScalarFieldEnum[]
  }

  /**
   * CourseSkill findMany
   */
  export type CourseSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseSkill
     */
    select?: CourseSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseSkill
     */
    omit?: CourseSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseSkillInclude<ExtArgs> | null
    /**
     * Filter, which CourseSkills to fetch.
     */
    where?: CourseSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseSkills to fetch.
     */
    orderBy?: CourseSkillOrderByWithRelationInput | CourseSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseSkills.
     */
    cursor?: CourseSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseSkills.
     */
    skip?: number
    distinct?: CourseSkillScalarFieldEnum | CourseSkillScalarFieldEnum[]
  }

  /**
   * CourseSkill create
   */
  export type CourseSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseSkill
     */
    select?: CourseSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseSkill
     */
    omit?: CourseSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseSkill.
     */
    data: XOR<CourseSkillCreateInput, CourseSkillUncheckedCreateInput>
  }

  /**
   * CourseSkill createMany
   */
  export type CourseSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseSkills.
     */
    data: CourseSkillCreateManyInput | CourseSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseSkill createManyAndReturn
   */
  export type CourseSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseSkill
     */
    select?: CourseSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseSkill
     */
    omit?: CourseSkillOmit<ExtArgs> | null
    /**
     * The data used to create many CourseSkills.
     */
    data: CourseSkillCreateManyInput | CourseSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseSkill update
   */
  export type CourseSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseSkill
     */
    select?: CourseSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseSkill
     */
    omit?: CourseSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseSkill.
     */
    data: XOR<CourseSkillUpdateInput, CourseSkillUncheckedUpdateInput>
    /**
     * Choose, which CourseSkill to update.
     */
    where: CourseSkillWhereUniqueInput
  }

  /**
   * CourseSkill updateMany
   */
  export type CourseSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseSkills.
     */
    data: XOR<CourseSkillUpdateManyMutationInput, CourseSkillUncheckedUpdateManyInput>
    /**
     * Filter which CourseSkills to update
     */
    where?: CourseSkillWhereInput
    /**
     * Limit how many CourseSkills to update.
     */
    limit?: number
  }

  /**
   * CourseSkill updateManyAndReturn
   */
  export type CourseSkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseSkill
     */
    select?: CourseSkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseSkill
     */
    omit?: CourseSkillOmit<ExtArgs> | null
    /**
     * The data used to update CourseSkills.
     */
    data: XOR<CourseSkillUpdateManyMutationInput, CourseSkillUncheckedUpdateManyInput>
    /**
     * Filter which CourseSkills to update
     */
    where?: CourseSkillWhereInput
    /**
     * Limit how many CourseSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseSkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseSkill upsert
   */
  export type CourseSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseSkill
     */
    select?: CourseSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseSkill
     */
    omit?: CourseSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseSkill to update in case it exists.
     */
    where: CourseSkillWhereUniqueInput
    /**
     * In case the CourseSkill found by the `where` argument doesn't exist, create a new CourseSkill with this data.
     */
    create: XOR<CourseSkillCreateInput, CourseSkillUncheckedCreateInput>
    /**
     * In case the CourseSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseSkillUpdateInput, CourseSkillUncheckedUpdateInput>
  }

  /**
   * CourseSkill delete
   */
  export type CourseSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseSkill
     */
    select?: CourseSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseSkill
     */
    omit?: CourseSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseSkillInclude<ExtArgs> | null
    /**
     * Filter which CourseSkill to delete.
     */
    where: CourseSkillWhereUniqueInput
  }

  /**
   * CourseSkill deleteMany
   */
  export type CourseSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseSkills to delete
     */
    where?: CourseSkillWhereInput
    /**
     * Limit how many CourseSkills to delete.
     */
    limit?: number
  }

  /**
   * CourseSkill without action
   */
  export type CourseSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseSkill
     */
    select?: CourseSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseSkill
     */
    omit?: CourseSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseSkillInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    overallRating: number | null
    difficultyRating: number | null
    contentQuality: number | null
    instructorRating: number | null
    valueForMoney: number | null
    helpfulCount: number | null
    flagCount: number | null
  }

  export type ReviewSumAggregateOutputType = {
    overallRating: number | null
    difficultyRating: number | null
    contentQuality: number | null
    instructorRating: number | null
    valueForMoney: number | null
    helpfulCount: number | null
    flagCount: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    userId: string | null
    courseId: string | null
    overallRating: number | null
    difficultyRating: number | null
    contentQuality: number | null
    instructorRating: number | null
    valueForMoney: number | null
    wouldRecommend: boolean | null
    title: string | null
    content: string | null
    isAnonymous: boolean | null
    isVerified: boolean | null
    helpfulCount: number | null
    flagCount: number | null
    isHidden: boolean | null
    moderatorNotes: string | null
    completionDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    courseId: string | null
    overallRating: number | null
    difficultyRating: number | null
    contentQuality: number | null
    instructorRating: number | null
    valueForMoney: number | null
    wouldRecommend: boolean | null
    title: string | null
    content: string | null
    isAnonymous: boolean | null
    isVerified: boolean | null
    helpfulCount: number | null
    flagCount: number | null
    isHidden: boolean | null
    moderatorNotes: string | null
    completionDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    userId: number
    courseId: number
    overallRating: number
    difficultyRating: number
    contentQuality: number
    instructorRating: number
    valueForMoney: number
    wouldRecommend: number
    title: number
    content: number
    pros: number
    cons: number
    isAnonymous: number
    isVerified: number
    helpfulCount: number
    flagCount: number
    isHidden: number
    moderatorNotes: number
    completionDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    overallRating?: true
    difficultyRating?: true
    contentQuality?: true
    instructorRating?: true
    valueForMoney?: true
    helpfulCount?: true
    flagCount?: true
  }

  export type ReviewSumAggregateInputType = {
    overallRating?: true
    difficultyRating?: true
    contentQuality?: true
    instructorRating?: true
    valueForMoney?: true
    helpfulCount?: true
    flagCount?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    overallRating?: true
    difficultyRating?: true
    contentQuality?: true
    instructorRating?: true
    valueForMoney?: true
    wouldRecommend?: true
    title?: true
    content?: true
    isAnonymous?: true
    isVerified?: true
    helpfulCount?: true
    flagCount?: true
    isHidden?: true
    moderatorNotes?: true
    completionDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    overallRating?: true
    difficultyRating?: true
    contentQuality?: true
    instructorRating?: true
    valueForMoney?: true
    wouldRecommend?: true
    title?: true
    content?: true
    isAnonymous?: true
    isVerified?: true
    helpfulCount?: true
    flagCount?: true
    isHidden?: true
    moderatorNotes?: true
    completionDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    overallRating?: true
    difficultyRating?: true
    contentQuality?: true
    instructorRating?: true
    valueForMoney?: true
    wouldRecommend?: true
    title?: true
    content?: true
    pros?: true
    cons?: true
    isAnonymous?: true
    isVerified?: true
    helpfulCount?: true
    flagCount?: true
    isHidden?: true
    moderatorNotes?: true
    completionDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    userId: string
    courseId: string
    overallRating: number
    difficultyRating: number | null
    contentQuality: number | null
    instructorRating: number | null
    valueForMoney: number | null
    wouldRecommend: boolean | null
    title: string
    content: string
    pros: string[]
    cons: string[]
    isAnonymous: boolean
    isVerified: boolean
    helpfulCount: number
    flagCount: number
    isHidden: boolean
    moderatorNotes: string | null
    completionDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    overallRating?: boolean
    difficultyRating?: boolean
    contentQuality?: boolean
    instructorRating?: boolean
    valueForMoney?: boolean
    wouldRecommend?: boolean
    title?: boolean
    content?: boolean
    pros?: boolean
    cons?: boolean
    isAnonymous?: boolean
    isVerified?: boolean
    helpfulCount?: boolean
    flagCount?: boolean
    isHidden?: boolean
    moderatorNotes?: boolean
    completionDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    votes?: boolean | Review$votesArgs<ExtArgs>
    helpfulVotes?: boolean | Review$helpfulVotesArgs<ExtArgs>
    skillRatings?: boolean | Review$skillRatingsArgs<ExtArgs>
    _count?: boolean | ReviewCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    overallRating?: boolean
    difficultyRating?: boolean
    contentQuality?: boolean
    instructorRating?: boolean
    valueForMoney?: boolean
    wouldRecommend?: boolean
    title?: boolean
    content?: boolean
    pros?: boolean
    cons?: boolean
    isAnonymous?: boolean
    isVerified?: boolean
    helpfulCount?: boolean
    flagCount?: boolean
    isHidden?: boolean
    moderatorNotes?: boolean
    completionDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    overallRating?: boolean
    difficultyRating?: boolean
    contentQuality?: boolean
    instructorRating?: boolean
    valueForMoney?: boolean
    wouldRecommend?: boolean
    title?: boolean
    content?: boolean
    pros?: boolean
    cons?: boolean
    isAnonymous?: boolean
    isVerified?: boolean
    helpfulCount?: boolean
    flagCount?: boolean
    isHidden?: boolean
    moderatorNotes?: boolean
    completionDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    userId?: boolean
    courseId?: boolean
    overallRating?: boolean
    difficultyRating?: boolean
    contentQuality?: boolean
    instructorRating?: boolean
    valueForMoney?: boolean
    wouldRecommend?: boolean
    title?: boolean
    content?: boolean
    pros?: boolean
    cons?: boolean
    isAnonymous?: boolean
    isVerified?: boolean
    helpfulCount?: boolean
    flagCount?: boolean
    isHidden?: boolean
    moderatorNotes?: boolean
    completionDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "courseId" | "overallRating" | "difficultyRating" | "contentQuality" | "instructorRating" | "valueForMoney" | "wouldRecommend" | "title" | "content" | "pros" | "cons" | "isAnonymous" | "isVerified" | "helpfulCount" | "flagCount" | "isHidden" | "moderatorNotes" | "completionDate" | "createdAt" | "updatedAt", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    votes?: boolean | Review$votesArgs<ExtArgs>
    helpfulVotes?: boolean | Review$helpfulVotesArgs<ExtArgs>
    skillRatings?: boolean | Review$skillRatingsArgs<ExtArgs>
    _count?: boolean | ReviewCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
      votes: Prisma.$ReviewVotePayload<ExtArgs>[]
      helpfulVotes: Prisma.$ReviewHelpfulVotePayload<ExtArgs>[]
      skillRatings: Prisma.$ReviewSkillRatingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      courseId: string
      overallRating: number
      difficultyRating: number | null
      contentQuality: number | null
      instructorRating: number | null
      valueForMoney: number | null
      wouldRecommend: boolean | null
      title: string
      content: string
      pros: string[]
      cons: string[]
      isAnonymous: boolean
      isVerified: boolean
      helpfulCount: number
      flagCount: number
      isHidden: boolean
      moderatorNotes: string | null
      completionDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    votes<T extends Review$votesArgs<ExtArgs> = {}>(args?: Subset<T, Review$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    helpfulVotes<T extends Review$helpfulVotesArgs<ExtArgs> = {}>(args?: Subset<T, Review$helpfulVotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewHelpfulVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    skillRatings<T extends Review$skillRatingsArgs<ExtArgs> = {}>(args?: Subset<T, Review$skillRatingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewSkillRatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly userId: FieldRef<"Review", 'String'>
    readonly courseId: FieldRef<"Review", 'String'>
    readonly overallRating: FieldRef<"Review", 'Int'>
    readonly difficultyRating: FieldRef<"Review", 'Int'>
    readonly contentQuality: FieldRef<"Review", 'Int'>
    readonly instructorRating: FieldRef<"Review", 'Int'>
    readonly valueForMoney: FieldRef<"Review", 'Int'>
    readonly wouldRecommend: FieldRef<"Review", 'Boolean'>
    readonly title: FieldRef<"Review", 'String'>
    readonly content: FieldRef<"Review", 'String'>
    readonly pros: FieldRef<"Review", 'String[]'>
    readonly cons: FieldRef<"Review", 'String[]'>
    readonly isAnonymous: FieldRef<"Review", 'Boolean'>
    readonly isVerified: FieldRef<"Review", 'Boolean'>
    readonly helpfulCount: FieldRef<"Review", 'Int'>
    readonly flagCount: FieldRef<"Review", 'Int'>
    readonly isHidden: FieldRef<"Review", 'Boolean'>
    readonly moderatorNotes: FieldRef<"Review", 'String'>
    readonly completionDate: FieldRef<"Review", 'DateTime'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
    readonly updatedAt: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Review updateManyAndReturn
   */
  export type ReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Review.votes
   */
  export type Review$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
    where?: ReviewVoteWhereInput
    orderBy?: ReviewVoteOrderByWithRelationInput | ReviewVoteOrderByWithRelationInput[]
    cursor?: ReviewVoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewVoteScalarFieldEnum | ReviewVoteScalarFieldEnum[]
  }

  /**
   * Review.helpfulVotes
   */
  export type Review$helpfulVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewHelpfulVote
     */
    select?: ReviewHelpfulVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewHelpfulVote
     */
    omit?: ReviewHelpfulVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewHelpfulVoteInclude<ExtArgs> | null
    where?: ReviewHelpfulVoteWhereInput
    orderBy?: ReviewHelpfulVoteOrderByWithRelationInput | ReviewHelpfulVoteOrderByWithRelationInput[]
    cursor?: ReviewHelpfulVoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewHelpfulVoteScalarFieldEnum | ReviewHelpfulVoteScalarFieldEnum[]
  }

  /**
   * Review.skillRatings
   */
  export type Review$skillRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewSkillRating
     */
    select?: ReviewSkillRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewSkillRating
     */
    omit?: ReviewSkillRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewSkillRatingInclude<ExtArgs> | null
    where?: ReviewSkillRatingWhereInput
    orderBy?: ReviewSkillRatingOrderByWithRelationInput | ReviewSkillRatingOrderByWithRelationInput[]
    cursor?: ReviewSkillRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewSkillRatingScalarFieldEnum | ReviewSkillRatingScalarFieldEnum[]
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model ReviewVote
   */

  export type AggregateReviewVote = {
    _count: ReviewVoteCountAggregateOutputType | null
    _min: ReviewVoteMinAggregateOutputType | null
    _max: ReviewVoteMaxAggregateOutputType | null
  }

  export type ReviewVoteMinAggregateOutputType = {
    id: string | null
    userId: string | null
    reviewId: string | null
    isUpvote: boolean | null
    createdAt: Date | null
  }

  export type ReviewVoteMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    reviewId: string | null
    isUpvote: boolean | null
    createdAt: Date | null
  }

  export type ReviewVoteCountAggregateOutputType = {
    id: number
    userId: number
    reviewId: number
    isUpvote: number
    createdAt: number
    _all: number
  }


  export type ReviewVoteMinAggregateInputType = {
    id?: true
    userId?: true
    reviewId?: true
    isUpvote?: true
    createdAt?: true
  }

  export type ReviewVoteMaxAggregateInputType = {
    id?: true
    userId?: true
    reviewId?: true
    isUpvote?: true
    createdAt?: true
  }

  export type ReviewVoteCountAggregateInputType = {
    id?: true
    userId?: true
    reviewId?: true
    isUpvote?: true
    createdAt?: true
    _all?: true
  }

  export type ReviewVoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewVote to aggregate.
     */
    where?: ReviewVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewVotes to fetch.
     */
    orderBy?: ReviewVoteOrderByWithRelationInput | ReviewVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReviewVotes
    **/
    _count?: true | ReviewVoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewVoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewVoteMaxAggregateInputType
  }

  export type GetReviewVoteAggregateType<T extends ReviewVoteAggregateArgs> = {
        [P in keyof T & keyof AggregateReviewVote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviewVote[P]>
      : GetScalarType<T[P], AggregateReviewVote[P]>
  }




  export type ReviewVoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewVoteWhereInput
    orderBy?: ReviewVoteOrderByWithAggregationInput | ReviewVoteOrderByWithAggregationInput[]
    by: ReviewVoteScalarFieldEnum[] | ReviewVoteScalarFieldEnum
    having?: ReviewVoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewVoteCountAggregateInputType | true
    _min?: ReviewVoteMinAggregateInputType
    _max?: ReviewVoteMaxAggregateInputType
  }

  export type ReviewVoteGroupByOutputType = {
    id: string
    userId: string
    reviewId: string
    isUpvote: boolean
    createdAt: Date
    _count: ReviewVoteCountAggregateOutputType | null
    _min: ReviewVoteMinAggregateOutputType | null
    _max: ReviewVoteMaxAggregateOutputType | null
  }

  type GetReviewVoteGroupByPayload<T extends ReviewVoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewVoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewVoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewVoteGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewVoteGroupByOutputType[P]>
        }
      >
    >


  export type ReviewVoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    reviewId?: boolean
    isUpvote?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    review?: boolean | ReviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewVote"]>

  export type ReviewVoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    reviewId?: boolean
    isUpvote?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    review?: boolean | ReviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewVote"]>

  export type ReviewVoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    reviewId?: boolean
    isUpvote?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    review?: boolean | ReviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewVote"]>

  export type ReviewVoteSelectScalar = {
    id?: boolean
    userId?: boolean
    reviewId?: boolean
    isUpvote?: boolean
    createdAt?: boolean
  }

  export type ReviewVoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "reviewId" | "isUpvote" | "createdAt", ExtArgs["result"]["reviewVote"]>
  export type ReviewVoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    review?: boolean | ReviewDefaultArgs<ExtArgs>
  }
  export type ReviewVoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    review?: boolean | ReviewDefaultArgs<ExtArgs>
  }
  export type ReviewVoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    review?: boolean | ReviewDefaultArgs<ExtArgs>
  }

  export type $ReviewVotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReviewVote"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      review: Prisma.$ReviewPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      reviewId: string
      isUpvote: boolean
      createdAt: Date
    }, ExtArgs["result"]["reviewVote"]>
    composites: {}
  }

  type ReviewVoteGetPayload<S extends boolean | null | undefined | ReviewVoteDefaultArgs> = $Result.GetResult<Prisma.$ReviewVotePayload, S>

  type ReviewVoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewVoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewVoteCountAggregateInputType | true
    }

  export interface ReviewVoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReviewVote'], meta: { name: 'ReviewVote' } }
    /**
     * Find zero or one ReviewVote that matches the filter.
     * @param {ReviewVoteFindUniqueArgs} args - Arguments to find a ReviewVote
     * @example
     * // Get one ReviewVote
     * const reviewVote = await prisma.reviewVote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewVoteFindUniqueArgs>(args: SelectSubset<T, ReviewVoteFindUniqueArgs<ExtArgs>>): Prisma__ReviewVoteClient<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReviewVote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewVoteFindUniqueOrThrowArgs} args - Arguments to find a ReviewVote
     * @example
     * // Get one ReviewVote
     * const reviewVote = await prisma.reviewVote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewVoteFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewVoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewVoteClient<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewVote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewVoteFindFirstArgs} args - Arguments to find a ReviewVote
     * @example
     * // Get one ReviewVote
     * const reviewVote = await prisma.reviewVote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewVoteFindFirstArgs>(args?: SelectSubset<T, ReviewVoteFindFirstArgs<ExtArgs>>): Prisma__ReviewVoteClient<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewVote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewVoteFindFirstOrThrowArgs} args - Arguments to find a ReviewVote
     * @example
     * // Get one ReviewVote
     * const reviewVote = await prisma.reviewVote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewVoteFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewVoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewVoteClient<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReviewVotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewVoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReviewVotes
     * const reviewVotes = await prisma.reviewVote.findMany()
     * 
     * // Get first 10 ReviewVotes
     * const reviewVotes = await prisma.reviewVote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewVoteWithIdOnly = await prisma.reviewVote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewVoteFindManyArgs>(args?: SelectSubset<T, ReviewVoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReviewVote.
     * @param {ReviewVoteCreateArgs} args - Arguments to create a ReviewVote.
     * @example
     * // Create one ReviewVote
     * const ReviewVote = await prisma.reviewVote.create({
     *   data: {
     *     // ... data to create a ReviewVote
     *   }
     * })
     * 
     */
    create<T extends ReviewVoteCreateArgs>(args: SelectSubset<T, ReviewVoteCreateArgs<ExtArgs>>): Prisma__ReviewVoteClient<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReviewVotes.
     * @param {ReviewVoteCreateManyArgs} args - Arguments to create many ReviewVotes.
     * @example
     * // Create many ReviewVotes
     * const reviewVote = await prisma.reviewVote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewVoteCreateManyArgs>(args?: SelectSubset<T, ReviewVoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReviewVotes and returns the data saved in the database.
     * @param {ReviewVoteCreateManyAndReturnArgs} args - Arguments to create many ReviewVotes.
     * @example
     * // Create many ReviewVotes
     * const reviewVote = await prisma.reviewVote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReviewVotes and only return the `id`
     * const reviewVoteWithIdOnly = await prisma.reviewVote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewVoteCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewVoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReviewVote.
     * @param {ReviewVoteDeleteArgs} args - Arguments to delete one ReviewVote.
     * @example
     * // Delete one ReviewVote
     * const ReviewVote = await prisma.reviewVote.delete({
     *   where: {
     *     // ... filter to delete one ReviewVote
     *   }
     * })
     * 
     */
    delete<T extends ReviewVoteDeleteArgs>(args: SelectSubset<T, ReviewVoteDeleteArgs<ExtArgs>>): Prisma__ReviewVoteClient<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReviewVote.
     * @param {ReviewVoteUpdateArgs} args - Arguments to update one ReviewVote.
     * @example
     * // Update one ReviewVote
     * const reviewVote = await prisma.reviewVote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewVoteUpdateArgs>(args: SelectSubset<T, ReviewVoteUpdateArgs<ExtArgs>>): Prisma__ReviewVoteClient<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReviewVotes.
     * @param {ReviewVoteDeleteManyArgs} args - Arguments to filter ReviewVotes to delete.
     * @example
     * // Delete a few ReviewVotes
     * const { count } = await prisma.reviewVote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewVoteDeleteManyArgs>(args?: SelectSubset<T, ReviewVoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewVoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReviewVotes
     * const reviewVote = await prisma.reviewVote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewVoteUpdateManyArgs>(args: SelectSubset<T, ReviewVoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewVotes and returns the data updated in the database.
     * @param {ReviewVoteUpdateManyAndReturnArgs} args - Arguments to update many ReviewVotes.
     * @example
     * // Update many ReviewVotes
     * const reviewVote = await prisma.reviewVote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReviewVotes and only return the `id`
     * const reviewVoteWithIdOnly = await prisma.reviewVote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewVoteUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewVoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReviewVote.
     * @param {ReviewVoteUpsertArgs} args - Arguments to update or create a ReviewVote.
     * @example
     * // Update or create a ReviewVote
     * const reviewVote = await prisma.reviewVote.upsert({
     *   create: {
     *     // ... data to create a ReviewVote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReviewVote we want to update
     *   }
     * })
     */
    upsert<T extends ReviewVoteUpsertArgs>(args: SelectSubset<T, ReviewVoteUpsertArgs<ExtArgs>>): Prisma__ReviewVoteClient<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReviewVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewVoteCountArgs} args - Arguments to filter ReviewVotes to count.
     * @example
     * // Count the number of ReviewVotes
     * const count = await prisma.reviewVote.count({
     *   where: {
     *     // ... the filter for the ReviewVotes we want to count
     *   }
     * })
    **/
    count<T extends ReviewVoteCountArgs>(
      args?: Subset<T, ReviewVoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewVoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReviewVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewVoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewVoteAggregateArgs>(args: Subset<T, ReviewVoteAggregateArgs>): Prisma.PrismaPromise<GetReviewVoteAggregateType<T>>

    /**
     * Group by ReviewVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewVoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewVoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewVoteGroupByArgs['orderBy'] }
        : { orderBy?: ReviewVoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewVoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewVoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReviewVote model
   */
  readonly fields: ReviewVoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReviewVote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewVoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    review<T extends ReviewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReviewDefaultArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReviewVote model
   */
  interface ReviewVoteFieldRefs {
    readonly id: FieldRef<"ReviewVote", 'String'>
    readonly userId: FieldRef<"ReviewVote", 'String'>
    readonly reviewId: FieldRef<"ReviewVote", 'String'>
    readonly isUpvote: FieldRef<"ReviewVote", 'Boolean'>
    readonly createdAt: FieldRef<"ReviewVote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReviewVote findUnique
   */
  export type ReviewVoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
    /**
     * Filter, which ReviewVote to fetch.
     */
    where: ReviewVoteWhereUniqueInput
  }

  /**
   * ReviewVote findUniqueOrThrow
   */
  export type ReviewVoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
    /**
     * Filter, which ReviewVote to fetch.
     */
    where: ReviewVoteWhereUniqueInput
  }

  /**
   * ReviewVote findFirst
   */
  export type ReviewVoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
    /**
     * Filter, which ReviewVote to fetch.
     */
    where?: ReviewVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewVotes to fetch.
     */
    orderBy?: ReviewVoteOrderByWithRelationInput | ReviewVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewVotes.
     */
    cursor?: ReviewVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewVotes.
     */
    distinct?: ReviewVoteScalarFieldEnum | ReviewVoteScalarFieldEnum[]
  }

  /**
   * ReviewVote findFirstOrThrow
   */
  export type ReviewVoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
    /**
     * Filter, which ReviewVote to fetch.
     */
    where?: ReviewVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewVotes to fetch.
     */
    orderBy?: ReviewVoteOrderByWithRelationInput | ReviewVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewVotes.
     */
    cursor?: ReviewVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewVotes.
     */
    distinct?: ReviewVoteScalarFieldEnum | ReviewVoteScalarFieldEnum[]
  }

  /**
   * ReviewVote findMany
   */
  export type ReviewVoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
    /**
     * Filter, which ReviewVotes to fetch.
     */
    where?: ReviewVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewVotes to fetch.
     */
    orderBy?: ReviewVoteOrderByWithRelationInput | ReviewVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReviewVotes.
     */
    cursor?: ReviewVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewVotes.
     */
    skip?: number
    distinct?: ReviewVoteScalarFieldEnum | ReviewVoteScalarFieldEnum[]
  }

  /**
   * ReviewVote create
   */
  export type ReviewVoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
    /**
     * The data needed to create a ReviewVote.
     */
    data: XOR<ReviewVoteCreateInput, ReviewVoteUncheckedCreateInput>
  }

  /**
   * ReviewVote createMany
   */
  export type ReviewVoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReviewVotes.
     */
    data: ReviewVoteCreateManyInput | ReviewVoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReviewVote createManyAndReturn
   */
  export type ReviewVoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * The data used to create many ReviewVotes.
     */
    data: ReviewVoteCreateManyInput | ReviewVoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewVote update
   */
  export type ReviewVoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
    /**
     * The data needed to update a ReviewVote.
     */
    data: XOR<ReviewVoteUpdateInput, ReviewVoteUncheckedUpdateInput>
    /**
     * Choose, which ReviewVote to update.
     */
    where: ReviewVoteWhereUniqueInput
  }

  /**
   * ReviewVote updateMany
   */
  export type ReviewVoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReviewVotes.
     */
    data: XOR<ReviewVoteUpdateManyMutationInput, ReviewVoteUncheckedUpdateManyInput>
    /**
     * Filter which ReviewVotes to update
     */
    where?: ReviewVoteWhereInput
    /**
     * Limit how many ReviewVotes to update.
     */
    limit?: number
  }

  /**
   * ReviewVote updateManyAndReturn
   */
  export type ReviewVoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * The data used to update ReviewVotes.
     */
    data: XOR<ReviewVoteUpdateManyMutationInput, ReviewVoteUncheckedUpdateManyInput>
    /**
     * Filter which ReviewVotes to update
     */
    where?: ReviewVoteWhereInput
    /**
     * Limit how many ReviewVotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewVote upsert
   */
  export type ReviewVoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
    /**
     * The filter to search for the ReviewVote to update in case it exists.
     */
    where: ReviewVoteWhereUniqueInput
    /**
     * In case the ReviewVote found by the `where` argument doesn't exist, create a new ReviewVote with this data.
     */
    create: XOR<ReviewVoteCreateInput, ReviewVoteUncheckedCreateInput>
    /**
     * In case the ReviewVote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewVoteUpdateInput, ReviewVoteUncheckedUpdateInput>
  }

  /**
   * ReviewVote delete
   */
  export type ReviewVoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
    /**
     * Filter which ReviewVote to delete.
     */
    where: ReviewVoteWhereUniqueInput
  }

  /**
   * ReviewVote deleteMany
   */
  export type ReviewVoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewVotes to delete
     */
    where?: ReviewVoteWhereInput
    /**
     * Limit how many ReviewVotes to delete.
     */
    limit?: number
  }

  /**
   * ReviewVote without action
   */
  export type ReviewVoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
  }


  /**
   * Model ReviewHelpfulVote
   */

  export type AggregateReviewHelpfulVote = {
    _count: ReviewHelpfulVoteCountAggregateOutputType | null
    _min: ReviewHelpfulVoteMinAggregateOutputType | null
    _max: ReviewHelpfulVoteMaxAggregateOutputType | null
  }

  export type ReviewHelpfulVoteMinAggregateOutputType = {
    id: string | null
    userId: string | null
    reviewId: string | null
    isHelpful: boolean | null
    createdAt: Date | null
  }

  export type ReviewHelpfulVoteMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    reviewId: string | null
    isHelpful: boolean | null
    createdAt: Date | null
  }

  export type ReviewHelpfulVoteCountAggregateOutputType = {
    id: number
    userId: number
    reviewId: number
    isHelpful: number
    createdAt: number
    _all: number
  }


  export type ReviewHelpfulVoteMinAggregateInputType = {
    id?: true
    userId?: true
    reviewId?: true
    isHelpful?: true
    createdAt?: true
  }

  export type ReviewHelpfulVoteMaxAggregateInputType = {
    id?: true
    userId?: true
    reviewId?: true
    isHelpful?: true
    createdAt?: true
  }

  export type ReviewHelpfulVoteCountAggregateInputType = {
    id?: true
    userId?: true
    reviewId?: true
    isHelpful?: true
    createdAt?: true
    _all?: true
  }

  export type ReviewHelpfulVoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewHelpfulVote to aggregate.
     */
    where?: ReviewHelpfulVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewHelpfulVotes to fetch.
     */
    orderBy?: ReviewHelpfulVoteOrderByWithRelationInput | ReviewHelpfulVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewHelpfulVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewHelpfulVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewHelpfulVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReviewHelpfulVotes
    **/
    _count?: true | ReviewHelpfulVoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewHelpfulVoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewHelpfulVoteMaxAggregateInputType
  }

  export type GetReviewHelpfulVoteAggregateType<T extends ReviewHelpfulVoteAggregateArgs> = {
        [P in keyof T & keyof AggregateReviewHelpfulVote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviewHelpfulVote[P]>
      : GetScalarType<T[P], AggregateReviewHelpfulVote[P]>
  }




  export type ReviewHelpfulVoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewHelpfulVoteWhereInput
    orderBy?: ReviewHelpfulVoteOrderByWithAggregationInput | ReviewHelpfulVoteOrderByWithAggregationInput[]
    by: ReviewHelpfulVoteScalarFieldEnum[] | ReviewHelpfulVoteScalarFieldEnum
    having?: ReviewHelpfulVoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewHelpfulVoteCountAggregateInputType | true
    _min?: ReviewHelpfulVoteMinAggregateInputType
    _max?: ReviewHelpfulVoteMaxAggregateInputType
  }

  export type ReviewHelpfulVoteGroupByOutputType = {
    id: string
    userId: string
    reviewId: string
    isHelpful: boolean
    createdAt: Date
    _count: ReviewHelpfulVoteCountAggregateOutputType | null
    _min: ReviewHelpfulVoteMinAggregateOutputType | null
    _max: ReviewHelpfulVoteMaxAggregateOutputType | null
  }

  type GetReviewHelpfulVoteGroupByPayload<T extends ReviewHelpfulVoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewHelpfulVoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewHelpfulVoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewHelpfulVoteGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewHelpfulVoteGroupByOutputType[P]>
        }
      >
    >


  export type ReviewHelpfulVoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    reviewId?: boolean
    isHelpful?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    review?: boolean | ReviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewHelpfulVote"]>

  export type ReviewHelpfulVoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    reviewId?: boolean
    isHelpful?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    review?: boolean | ReviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewHelpfulVote"]>

  export type ReviewHelpfulVoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    reviewId?: boolean
    isHelpful?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    review?: boolean | ReviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewHelpfulVote"]>

  export type ReviewHelpfulVoteSelectScalar = {
    id?: boolean
    userId?: boolean
    reviewId?: boolean
    isHelpful?: boolean
    createdAt?: boolean
  }

  export type ReviewHelpfulVoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "reviewId" | "isHelpful" | "createdAt", ExtArgs["result"]["reviewHelpfulVote"]>
  export type ReviewHelpfulVoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    review?: boolean | ReviewDefaultArgs<ExtArgs>
  }
  export type ReviewHelpfulVoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    review?: boolean | ReviewDefaultArgs<ExtArgs>
  }
  export type ReviewHelpfulVoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    review?: boolean | ReviewDefaultArgs<ExtArgs>
  }

  export type $ReviewHelpfulVotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReviewHelpfulVote"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      review: Prisma.$ReviewPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      reviewId: string
      isHelpful: boolean
      createdAt: Date
    }, ExtArgs["result"]["reviewHelpfulVote"]>
    composites: {}
  }

  type ReviewHelpfulVoteGetPayload<S extends boolean | null | undefined | ReviewHelpfulVoteDefaultArgs> = $Result.GetResult<Prisma.$ReviewHelpfulVotePayload, S>

  type ReviewHelpfulVoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewHelpfulVoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewHelpfulVoteCountAggregateInputType | true
    }

  export interface ReviewHelpfulVoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReviewHelpfulVote'], meta: { name: 'ReviewHelpfulVote' } }
    /**
     * Find zero or one ReviewHelpfulVote that matches the filter.
     * @param {ReviewHelpfulVoteFindUniqueArgs} args - Arguments to find a ReviewHelpfulVote
     * @example
     * // Get one ReviewHelpfulVote
     * const reviewHelpfulVote = await prisma.reviewHelpfulVote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewHelpfulVoteFindUniqueArgs>(args: SelectSubset<T, ReviewHelpfulVoteFindUniqueArgs<ExtArgs>>): Prisma__ReviewHelpfulVoteClient<$Result.GetResult<Prisma.$ReviewHelpfulVotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReviewHelpfulVote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewHelpfulVoteFindUniqueOrThrowArgs} args - Arguments to find a ReviewHelpfulVote
     * @example
     * // Get one ReviewHelpfulVote
     * const reviewHelpfulVote = await prisma.reviewHelpfulVote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewHelpfulVoteFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewHelpfulVoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewHelpfulVoteClient<$Result.GetResult<Prisma.$ReviewHelpfulVotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewHelpfulVote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewHelpfulVoteFindFirstArgs} args - Arguments to find a ReviewHelpfulVote
     * @example
     * // Get one ReviewHelpfulVote
     * const reviewHelpfulVote = await prisma.reviewHelpfulVote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewHelpfulVoteFindFirstArgs>(args?: SelectSubset<T, ReviewHelpfulVoteFindFirstArgs<ExtArgs>>): Prisma__ReviewHelpfulVoteClient<$Result.GetResult<Prisma.$ReviewHelpfulVotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewHelpfulVote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewHelpfulVoteFindFirstOrThrowArgs} args - Arguments to find a ReviewHelpfulVote
     * @example
     * // Get one ReviewHelpfulVote
     * const reviewHelpfulVote = await prisma.reviewHelpfulVote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewHelpfulVoteFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewHelpfulVoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewHelpfulVoteClient<$Result.GetResult<Prisma.$ReviewHelpfulVotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReviewHelpfulVotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewHelpfulVoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReviewHelpfulVotes
     * const reviewHelpfulVotes = await prisma.reviewHelpfulVote.findMany()
     * 
     * // Get first 10 ReviewHelpfulVotes
     * const reviewHelpfulVotes = await prisma.reviewHelpfulVote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewHelpfulVoteWithIdOnly = await prisma.reviewHelpfulVote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewHelpfulVoteFindManyArgs>(args?: SelectSubset<T, ReviewHelpfulVoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewHelpfulVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReviewHelpfulVote.
     * @param {ReviewHelpfulVoteCreateArgs} args - Arguments to create a ReviewHelpfulVote.
     * @example
     * // Create one ReviewHelpfulVote
     * const ReviewHelpfulVote = await prisma.reviewHelpfulVote.create({
     *   data: {
     *     // ... data to create a ReviewHelpfulVote
     *   }
     * })
     * 
     */
    create<T extends ReviewHelpfulVoteCreateArgs>(args: SelectSubset<T, ReviewHelpfulVoteCreateArgs<ExtArgs>>): Prisma__ReviewHelpfulVoteClient<$Result.GetResult<Prisma.$ReviewHelpfulVotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReviewHelpfulVotes.
     * @param {ReviewHelpfulVoteCreateManyArgs} args - Arguments to create many ReviewHelpfulVotes.
     * @example
     * // Create many ReviewHelpfulVotes
     * const reviewHelpfulVote = await prisma.reviewHelpfulVote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewHelpfulVoteCreateManyArgs>(args?: SelectSubset<T, ReviewHelpfulVoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReviewHelpfulVotes and returns the data saved in the database.
     * @param {ReviewHelpfulVoteCreateManyAndReturnArgs} args - Arguments to create many ReviewHelpfulVotes.
     * @example
     * // Create many ReviewHelpfulVotes
     * const reviewHelpfulVote = await prisma.reviewHelpfulVote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReviewHelpfulVotes and only return the `id`
     * const reviewHelpfulVoteWithIdOnly = await prisma.reviewHelpfulVote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewHelpfulVoteCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewHelpfulVoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewHelpfulVotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReviewHelpfulVote.
     * @param {ReviewHelpfulVoteDeleteArgs} args - Arguments to delete one ReviewHelpfulVote.
     * @example
     * // Delete one ReviewHelpfulVote
     * const ReviewHelpfulVote = await prisma.reviewHelpfulVote.delete({
     *   where: {
     *     // ... filter to delete one ReviewHelpfulVote
     *   }
     * })
     * 
     */
    delete<T extends ReviewHelpfulVoteDeleteArgs>(args: SelectSubset<T, ReviewHelpfulVoteDeleteArgs<ExtArgs>>): Prisma__ReviewHelpfulVoteClient<$Result.GetResult<Prisma.$ReviewHelpfulVotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReviewHelpfulVote.
     * @param {ReviewHelpfulVoteUpdateArgs} args - Arguments to update one ReviewHelpfulVote.
     * @example
     * // Update one ReviewHelpfulVote
     * const reviewHelpfulVote = await prisma.reviewHelpfulVote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewHelpfulVoteUpdateArgs>(args: SelectSubset<T, ReviewHelpfulVoteUpdateArgs<ExtArgs>>): Prisma__ReviewHelpfulVoteClient<$Result.GetResult<Prisma.$ReviewHelpfulVotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReviewHelpfulVotes.
     * @param {ReviewHelpfulVoteDeleteManyArgs} args - Arguments to filter ReviewHelpfulVotes to delete.
     * @example
     * // Delete a few ReviewHelpfulVotes
     * const { count } = await prisma.reviewHelpfulVote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewHelpfulVoteDeleteManyArgs>(args?: SelectSubset<T, ReviewHelpfulVoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewHelpfulVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewHelpfulVoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReviewHelpfulVotes
     * const reviewHelpfulVote = await prisma.reviewHelpfulVote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewHelpfulVoteUpdateManyArgs>(args: SelectSubset<T, ReviewHelpfulVoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewHelpfulVotes and returns the data updated in the database.
     * @param {ReviewHelpfulVoteUpdateManyAndReturnArgs} args - Arguments to update many ReviewHelpfulVotes.
     * @example
     * // Update many ReviewHelpfulVotes
     * const reviewHelpfulVote = await prisma.reviewHelpfulVote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReviewHelpfulVotes and only return the `id`
     * const reviewHelpfulVoteWithIdOnly = await prisma.reviewHelpfulVote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewHelpfulVoteUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewHelpfulVoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewHelpfulVotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReviewHelpfulVote.
     * @param {ReviewHelpfulVoteUpsertArgs} args - Arguments to update or create a ReviewHelpfulVote.
     * @example
     * // Update or create a ReviewHelpfulVote
     * const reviewHelpfulVote = await prisma.reviewHelpfulVote.upsert({
     *   create: {
     *     // ... data to create a ReviewHelpfulVote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReviewHelpfulVote we want to update
     *   }
     * })
     */
    upsert<T extends ReviewHelpfulVoteUpsertArgs>(args: SelectSubset<T, ReviewHelpfulVoteUpsertArgs<ExtArgs>>): Prisma__ReviewHelpfulVoteClient<$Result.GetResult<Prisma.$ReviewHelpfulVotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReviewHelpfulVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewHelpfulVoteCountArgs} args - Arguments to filter ReviewHelpfulVotes to count.
     * @example
     * // Count the number of ReviewHelpfulVotes
     * const count = await prisma.reviewHelpfulVote.count({
     *   where: {
     *     // ... the filter for the ReviewHelpfulVotes we want to count
     *   }
     * })
    **/
    count<T extends ReviewHelpfulVoteCountArgs>(
      args?: Subset<T, ReviewHelpfulVoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewHelpfulVoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReviewHelpfulVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewHelpfulVoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewHelpfulVoteAggregateArgs>(args: Subset<T, ReviewHelpfulVoteAggregateArgs>): Prisma.PrismaPromise<GetReviewHelpfulVoteAggregateType<T>>

    /**
     * Group by ReviewHelpfulVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewHelpfulVoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewHelpfulVoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewHelpfulVoteGroupByArgs['orderBy'] }
        : { orderBy?: ReviewHelpfulVoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewHelpfulVoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewHelpfulVoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReviewHelpfulVote model
   */
  readonly fields: ReviewHelpfulVoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReviewHelpfulVote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewHelpfulVoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    review<T extends ReviewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReviewDefaultArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReviewHelpfulVote model
   */
  interface ReviewHelpfulVoteFieldRefs {
    readonly id: FieldRef<"ReviewHelpfulVote", 'String'>
    readonly userId: FieldRef<"ReviewHelpfulVote", 'String'>
    readonly reviewId: FieldRef<"ReviewHelpfulVote", 'String'>
    readonly isHelpful: FieldRef<"ReviewHelpfulVote", 'Boolean'>
    readonly createdAt: FieldRef<"ReviewHelpfulVote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReviewHelpfulVote findUnique
   */
  export type ReviewHelpfulVoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewHelpfulVote
     */
    select?: ReviewHelpfulVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewHelpfulVote
     */
    omit?: ReviewHelpfulVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewHelpfulVoteInclude<ExtArgs> | null
    /**
     * Filter, which ReviewHelpfulVote to fetch.
     */
    where: ReviewHelpfulVoteWhereUniqueInput
  }

  /**
   * ReviewHelpfulVote findUniqueOrThrow
   */
  export type ReviewHelpfulVoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewHelpfulVote
     */
    select?: ReviewHelpfulVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewHelpfulVote
     */
    omit?: ReviewHelpfulVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewHelpfulVoteInclude<ExtArgs> | null
    /**
     * Filter, which ReviewHelpfulVote to fetch.
     */
    where: ReviewHelpfulVoteWhereUniqueInput
  }

  /**
   * ReviewHelpfulVote findFirst
   */
  export type ReviewHelpfulVoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewHelpfulVote
     */
    select?: ReviewHelpfulVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewHelpfulVote
     */
    omit?: ReviewHelpfulVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewHelpfulVoteInclude<ExtArgs> | null
    /**
     * Filter, which ReviewHelpfulVote to fetch.
     */
    where?: ReviewHelpfulVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewHelpfulVotes to fetch.
     */
    orderBy?: ReviewHelpfulVoteOrderByWithRelationInput | ReviewHelpfulVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewHelpfulVotes.
     */
    cursor?: ReviewHelpfulVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewHelpfulVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewHelpfulVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewHelpfulVotes.
     */
    distinct?: ReviewHelpfulVoteScalarFieldEnum | ReviewHelpfulVoteScalarFieldEnum[]
  }

  /**
   * ReviewHelpfulVote findFirstOrThrow
   */
  export type ReviewHelpfulVoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewHelpfulVote
     */
    select?: ReviewHelpfulVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewHelpfulVote
     */
    omit?: ReviewHelpfulVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewHelpfulVoteInclude<ExtArgs> | null
    /**
     * Filter, which ReviewHelpfulVote to fetch.
     */
    where?: ReviewHelpfulVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewHelpfulVotes to fetch.
     */
    orderBy?: ReviewHelpfulVoteOrderByWithRelationInput | ReviewHelpfulVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewHelpfulVotes.
     */
    cursor?: ReviewHelpfulVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewHelpfulVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewHelpfulVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewHelpfulVotes.
     */
    distinct?: ReviewHelpfulVoteScalarFieldEnum | ReviewHelpfulVoteScalarFieldEnum[]
  }

  /**
   * ReviewHelpfulVote findMany
   */
  export type ReviewHelpfulVoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewHelpfulVote
     */
    select?: ReviewHelpfulVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewHelpfulVote
     */
    omit?: ReviewHelpfulVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewHelpfulVoteInclude<ExtArgs> | null
    /**
     * Filter, which ReviewHelpfulVotes to fetch.
     */
    where?: ReviewHelpfulVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewHelpfulVotes to fetch.
     */
    orderBy?: ReviewHelpfulVoteOrderByWithRelationInput | ReviewHelpfulVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReviewHelpfulVotes.
     */
    cursor?: ReviewHelpfulVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewHelpfulVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewHelpfulVotes.
     */
    skip?: number
    distinct?: ReviewHelpfulVoteScalarFieldEnum | ReviewHelpfulVoteScalarFieldEnum[]
  }

  /**
   * ReviewHelpfulVote create
   */
  export type ReviewHelpfulVoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewHelpfulVote
     */
    select?: ReviewHelpfulVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewHelpfulVote
     */
    omit?: ReviewHelpfulVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewHelpfulVoteInclude<ExtArgs> | null
    /**
     * The data needed to create a ReviewHelpfulVote.
     */
    data: XOR<ReviewHelpfulVoteCreateInput, ReviewHelpfulVoteUncheckedCreateInput>
  }

  /**
   * ReviewHelpfulVote createMany
   */
  export type ReviewHelpfulVoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReviewHelpfulVotes.
     */
    data: ReviewHelpfulVoteCreateManyInput | ReviewHelpfulVoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReviewHelpfulVote createManyAndReturn
   */
  export type ReviewHelpfulVoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewHelpfulVote
     */
    select?: ReviewHelpfulVoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewHelpfulVote
     */
    omit?: ReviewHelpfulVoteOmit<ExtArgs> | null
    /**
     * The data used to create many ReviewHelpfulVotes.
     */
    data: ReviewHelpfulVoteCreateManyInput | ReviewHelpfulVoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewHelpfulVoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewHelpfulVote update
   */
  export type ReviewHelpfulVoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewHelpfulVote
     */
    select?: ReviewHelpfulVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewHelpfulVote
     */
    omit?: ReviewHelpfulVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewHelpfulVoteInclude<ExtArgs> | null
    /**
     * The data needed to update a ReviewHelpfulVote.
     */
    data: XOR<ReviewHelpfulVoteUpdateInput, ReviewHelpfulVoteUncheckedUpdateInput>
    /**
     * Choose, which ReviewHelpfulVote to update.
     */
    where: ReviewHelpfulVoteWhereUniqueInput
  }

  /**
   * ReviewHelpfulVote updateMany
   */
  export type ReviewHelpfulVoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReviewHelpfulVotes.
     */
    data: XOR<ReviewHelpfulVoteUpdateManyMutationInput, ReviewHelpfulVoteUncheckedUpdateManyInput>
    /**
     * Filter which ReviewHelpfulVotes to update
     */
    where?: ReviewHelpfulVoteWhereInput
    /**
     * Limit how many ReviewHelpfulVotes to update.
     */
    limit?: number
  }

  /**
   * ReviewHelpfulVote updateManyAndReturn
   */
  export type ReviewHelpfulVoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewHelpfulVote
     */
    select?: ReviewHelpfulVoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewHelpfulVote
     */
    omit?: ReviewHelpfulVoteOmit<ExtArgs> | null
    /**
     * The data used to update ReviewHelpfulVotes.
     */
    data: XOR<ReviewHelpfulVoteUpdateManyMutationInput, ReviewHelpfulVoteUncheckedUpdateManyInput>
    /**
     * Filter which ReviewHelpfulVotes to update
     */
    where?: ReviewHelpfulVoteWhereInput
    /**
     * Limit how many ReviewHelpfulVotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewHelpfulVoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewHelpfulVote upsert
   */
  export type ReviewHelpfulVoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewHelpfulVote
     */
    select?: ReviewHelpfulVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewHelpfulVote
     */
    omit?: ReviewHelpfulVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewHelpfulVoteInclude<ExtArgs> | null
    /**
     * The filter to search for the ReviewHelpfulVote to update in case it exists.
     */
    where: ReviewHelpfulVoteWhereUniqueInput
    /**
     * In case the ReviewHelpfulVote found by the `where` argument doesn't exist, create a new ReviewHelpfulVote with this data.
     */
    create: XOR<ReviewHelpfulVoteCreateInput, ReviewHelpfulVoteUncheckedCreateInput>
    /**
     * In case the ReviewHelpfulVote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewHelpfulVoteUpdateInput, ReviewHelpfulVoteUncheckedUpdateInput>
  }

  /**
   * ReviewHelpfulVote delete
   */
  export type ReviewHelpfulVoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewHelpfulVote
     */
    select?: ReviewHelpfulVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewHelpfulVote
     */
    omit?: ReviewHelpfulVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewHelpfulVoteInclude<ExtArgs> | null
    /**
     * Filter which ReviewHelpfulVote to delete.
     */
    where: ReviewHelpfulVoteWhereUniqueInput
  }

  /**
   * ReviewHelpfulVote deleteMany
   */
  export type ReviewHelpfulVoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewHelpfulVotes to delete
     */
    where?: ReviewHelpfulVoteWhereInput
    /**
     * Limit how many ReviewHelpfulVotes to delete.
     */
    limit?: number
  }

  /**
   * ReviewHelpfulVote without action
   */
  export type ReviewHelpfulVoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewHelpfulVote
     */
    select?: ReviewHelpfulVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewHelpfulVote
     */
    omit?: ReviewHelpfulVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewHelpfulVoteInclude<ExtArgs> | null
  }


  /**
   * Model ReviewSkillRating
   */

  export type AggregateReviewSkillRating = {
    _count: ReviewSkillRatingCountAggregateOutputType | null
    _avg: ReviewSkillRatingAvgAggregateOutputType | null
    _sum: ReviewSkillRatingSumAggregateOutputType | null
    _min: ReviewSkillRatingMinAggregateOutputType | null
    _max: ReviewSkillRatingMaxAggregateOutputType | null
  }

  export type ReviewSkillRatingAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewSkillRatingSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewSkillRatingMinAggregateOutputType = {
    id: string | null
    reviewId: string | null
    skillId: string | null
    rating: number | null
    createdAt: Date | null
  }

  export type ReviewSkillRatingMaxAggregateOutputType = {
    id: string | null
    reviewId: string | null
    skillId: string | null
    rating: number | null
    createdAt: Date | null
  }

  export type ReviewSkillRatingCountAggregateOutputType = {
    id: number
    reviewId: number
    skillId: number
    rating: number
    createdAt: number
    _all: number
  }


  export type ReviewSkillRatingAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewSkillRatingSumAggregateInputType = {
    rating?: true
  }

  export type ReviewSkillRatingMinAggregateInputType = {
    id?: true
    reviewId?: true
    skillId?: true
    rating?: true
    createdAt?: true
  }

  export type ReviewSkillRatingMaxAggregateInputType = {
    id?: true
    reviewId?: true
    skillId?: true
    rating?: true
    createdAt?: true
  }

  export type ReviewSkillRatingCountAggregateInputType = {
    id?: true
    reviewId?: true
    skillId?: true
    rating?: true
    createdAt?: true
    _all?: true
  }

  export type ReviewSkillRatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewSkillRating to aggregate.
     */
    where?: ReviewSkillRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewSkillRatings to fetch.
     */
    orderBy?: ReviewSkillRatingOrderByWithRelationInput | ReviewSkillRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewSkillRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewSkillRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewSkillRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReviewSkillRatings
    **/
    _count?: true | ReviewSkillRatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewSkillRatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSkillRatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewSkillRatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewSkillRatingMaxAggregateInputType
  }

  export type GetReviewSkillRatingAggregateType<T extends ReviewSkillRatingAggregateArgs> = {
        [P in keyof T & keyof AggregateReviewSkillRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviewSkillRating[P]>
      : GetScalarType<T[P], AggregateReviewSkillRating[P]>
  }




  export type ReviewSkillRatingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewSkillRatingWhereInput
    orderBy?: ReviewSkillRatingOrderByWithAggregationInput | ReviewSkillRatingOrderByWithAggregationInput[]
    by: ReviewSkillRatingScalarFieldEnum[] | ReviewSkillRatingScalarFieldEnum
    having?: ReviewSkillRatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewSkillRatingCountAggregateInputType | true
    _avg?: ReviewSkillRatingAvgAggregateInputType
    _sum?: ReviewSkillRatingSumAggregateInputType
    _min?: ReviewSkillRatingMinAggregateInputType
    _max?: ReviewSkillRatingMaxAggregateInputType
  }

  export type ReviewSkillRatingGroupByOutputType = {
    id: string
    reviewId: string
    skillId: string
    rating: number
    createdAt: Date
    _count: ReviewSkillRatingCountAggregateOutputType | null
    _avg: ReviewSkillRatingAvgAggregateOutputType | null
    _sum: ReviewSkillRatingSumAggregateOutputType | null
    _min: ReviewSkillRatingMinAggregateOutputType | null
    _max: ReviewSkillRatingMaxAggregateOutputType | null
  }

  type GetReviewSkillRatingGroupByPayload<T extends ReviewSkillRatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewSkillRatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewSkillRatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewSkillRatingGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewSkillRatingGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSkillRatingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    skillId?: boolean
    rating?: boolean
    createdAt?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewSkillRating"]>

  export type ReviewSkillRatingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    skillId?: boolean
    rating?: boolean
    createdAt?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewSkillRating"]>

  export type ReviewSkillRatingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    skillId?: boolean
    rating?: boolean
    createdAt?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewSkillRating"]>

  export type ReviewSkillRatingSelectScalar = {
    id?: boolean
    reviewId?: boolean
    skillId?: boolean
    rating?: boolean
    createdAt?: boolean
  }

  export type ReviewSkillRatingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reviewId" | "skillId" | "rating" | "createdAt", ExtArgs["result"]["reviewSkillRating"]>
  export type ReviewSkillRatingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type ReviewSkillRatingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type ReviewSkillRatingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }

  export type $ReviewSkillRatingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReviewSkillRating"
    objects: {
      review: Prisma.$ReviewPayload<ExtArgs>
      skill: Prisma.$SkillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reviewId: string
      skillId: string
      rating: number
      createdAt: Date
    }, ExtArgs["result"]["reviewSkillRating"]>
    composites: {}
  }

  type ReviewSkillRatingGetPayload<S extends boolean | null | undefined | ReviewSkillRatingDefaultArgs> = $Result.GetResult<Prisma.$ReviewSkillRatingPayload, S>

  type ReviewSkillRatingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewSkillRatingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewSkillRatingCountAggregateInputType | true
    }

  export interface ReviewSkillRatingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReviewSkillRating'], meta: { name: 'ReviewSkillRating' } }
    /**
     * Find zero or one ReviewSkillRating that matches the filter.
     * @param {ReviewSkillRatingFindUniqueArgs} args - Arguments to find a ReviewSkillRating
     * @example
     * // Get one ReviewSkillRating
     * const reviewSkillRating = await prisma.reviewSkillRating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewSkillRatingFindUniqueArgs>(args: SelectSubset<T, ReviewSkillRatingFindUniqueArgs<ExtArgs>>): Prisma__ReviewSkillRatingClient<$Result.GetResult<Prisma.$ReviewSkillRatingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReviewSkillRating that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewSkillRatingFindUniqueOrThrowArgs} args - Arguments to find a ReviewSkillRating
     * @example
     * // Get one ReviewSkillRating
     * const reviewSkillRating = await prisma.reviewSkillRating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewSkillRatingFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewSkillRatingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewSkillRatingClient<$Result.GetResult<Prisma.$ReviewSkillRatingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewSkillRating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewSkillRatingFindFirstArgs} args - Arguments to find a ReviewSkillRating
     * @example
     * // Get one ReviewSkillRating
     * const reviewSkillRating = await prisma.reviewSkillRating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewSkillRatingFindFirstArgs>(args?: SelectSubset<T, ReviewSkillRatingFindFirstArgs<ExtArgs>>): Prisma__ReviewSkillRatingClient<$Result.GetResult<Prisma.$ReviewSkillRatingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewSkillRating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewSkillRatingFindFirstOrThrowArgs} args - Arguments to find a ReviewSkillRating
     * @example
     * // Get one ReviewSkillRating
     * const reviewSkillRating = await prisma.reviewSkillRating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewSkillRatingFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewSkillRatingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewSkillRatingClient<$Result.GetResult<Prisma.$ReviewSkillRatingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReviewSkillRatings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewSkillRatingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReviewSkillRatings
     * const reviewSkillRatings = await prisma.reviewSkillRating.findMany()
     * 
     * // Get first 10 ReviewSkillRatings
     * const reviewSkillRatings = await prisma.reviewSkillRating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewSkillRatingWithIdOnly = await prisma.reviewSkillRating.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewSkillRatingFindManyArgs>(args?: SelectSubset<T, ReviewSkillRatingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewSkillRatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReviewSkillRating.
     * @param {ReviewSkillRatingCreateArgs} args - Arguments to create a ReviewSkillRating.
     * @example
     * // Create one ReviewSkillRating
     * const ReviewSkillRating = await prisma.reviewSkillRating.create({
     *   data: {
     *     // ... data to create a ReviewSkillRating
     *   }
     * })
     * 
     */
    create<T extends ReviewSkillRatingCreateArgs>(args: SelectSubset<T, ReviewSkillRatingCreateArgs<ExtArgs>>): Prisma__ReviewSkillRatingClient<$Result.GetResult<Prisma.$ReviewSkillRatingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReviewSkillRatings.
     * @param {ReviewSkillRatingCreateManyArgs} args - Arguments to create many ReviewSkillRatings.
     * @example
     * // Create many ReviewSkillRatings
     * const reviewSkillRating = await prisma.reviewSkillRating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewSkillRatingCreateManyArgs>(args?: SelectSubset<T, ReviewSkillRatingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReviewSkillRatings and returns the data saved in the database.
     * @param {ReviewSkillRatingCreateManyAndReturnArgs} args - Arguments to create many ReviewSkillRatings.
     * @example
     * // Create many ReviewSkillRatings
     * const reviewSkillRating = await prisma.reviewSkillRating.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReviewSkillRatings and only return the `id`
     * const reviewSkillRatingWithIdOnly = await prisma.reviewSkillRating.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewSkillRatingCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewSkillRatingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewSkillRatingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReviewSkillRating.
     * @param {ReviewSkillRatingDeleteArgs} args - Arguments to delete one ReviewSkillRating.
     * @example
     * // Delete one ReviewSkillRating
     * const ReviewSkillRating = await prisma.reviewSkillRating.delete({
     *   where: {
     *     // ... filter to delete one ReviewSkillRating
     *   }
     * })
     * 
     */
    delete<T extends ReviewSkillRatingDeleteArgs>(args: SelectSubset<T, ReviewSkillRatingDeleteArgs<ExtArgs>>): Prisma__ReviewSkillRatingClient<$Result.GetResult<Prisma.$ReviewSkillRatingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReviewSkillRating.
     * @param {ReviewSkillRatingUpdateArgs} args - Arguments to update one ReviewSkillRating.
     * @example
     * // Update one ReviewSkillRating
     * const reviewSkillRating = await prisma.reviewSkillRating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewSkillRatingUpdateArgs>(args: SelectSubset<T, ReviewSkillRatingUpdateArgs<ExtArgs>>): Prisma__ReviewSkillRatingClient<$Result.GetResult<Prisma.$ReviewSkillRatingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReviewSkillRatings.
     * @param {ReviewSkillRatingDeleteManyArgs} args - Arguments to filter ReviewSkillRatings to delete.
     * @example
     * // Delete a few ReviewSkillRatings
     * const { count } = await prisma.reviewSkillRating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewSkillRatingDeleteManyArgs>(args?: SelectSubset<T, ReviewSkillRatingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewSkillRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewSkillRatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReviewSkillRatings
     * const reviewSkillRating = await prisma.reviewSkillRating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewSkillRatingUpdateManyArgs>(args: SelectSubset<T, ReviewSkillRatingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewSkillRatings and returns the data updated in the database.
     * @param {ReviewSkillRatingUpdateManyAndReturnArgs} args - Arguments to update many ReviewSkillRatings.
     * @example
     * // Update many ReviewSkillRatings
     * const reviewSkillRating = await prisma.reviewSkillRating.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReviewSkillRatings and only return the `id`
     * const reviewSkillRatingWithIdOnly = await prisma.reviewSkillRating.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewSkillRatingUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewSkillRatingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewSkillRatingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReviewSkillRating.
     * @param {ReviewSkillRatingUpsertArgs} args - Arguments to update or create a ReviewSkillRating.
     * @example
     * // Update or create a ReviewSkillRating
     * const reviewSkillRating = await prisma.reviewSkillRating.upsert({
     *   create: {
     *     // ... data to create a ReviewSkillRating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReviewSkillRating we want to update
     *   }
     * })
     */
    upsert<T extends ReviewSkillRatingUpsertArgs>(args: SelectSubset<T, ReviewSkillRatingUpsertArgs<ExtArgs>>): Prisma__ReviewSkillRatingClient<$Result.GetResult<Prisma.$ReviewSkillRatingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReviewSkillRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewSkillRatingCountArgs} args - Arguments to filter ReviewSkillRatings to count.
     * @example
     * // Count the number of ReviewSkillRatings
     * const count = await prisma.reviewSkillRating.count({
     *   where: {
     *     // ... the filter for the ReviewSkillRatings we want to count
     *   }
     * })
    **/
    count<T extends ReviewSkillRatingCountArgs>(
      args?: Subset<T, ReviewSkillRatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewSkillRatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReviewSkillRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewSkillRatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewSkillRatingAggregateArgs>(args: Subset<T, ReviewSkillRatingAggregateArgs>): Prisma.PrismaPromise<GetReviewSkillRatingAggregateType<T>>

    /**
     * Group by ReviewSkillRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewSkillRatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewSkillRatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewSkillRatingGroupByArgs['orderBy'] }
        : { orderBy?: ReviewSkillRatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewSkillRatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewSkillRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReviewSkillRating model
   */
  readonly fields: ReviewSkillRatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReviewSkillRating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewSkillRatingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    review<T extends ReviewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReviewDefaultArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    skill<T extends SkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillDefaultArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReviewSkillRating model
   */
  interface ReviewSkillRatingFieldRefs {
    readonly id: FieldRef<"ReviewSkillRating", 'String'>
    readonly reviewId: FieldRef<"ReviewSkillRating", 'String'>
    readonly skillId: FieldRef<"ReviewSkillRating", 'String'>
    readonly rating: FieldRef<"ReviewSkillRating", 'Int'>
    readonly createdAt: FieldRef<"ReviewSkillRating", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReviewSkillRating findUnique
   */
  export type ReviewSkillRatingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewSkillRating
     */
    select?: ReviewSkillRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewSkillRating
     */
    omit?: ReviewSkillRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewSkillRatingInclude<ExtArgs> | null
    /**
     * Filter, which ReviewSkillRating to fetch.
     */
    where: ReviewSkillRatingWhereUniqueInput
  }

  /**
   * ReviewSkillRating findUniqueOrThrow
   */
  export type ReviewSkillRatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewSkillRating
     */
    select?: ReviewSkillRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewSkillRating
     */
    omit?: ReviewSkillRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewSkillRatingInclude<ExtArgs> | null
    /**
     * Filter, which ReviewSkillRating to fetch.
     */
    where: ReviewSkillRatingWhereUniqueInput
  }

  /**
   * ReviewSkillRating findFirst
   */
  export type ReviewSkillRatingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewSkillRating
     */
    select?: ReviewSkillRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewSkillRating
     */
    omit?: ReviewSkillRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewSkillRatingInclude<ExtArgs> | null
    /**
     * Filter, which ReviewSkillRating to fetch.
     */
    where?: ReviewSkillRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewSkillRatings to fetch.
     */
    orderBy?: ReviewSkillRatingOrderByWithRelationInput | ReviewSkillRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewSkillRatings.
     */
    cursor?: ReviewSkillRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewSkillRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewSkillRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewSkillRatings.
     */
    distinct?: ReviewSkillRatingScalarFieldEnum | ReviewSkillRatingScalarFieldEnum[]
  }

  /**
   * ReviewSkillRating findFirstOrThrow
   */
  export type ReviewSkillRatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewSkillRating
     */
    select?: ReviewSkillRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewSkillRating
     */
    omit?: ReviewSkillRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewSkillRatingInclude<ExtArgs> | null
    /**
     * Filter, which ReviewSkillRating to fetch.
     */
    where?: ReviewSkillRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewSkillRatings to fetch.
     */
    orderBy?: ReviewSkillRatingOrderByWithRelationInput | ReviewSkillRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewSkillRatings.
     */
    cursor?: ReviewSkillRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewSkillRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewSkillRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewSkillRatings.
     */
    distinct?: ReviewSkillRatingScalarFieldEnum | ReviewSkillRatingScalarFieldEnum[]
  }

  /**
   * ReviewSkillRating findMany
   */
  export type ReviewSkillRatingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewSkillRating
     */
    select?: ReviewSkillRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewSkillRating
     */
    omit?: ReviewSkillRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewSkillRatingInclude<ExtArgs> | null
    /**
     * Filter, which ReviewSkillRatings to fetch.
     */
    where?: ReviewSkillRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewSkillRatings to fetch.
     */
    orderBy?: ReviewSkillRatingOrderByWithRelationInput | ReviewSkillRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReviewSkillRatings.
     */
    cursor?: ReviewSkillRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewSkillRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewSkillRatings.
     */
    skip?: number
    distinct?: ReviewSkillRatingScalarFieldEnum | ReviewSkillRatingScalarFieldEnum[]
  }

  /**
   * ReviewSkillRating create
   */
  export type ReviewSkillRatingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewSkillRating
     */
    select?: ReviewSkillRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewSkillRating
     */
    omit?: ReviewSkillRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewSkillRatingInclude<ExtArgs> | null
    /**
     * The data needed to create a ReviewSkillRating.
     */
    data: XOR<ReviewSkillRatingCreateInput, ReviewSkillRatingUncheckedCreateInput>
  }

  /**
   * ReviewSkillRating createMany
   */
  export type ReviewSkillRatingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReviewSkillRatings.
     */
    data: ReviewSkillRatingCreateManyInput | ReviewSkillRatingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReviewSkillRating createManyAndReturn
   */
  export type ReviewSkillRatingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewSkillRating
     */
    select?: ReviewSkillRatingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewSkillRating
     */
    omit?: ReviewSkillRatingOmit<ExtArgs> | null
    /**
     * The data used to create many ReviewSkillRatings.
     */
    data: ReviewSkillRatingCreateManyInput | ReviewSkillRatingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewSkillRatingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewSkillRating update
   */
  export type ReviewSkillRatingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewSkillRating
     */
    select?: ReviewSkillRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewSkillRating
     */
    omit?: ReviewSkillRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewSkillRatingInclude<ExtArgs> | null
    /**
     * The data needed to update a ReviewSkillRating.
     */
    data: XOR<ReviewSkillRatingUpdateInput, ReviewSkillRatingUncheckedUpdateInput>
    /**
     * Choose, which ReviewSkillRating to update.
     */
    where: ReviewSkillRatingWhereUniqueInput
  }

  /**
   * ReviewSkillRating updateMany
   */
  export type ReviewSkillRatingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReviewSkillRatings.
     */
    data: XOR<ReviewSkillRatingUpdateManyMutationInput, ReviewSkillRatingUncheckedUpdateManyInput>
    /**
     * Filter which ReviewSkillRatings to update
     */
    where?: ReviewSkillRatingWhereInput
    /**
     * Limit how many ReviewSkillRatings to update.
     */
    limit?: number
  }

  /**
   * ReviewSkillRating updateManyAndReturn
   */
  export type ReviewSkillRatingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewSkillRating
     */
    select?: ReviewSkillRatingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewSkillRating
     */
    omit?: ReviewSkillRatingOmit<ExtArgs> | null
    /**
     * The data used to update ReviewSkillRatings.
     */
    data: XOR<ReviewSkillRatingUpdateManyMutationInput, ReviewSkillRatingUncheckedUpdateManyInput>
    /**
     * Filter which ReviewSkillRatings to update
     */
    where?: ReviewSkillRatingWhereInput
    /**
     * Limit how many ReviewSkillRatings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewSkillRatingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewSkillRating upsert
   */
  export type ReviewSkillRatingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewSkillRating
     */
    select?: ReviewSkillRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewSkillRating
     */
    omit?: ReviewSkillRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewSkillRatingInclude<ExtArgs> | null
    /**
     * The filter to search for the ReviewSkillRating to update in case it exists.
     */
    where: ReviewSkillRatingWhereUniqueInput
    /**
     * In case the ReviewSkillRating found by the `where` argument doesn't exist, create a new ReviewSkillRating with this data.
     */
    create: XOR<ReviewSkillRatingCreateInput, ReviewSkillRatingUncheckedCreateInput>
    /**
     * In case the ReviewSkillRating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewSkillRatingUpdateInput, ReviewSkillRatingUncheckedUpdateInput>
  }

  /**
   * ReviewSkillRating delete
   */
  export type ReviewSkillRatingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewSkillRating
     */
    select?: ReviewSkillRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewSkillRating
     */
    omit?: ReviewSkillRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewSkillRatingInclude<ExtArgs> | null
    /**
     * Filter which ReviewSkillRating to delete.
     */
    where: ReviewSkillRatingWhereUniqueInput
  }

  /**
   * ReviewSkillRating deleteMany
   */
  export type ReviewSkillRatingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewSkillRatings to delete
     */
    where?: ReviewSkillRatingWhereInput
    /**
     * Limit how many ReviewSkillRatings to delete.
     */
    limit?: number
  }

  /**
   * ReviewSkillRating without action
   */
  export type ReviewSkillRatingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewSkillRating
     */
    select?: ReviewSkillRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewSkillRating
     */
    omit?: ReviewSkillRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewSkillRatingInclude<ExtArgs> | null
  }


  /**
   * Model CourseEnrollment
   */

  export type AggregateCourseEnrollment = {
    _count: CourseEnrollmentCountAggregateOutputType | null
    _avg: CourseEnrollmentAvgAggregateOutputType | null
    _sum: CourseEnrollmentSumAggregateOutputType | null
    _min: CourseEnrollmentMinAggregateOutputType | null
    _max: CourseEnrollmentMaxAggregateOutputType | null
  }

  export type CourseEnrollmentAvgAggregateOutputType = {
    progress: number | null
  }

  export type CourseEnrollmentSumAggregateOutputType = {
    progress: number | null
  }

  export type CourseEnrollmentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    courseId: string | null
    enrolledAt: Date | null
    completedAt: Date | null
    progress: number | null
    lastAccessed: Date | null
    status: string | null
    certificateUrl: string | null
  }

  export type CourseEnrollmentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    courseId: string | null
    enrolledAt: Date | null
    completedAt: Date | null
    progress: number | null
    lastAccessed: Date | null
    status: string | null
    certificateUrl: string | null
  }

  export type CourseEnrollmentCountAggregateOutputType = {
    id: number
    userId: number
    courseId: number
    enrolledAt: number
    completedAt: number
    progress: number
    lastAccessed: number
    status: number
    certificateUrl: number
    _all: number
  }


  export type CourseEnrollmentAvgAggregateInputType = {
    progress?: true
  }

  export type CourseEnrollmentSumAggregateInputType = {
    progress?: true
  }

  export type CourseEnrollmentMinAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    enrolledAt?: true
    completedAt?: true
    progress?: true
    lastAccessed?: true
    status?: true
    certificateUrl?: true
  }

  export type CourseEnrollmentMaxAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    enrolledAt?: true
    completedAt?: true
    progress?: true
    lastAccessed?: true
    status?: true
    certificateUrl?: true
  }

  export type CourseEnrollmentCountAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    enrolledAt?: true
    completedAt?: true
    progress?: true
    lastAccessed?: true
    status?: true
    certificateUrl?: true
    _all?: true
  }

  export type CourseEnrollmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseEnrollment to aggregate.
     */
    where?: CourseEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseEnrollments to fetch.
     */
    orderBy?: CourseEnrollmentOrderByWithRelationInput | CourseEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseEnrollments
    **/
    _count?: true | CourseEnrollmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseEnrollmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseEnrollmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseEnrollmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseEnrollmentMaxAggregateInputType
  }

  export type GetCourseEnrollmentAggregateType<T extends CourseEnrollmentAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseEnrollment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseEnrollment[P]>
      : GetScalarType<T[P], AggregateCourseEnrollment[P]>
  }




  export type CourseEnrollmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseEnrollmentWhereInput
    orderBy?: CourseEnrollmentOrderByWithAggregationInput | CourseEnrollmentOrderByWithAggregationInput[]
    by: CourseEnrollmentScalarFieldEnum[] | CourseEnrollmentScalarFieldEnum
    having?: CourseEnrollmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseEnrollmentCountAggregateInputType | true
    _avg?: CourseEnrollmentAvgAggregateInputType
    _sum?: CourseEnrollmentSumAggregateInputType
    _min?: CourseEnrollmentMinAggregateInputType
    _max?: CourseEnrollmentMaxAggregateInputType
  }

  export type CourseEnrollmentGroupByOutputType = {
    id: string
    userId: string
    courseId: string
    enrolledAt: Date
    completedAt: Date | null
    progress: number
    lastAccessed: Date
    status: string
    certificateUrl: string | null
    _count: CourseEnrollmentCountAggregateOutputType | null
    _avg: CourseEnrollmentAvgAggregateOutputType | null
    _sum: CourseEnrollmentSumAggregateOutputType | null
    _min: CourseEnrollmentMinAggregateOutputType | null
    _max: CourseEnrollmentMaxAggregateOutputType | null
  }

  type GetCourseEnrollmentGroupByPayload<T extends CourseEnrollmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseEnrollmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseEnrollmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseEnrollmentGroupByOutputType[P]>
            : GetScalarType<T[P], CourseEnrollmentGroupByOutputType[P]>
        }
      >
    >


  export type CourseEnrollmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    enrolledAt?: boolean
    completedAt?: boolean
    progress?: boolean
    lastAccessed?: boolean
    status?: boolean
    certificateUrl?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseEnrollment"]>

  export type CourseEnrollmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    enrolledAt?: boolean
    completedAt?: boolean
    progress?: boolean
    lastAccessed?: boolean
    status?: boolean
    certificateUrl?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseEnrollment"]>

  export type CourseEnrollmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    enrolledAt?: boolean
    completedAt?: boolean
    progress?: boolean
    lastAccessed?: boolean
    status?: boolean
    certificateUrl?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseEnrollment"]>

  export type CourseEnrollmentSelectScalar = {
    id?: boolean
    userId?: boolean
    courseId?: boolean
    enrolledAt?: boolean
    completedAt?: boolean
    progress?: boolean
    lastAccessed?: boolean
    status?: boolean
    certificateUrl?: boolean
  }

  export type CourseEnrollmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "courseId" | "enrolledAt" | "completedAt" | "progress" | "lastAccessed" | "status" | "certificateUrl", ExtArgs["result"]["courseEnrollment"]>
  export type CourseEnrollmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type CourseEnrollmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type CourseEnrollmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $CourseEnrollmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseEnrollment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      courseId: string
      enrolledAt: Date
      completedAt: Date | null
      progress: number
      lastAccessed: Date
      status: string
      certificateUrl: string | null
    }, ExtArgs["result"]["courseEnrollment"]>
    composites: {}
  }

  type CourseEnrollmentGetPayload<S extends boolean | null | undefined | CourseEnrollmentDefaultArgs> = $Result.GetResult<Prisma.$CourseEnrollmentPayload, S>

  type CourseEnrollmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseEnrollmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseEnrollmentCountAggregateInputType | true
    }

  export interface CourseEnrollmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseEnrollment'], meta: { name: 'CourseEnrollment' } }
    /**
     * Find zero or one CourseEnrollment that matches the filter.
     * @param {CourseEnrollmentFindUniqueArgs} args - Arguments to find a CourseEnrollment
     * @example
     * // Get one CourseEnrollment
     * const courseEnrollment = await prisma.courseEnrollment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseEnrollmentFindUniqueArgs>(args: SelectSubset<T, CourseEnrollmentFindUniqueArgs<ExtArgs>>): Prisma__CourseEnrollmentClient<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourseEnrollment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseEnrollmentFindUniqueOrThrowArgs} args - Arguments to find a CourseEnrollment
     * @example
     * // Get one CourseEnrollment
     * const courseEnrollment = await prisma.courseEnrollment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseEnrollmentFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseEnrollmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseEnrollmentClient<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseEnrollment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseEnrollmentFindFirstArgs} args - Arguments to find a CourseEnrollment
     * @example
     * // Get one CourseEnrollment
     * const courseEnrollment = await prisma.courseEnrollment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseEnrollmentFindFirstArgs>(args?: SelectSubset<T, CourseEnrollmentFindFirstArgs<ExtArgs>>): Prisma__CourseEnrollmentClient<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseEnrollment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseEnrollmentFindFirstOrThrowArgs} args - Arguments to find a CourseEnrollment
     * @example
     * // Get one CourseEnrollment
     * const courseEnrollment = await prisma.courseEnrollment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseEnrollmentFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseEnrollmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseEnrollmentClient<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourseEnrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseEnrollmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseEnrollments
     * const courseEnrollments = await prisma.courseEnrollment.findMany()
     * 
     * // Get first 10 CourseEnrollments
     * const courseEnrollments = await prisma.courseEnrollment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseEnrollmentWithIdOnly = await prisma.courseEnrollment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseEnrollmentFindManyArgs>(args?: SelectSubset<T, CourseEnrollmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourseEnrollment.
     * @param {CourseEnrollmentCreateArgs} args - Arguments to create a CourseEnrollment.
     * @example
     * // Create one CourseEnrollment
     * const CourseEnrollment = await prisma.courseEnrollment.create({
     *   data: {
     *     // ... data to create a CourseEnrollment
     *   }
     * })
     * 
     */
    create<T extends CourseEnrollmentCreateArgs>(args: SelectSubset<T, CourseEnrollmentCreateArgs<ExtArgs>>): Prisma__CourseEnrollmentClient<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourseEnrollments.
     * @param {CourseEnrollmentCreateManyArgs} args - Arguments to create many CourseEnrollments.
     * @example
     * // Create many CourseEnrollments
     * const courseEnrollment = await prisma.courseEnrollment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseEnrollmentCreateManyArgs>(args?: SelectSubset<T, CourseEnrollmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseEnrollments and returns the data saved in the database.
     * @param {CourseEnrollmentCreateManyAndReturnArgs} args - Arguments to create many CourseEnrollments.
     * @example
     * // Create many CourseEnrollments
     * const courseEnrollment = await prisma.courseEnrollment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseEnrollments and only return the `id`
     * const courseEnrollmentWithIdOnly = await prisma.courseEnrollment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseEnrollmentCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseEnrollmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CourseEnrollment.
     * @param {CourseEnrollmentDeleteArgs} args - Arguments to delete one CourseEnrollment.
     * @example
     * // Delete one CourseEnrollment
     * const CourseEnrollment = await prisma.courseEnrollment.delete({
     *   where: {
     *     // ... filter to delete one CourseEnrollment
     *   }
     * })
     * 
     */
    delete<T extends CourseEnrollmentDeleteArgs>(args: SelectSubset<T, CourseEnrollmentDeleteArgs<ExtArgs>>): Prisma__CourseEnrollmentClient<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourseEnrollment.
     * @param {CourseEnrollmentUpdateArgs} args - Arguments to update one CourseEnrollment.
     * @example
     * // Update one CourseEnrollment
     * const courseEnrollment = await prisma.courseEnrollment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseEnrollmentUpdateArgs>(args: SelectSubset<T, CourseEnrollmentUpdateArgs<ExtArgs>>): Prisma__CourseEnrollmentClient<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourseEnrollments.
     * @param {CourseEnrollmentDeleteManyArgs} args - Arguments to filter CourseEnrollments to delete.
     * @example
     * // Delete a few CourseEnrollments
     * const { count } = await prisma.courseEnrollment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseEnrollmentDeleteManyArgs>(args?: SelectSubset<T, CourseEnrollmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseEnrollmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseEnrollments
     * const courseEnrollment = await prisma.courseEnrollment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseEnrollmentUpdateManyArgs>(args: SelectSubset<T, CourseEnrollmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseEnrollments and returns the data updated in the database.
     * @param {CourseEnrollmentUpdateManyAndReturnArgs} args - Arguments to update many CourseEnrollments.
     * @example
     * // Update many CourseEnrollments
     * const courseEnrollment = await prisma.courseEnrollment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CourseEnrollments and only return the `id`
     * const courseEnrollmentWithIdOnly = await prisma.courseEnrollment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseEnrollmentUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseEnrollmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CourseEnrollment.
     * @param {CourseEnrollmentUpsertArgs} args - Arguments to update or create a CourseEnrollment.
     * @example
     * // Update or create a CourseEnrollment
     * const courseEnrollment = await prisma.courseEnrollment.upsert({
     *   create: {
     *     // ... data to create a CourseEnrollment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseEnrollment we want to update
     *   }
     * })
     */
    upsert<T extends CourseEnrollmentUpsertArgs>(args: SelectSubset<T, CourseEnrollmentUpsertArgs<ExtArgs>>): Prisma__CourseEnrollmentClient<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourseEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseEnrollmentCountArgs} args - Arguments to filter CourseEnrollments to count.
     * @example
     * // Count the number of CourseEnrollments
     * const count = await prisma.courseEnrollment.count({
     *   where: {
     *     // ... the filter for the CourseEnrollments we want to count
     *   }
     * })
    **/
    count<T extends CourseEnrollmentCountArgs>(
      args?: Subset<T, CourseEnrollmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseEnrollmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseEnrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseEnrollmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseEnrollmentAggregateArgs>(args: Subset<T, CourseEnrollmentAggregateArgs>): Prisma.PrismaPromise<GetCourseEnrollmentAggregateType<T>>

    /**
     * Group by CourseEnrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseEnrollmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseEnrollmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseEnrollmentGroupByArgs['orderBy'] }
        : { orderBy?: CourseEnrollmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseEnrollmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseEnrollmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseEnrollment model
   */
  readonly fields: CourseEnrollmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseEnrollment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseEnrollmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseEnrollment model
   */
  interface CourseEnrollmentFieldRefs {
    readonly id: FieldRef<"CourseEnrollment", 'String'>
    readonly userId: FieldRef<"CourseEnrollment", 'String'>
    readonly courseId: FieldRef<"CourseEnrollment", 'String'>
    readonly enrolledAt: FieldRef<"CourseEnrollment", 'DateTime'>
    readonly completedAt: FieldRef<"CourseEnrollment", 'DateTime'>
    readonly progress: FieldRef<"CourseEnrollment", 'Int'>
    readonly lastAccessed: FieldRef<"CourseEnrollment", 'DateTime'>
    readonly status: FieldRef<"CourseEnrollment", 'String'>
    readonly certificateUrl: FieldRef<"CourseEnrollment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CourseEnrollment findUnique
   */
  export type CourseEnrollmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseEnrollment
     */
    omit?: CourseEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which CourseEnrollment to fetch.
     */
    where: CourseEnrollmentWhereUniqueInput
  }

  /**
   * CourseEnrollment findUniqueOrThrow
   */
  export type CourseEnrollmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseEnrollment
     */
    omit?: CourseEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which CourseEnrollment to fetch.
     */
    where: CourseEnrollmentWhereUniqueInput
  }

  /**
   * CourseEnrollment findFirst
   */
  export type CourseEnrollmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseEnrollment
     */
    omit?: CourseEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which CourseEnrollment to fetch.
     */
    where?: CourseEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseEnrollments to fetch.
     */
    orderBy?: CourseEnrollmentOrderByWithRelationInput | CourseEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseEnrollments.
     */
    cursor?: CourseEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseEnrollments.
     */
    distinct?: CourseEnrollmentScalarFieldEnum | CourseEnrollmentScalarFieldEnum[]
  }

  /**
   * CourseEnrollment findFirstOrThrow
   */
  export type CourseEnrollmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseEnrollment
     */
    omit?: CourseEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which CourseEnrollment to fetch.
     */
    where?: CourseEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseEnrollments to fetch.
     */
    orderBy?: CourseEnrollmentOrderByWithRelationInput | CourseEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseEnrollments.
     */
    cursor?: CourseEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseEnrollments.
     */
    distinct?: CourseEnrollmentScalarFieldEnum | CourseEnrollmentScalarFieldEnum[]
  }

  /**
   * CourseEnrollment findMany
   */
  export type CourseEnrollmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseEnrollment
     */
    omit?: CourseEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which CourseEnrollments to fetch.
     */
    where?: CourseEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseEnrollments to fetch.
     */
    orderBy?: CourseEnrollmentOrderByWithRelationInput | CourseEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseEnrollments.
     */
    cursor?: CourseEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseEnrollments.
     */
    skip?: number
    distinct?: CourseEnrollmentScalarFieldEnum | CourseEnrollmentScalarFieldEnum[]
  }

  /**
   * CourseEnrollment create
   */
  export type CourseEnrollmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseEnrollment
     */
    omit?: CourseEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseEnrollment.
     */
    data: XOR<CourseEnrollmentCreateInput, CourseEnrollmentUncheckedCreateInput>
  }

  /**
   * CourseEnrollment createMany
   */
  export type CourseEnrollmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseEnrollments.
     */
    data: CourseEnrollmentCreateManyInput | CourseEnrollmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseEnrollment createManyAndReturn
   */
  export type CourseEnrollmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseEnrollment
     */
    omit?: CourseEnrollmentOmit<ExtArgs> | null
    /**
     * The data used to create many CourseEnrollments.
     */
    data: CourseEnrollmentCreateManyInput | CourseEnrollmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseEnrollment update
   */
  export type CourseEnrollmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseEnrollment
     */
    omit?: CourseEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseEnrollment.
     */
    data: XOR<CourseEnrollmentUpdateInput, CourseEnrollmentUncheckedUpdateInput>
    /**
     * Choose, which CourseEnrollment to update.
     */
    where: CourseEnrollmentWhereUniqueInput
  }

  /**
   * CourseEnrollment updateMany
   */
  export type CourseEnrollmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseEnrollments.
     */
    data: XOR<CourseEnrollmentUpdateManyMutationInput, CourseEnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which CourseEnrollments to update
     */
    where?: CourseEnrollmentWhereInput
    /**
     * Limit how many CourseEnrollments to update.
     */
    limit?: number
  }

  /**
   * CourseEnrollment updateManyAndReturn
   */
  export type CourseEnrollmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseEnrollment
     */
    omit?: CourseEnrollmentOmit<ExtArgs> | null
    /**
     * The data used to update CourseEnrollments.
     */
    data: XOR<CourseEnrollmentUpdateManyMutationInput, CourseEnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which CourseEnrollments to update
     */
    where?: CourseEnrollmentWhereInput
    /**
     * Limit how many CourseEnrollments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseEnrollment upsert
   */
  export type CourseEnrollmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseEnrollment
     */
    omit?: CourseEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseEnrollment to update in case it exists.
     */
    where: CourseEnrollmentWhereUniqueInput
    /**
     * In case the CourseEnrollment found by the `where` argument doesn't exist, create a new CourseEnrollment with this data.
     */
    create: XOR<CourseEnrollmentCreateInput, CourseEnrollmentUncheckedCreateInput>
    /**
     * In case the CourseEnrollment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseEnrollmentUpdateInput, CourseEnrollmentUncheckedUpdateInput>
  }

  /**
   * CourseEnrollment delete
   */
  export type CourseEnrollmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseEnrollment
     */
    omit?: CourseEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
    /**
     * Filter which CourseEnrollment to delete.
     */
    where: CourseEnrollmentWhereUniqueInput
  }

  /**
   * CourseEnrollment deleteMany
   */
  export type CourseEnrollmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseEnrollments to delete
     */
    where?: CourseEnrollmentWhereInput
    /**
     * Limit how many CourseEnrollments to delete.
     */
    limit?: number
  }

  /**
   * CourseEnrollment without action
   */
  export type CourseEnrollmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseEnrollment
     */
    omit?: CourseEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
  }


  /**
   * Model UserSkillProficiency
   */

  export type AggregateUserSkillProficiency = {
    _count: UserSkillProficiencyCountAggregateOutputType | null
    _avg: UserSkillProficiencyAvgAggregateOutputType | null
    _sum: UserSkillProficiencySumAggregateOutputType | null
    _min: UserSkillProficiencyMinAggregateOutputType | null
    _max: UserSkillProficiencyMaxAggregateOutputType | null
  }

  export type UserSkillProficiencyAvgAggregateOutputType = {
    yearsExperience: number | null
  }

  export type UserSkillProficiencySumAggregateOutputType = {
    yearsExperience: number | null
  }

  export type UserSkillProficiencyMinAggregateOutputType = {
    id: string | null
    userId: string | null
    skillId: string | null
    level: $Enums.SkillLevel | null
    yearsExperience: number | null
    lastUsed: Date | null
    isVerified: boolean | null
    verificationSource: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSkillProficiencyMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    skillId: string | null
    level: $Enums.SkillLevel | null
    yearsExperience: number | null
    lastUsed: Date | null
    isVerified: boolean | null
    verificationSource: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSkillProficiencyCountAggregateOutputType = {
    id: number
    userId: number
    skillId: number
    level: number
    yearsExperience: number
    lastUsed: number
    isVerified: number
    verificationSource: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserSkillProficiencyAvgAggregateInputType = {
    yearsExperience?: true
  }

  export type UserSkillProficiencySumAggregateInputType = {
    yearsExperience?: true
  }

  export type UserSkillProficiencyMinAggregateInputType = {
    id?: true
    userId?: true
    skillId?: true
    level?: true
    yearsExperience?: true
    lastUsed?: true
    isVerified?: true
    verificationSource?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSkillProficiencyMaxAggregateInputType = {
    id?: true
    userId?: true
    skillId?: true
    level?: true
    yearsExperience?: true
    lastUsed?: true
    isVerified?: true
    verificationSource?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSkillProficiencyCountAggregateInputType = {
    id?: true
    userId?: true
    skillId?: true
    level?: true
    yearsExperience?: true
    lastUsed?: true
    isVerified?: true
    verificationSource?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserSkillProficiencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSkillProficiency to aggregate.
     */
    where?: UserSkillProficiencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSkillProficiencies to fetch.
     */
    orderBy?: UserSkillProficiencyOrderByWithRelationInput | UserSkillProficiencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSkillProficiencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSkillProficiencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSkillProficiencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSkillProficiencies
    **/
    _count?: true | UserSkillProficiencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSkillProficiencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSkillProficiencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSkillProficiencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSkillProficiencyMaxAggregateInputType
  }

  export type GetUserSkillProficiencyAggregateType<T extends UserSkillProficiencyAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSkillProficiency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSkillProficiency[P]>
      : GetScalarType<T[P], AggregateUserSkillProficiency[P]>
  }




  export type UserSkillProficiencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSkillProficiencyWhereInput
    orderBy?: UserSkillProficiencyOrderByWithAggregationInput | UserSkillProficiencyOrderByWithAggregationInput[]
    by: UserSkillProficiencyScalarFieldEnum[] | UserSkillProficiencyScalarFieldEnum
    having?: UserSkillProficiencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSkillProficiencyCountAggregateInputType | true
    _avg?: UserSkillProficiencyAvgAggregateInputType
    _sum?: UserSkillProficiencySumAggregateInputType
    _min?: UserSkillProficiencyMinAggregateInputType
    _max?: UserSkillProficiencyMaxAggregateInputType
  }

  export type UserSkillProficiencyGroupByOutputType = {
    id: string
    userId: string
    skillId: string
    level: $Enums.SkillLevel
    yearsExperience: number | null
    lastUsed: Date | null
    isVerified: boolean
    verificationSource: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserSkillProficiencyCountAggregateOutputType | null
    _avg: UserSkillProficiencyAvgAggregateOutputType | null
    _sum: UserSkillProficiencySumAggregateOutputType | null
    _min: UserSkillProficiencyMinAggregateOutputType | null
    _max: UserSkillProficiencyMaxAggregateOutputType | null
  }

  type GetUserSkillProficiencyGroupByPayload<T extends UserSkillProficiencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSkillProficiencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSkillProficiencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSkillProficiencyGroupByOutputType[P]>
            : GetScalarType<T[P], UserSkillProficiencyGroupByOutputType[P]>
        }
      >
    >


  export type UserSkillProficiencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    skillId?: boolean
    level?: boolean
    yearsExperience?: boolean
    lastUsed?: boolean
    isVerified?: boolean
    verificationSource?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSkillProficiency"]>

  export type UserSkillProficiencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    skillId?: boolean
    level?: boolean
    yearsExperience?: boolean
    lastUsed?: boolean
    isVerified?: boolean
    verificationSource?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSkillProficiency"]>

  export type UserSkillProficiencySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    skillId?: boolean
    level?: boolean
    yearsExperience?: boolean
    lastUsed?: boolean
    isVerified?: boolean
    verificationSource?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSkillProficiency"]>

  export type UserSkillProficiencySelectScalar = {
    id?: boolean
    userId?: boolean
    skillId?: boolean
    level?: boolean
    yearsExperience?: boolean
    lastUsed?: boolean
    isVerified?: boolean
    verificationSource?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserSkillProficiencyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "skillId" | "level" | "yearsExperience" | "lastUsed" | "isVerified" | "verificationSource" | "createdAt" | "updatedAt", ExtArgs["result"]["userSkillProficiency"]>
  export type UserSkillProficiencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type UserSkillProficiencyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type UserSkillProficiencyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }

  export type $UserSkillProficiencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSkillProficiency"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      skill: Prisma.$SkillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      skillId: string
      level: $Enums.SkillLevel
      yearsExperience: number | null
      lastUsed: Date | null
      isVerified: boolean
      verificationSource: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userSkillProficiency"]>
    composites: {}
  }

  type UserSkillProficiencyGetPayload<S extends boolean | null | undefined | UserSkillProficiencyDefaultArgs> = $Result.GetResult<Prisma.$UserSkillProficiencyPayload, S>

  type UserSkillProficiencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSkillProficiencyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSkillProficiencyCountAggregateInputType | true
    }

  export interface UserSkillProficiencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSkillProficiency'], meta: { name: 'UserSkillProficiency' } }
    /**
     * Find zero or one UserSkillProficiency that matches the filter.
     * @param {UserSkillProficiencyFindUniqueArgs} args - Arguments to find a UserSkillProficiency
     * @example
     * // Get one UserSkillProficiency
     * const userSkillProficiency = await prisma.userSkillProficiency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSkillProficiencyFindUniqueArgs>(args: SelectSubset<T, UserSkillProficiencyFindUniqueArgs<ExtArgs>>): Prisma__UserSkillProficiencyClient<$Result.GetResult<Prisma.$UserSkillProficiencyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSkillProficiency that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSkillProficiencyFindUniqueOrThrowArgs} args - Arguments to find a UserSkillProficiency
     * @example
     * // Get one UserSkillProficiency
     * const userSkillProficiency = await prisma.userSkillProficiency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSkillProficiencyFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSkillProficiencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSkillProficiencyClient<$Result.GetResult<Prisma.$UserSkillProficiencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSkillProficiency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillProficiencyFindFirstArgs} args - Arguments to find a UserSkillProficiency
     * @example
     * // Get one UserSkillProficiency
     * const userSkillProficiency = await prisma.userSkillProficiency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSkillProficiencyFindFirstArgs>(args?: SelectSubset<T, UserSkillProficiencyFindFirstArgs<ExtArgs>>): Prisma__UserSkillProficiencyClient<$Result.GetResult<Prisma.$UserSkillProficiencyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSkillProficiency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillProficiencyFindFirstOrThrowArgs} args - Arguments to find a UserSkillProficiency
     * @example
     * // Get one UserSkillProficiency
     * const userSkillProficiency = await prisma.userSkillProficiency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSkillProficiencyFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSkillProficiencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSkillProficiencyClient<$Result.GetResult<Prisma.$UserSkillProficiencyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSkillProficiencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillProficiencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSkillProficiencies
     * const userSkillProficiencies = await prisma.userSkillProficiency.findMany()
     * 
     * // Get first 10 UserSkillProficiencies
     * const userSkillProficiencies = await prisma.userSkillProficiency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSkillProficiencyWithIdOnly = await prisma.userSkillProficiency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSkillProficiencyFindManyArgs>(args?: SelectSubset<T, UserSkillProficiencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSkillProficiencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSkillProficiency.
     * @param {UserSkillProficiencyCreateArgs} args - Arguments to create a UserSkillProficiency.
     * @example
     * // Create one UserSkillProficiency
     * const UserSkillProficiency = await prisma.userSkillProficiency.create({
     *   data: {
     *     // ... data to create a UserSkillProficiency
     *   }
     * })
     * 
     */
    create<T extends UserSkillProficiencyCreateArgs>(args: SelectSubset<T, UserSkillProficiencyCreateArgs<ExtArgs>>): Prisma__UserSkillProficiencyClient<$Result.GetResult<Prisma.$UserSkillProficiencyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSkillProficiencies.
     * @param {UserSkillProficiencyCreateManyArgs} args - Arguments to create many UserSkillProficiencies.
     * @example
     * // Create many UserSkillProficiencies
     * const userSkillProficiency = await prisma.userSkillProficiency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSkillProficiencyCreateManyArgs>(args?: SelectSubset<T, UserSkillProficiencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSkillProficiencies and returns the data saved in the database.
     * @param {UserSkillProficiencyCreateManyAndReturnArgs} args - Arguments to create many UserSkillProficiencies.
     * @example
     * // Create many UserSkillProficiencies
     * const userSkillProficiency = await prisma.userSkillProficiency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSkillProficiencies and only return the `id`
     * const userSkillProficiencyWithIdOnly = await prisma.userSkillProficiency.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSkillProficiencyCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSkillProficiencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSkillProficiencyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSkillProficiency.
     * @param {UserSkillProficiencyDeleteArgs} args - Arguments to delete one UserSkillProficiency.
     * @example
     * // Delete one UserSkillProficiency
     * const UserSkillProficiency = await prisma.userSkillProficiency.delete({
     *   where: {
     *     // ... filter to delete one UserSkillProficiency
     *   }
     * })
     * 
     */
    delete<T extends UserSkillProficiencyDeleteArgs>(args: SelectSubset<T, UserSkillProficiencyDeleteArgs<ExtArgs>>): Prisma__UserSkillProficiencyClient<$Result.GetResult<Prisma.$UserSkillProficiencyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSkillProficiency.
     * @param {UserSkillProficiencyUpdateArgs} args - Arguments to update one UserSkillProficiency.
     * @example
     * // Update one UserSkillProficiency
     * const userSkillProficiency = await prisma.userSkillProficiency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSkillProficiencyUpdateArgs>(args: SelectSubset<T, UserSkillProficiencyUpdateArgs<ExtArgs>>): Prisma__UserSkillProficiencyClient<$Result.GetResult<Prisma.$UserSkillProficiencyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSkillProficiencies.
     * @param {UserSkillProficiencyDeleteManyArgs} args - Arguments to filter UserSkillProficiencies to delete.
     * @example
     * // Delete a few UserSkillProficiencies
     * const { count } = await prisma.userSkillProficiency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSkillProficiencyDeleteManyArgs>(args?: SelectSubset<T, UserSkillProficiencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSkillProficiencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillProficiencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSkillProficiencies
     * const userSkillProficiency = await prisma.userSkillProficiency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSkillProficiencyUpdateManyArgs>(args: SelectSubset<T, UserSkillProficiencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSkillProficiencies and returns the data updated in the database.
     * @param {UserSkillProficiencyUpdateManyAndReturnArgs} args - Arguments to update many UserSkillProficiencies.
     * @example
     * // Update many UserSkillProficiencies
     * const userSkillProficiency = await prisma.userSkillProficiency.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSkillProficiencies and only return the `id`
     * const userSkillProficiencyWithIdOnly = await prisma.userSkillProficiency.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSkillProficiencyUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSkillProficiencyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSkillProficiencyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSkillProficiency.
     * @param {UserSkillProficiencyUpsertArgs} args - Arguments to update or create a UserSkillProficiency.
     * @example
     * // Update or create a UserSkillProficiency
     * const userSkillProficiency = await prisma.userSkillProficiency.upsert({
     *   create: {
     *     // ... data to create a UserSkillProficiency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSkillProficiency we want to update
     *   }
     * })
     */
    upsert<T extends UserSkillProficiencyUpsertArgs>(args: SelectSubset<T, UserSkillProficiencyUpsertArgs<ExtArgs>>): Prisma__UserSkillProficiencyClient<$Result.GetResult<Prisma.$UserSkillProficiencyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSkillProficiencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillProficiencyCountArgs} args - Arguments to filter UserSkillProficiencies to count.
     * @example
     * // Count the number of UserSkillProficiencies
     * const count = await prisma.userSkillProficiency.count({
     *   where: {
     *     // ... the filter for the UserSkillProficiencies we want to count
     *   }
     * })
    **/
    count<T extends UserSkillProficiencyCountArgs>(
      args?: Subset<T, UserSkillProficiencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSkillProficiencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSkillProficiency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillProficiencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSkillProficiencyAggregateArgs>(args: Subset<T, UserSkillProficiencyAggregateArgs>): Prisma.PrismaPromise<GetUserSkillProficiencyAggregateType<T>>

    /**
     * Group by UserSkillProficiency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillProficiencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSkillProficiencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSkillProficiencyGroupByArgs['orderBy'] }
        : { orderBy?: UserSkillProficiencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSkillProficiencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSkillProficiencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSkillProficiency model
   */
  readonly fields: UserSkillProficiencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSkillProficiency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSkillProficiencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    skill<T extends SkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillDefaultArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSkillProficiency model
   */
  interface UserSkillProficiencyFieldRefs {
    readonly id: FieldRef<"UserSkillProficiency", 'String'>
    readonly userId: FieldRef<"UserSkillProficiency", 'String'>
    readonly skillId: FieldRef<"UserSkillProficiency", 'String'>
    readonly level: FieldRef<"UserSkillProficiency", 'SkillLevel'>
    readonly yearsExperience: FieldRef<"UserSkillProficiency", 'Int'>
    readonly lastUsed: FieldRef<"UserSkillProficiency", 'DateTime'>
    readonly isVerified: FieldRef<"UserSkillProficiency", 'Boolean'>
    readonly verificationSource: FieldRef<"UserSkillProficiency", 'String'>
    readonly createdAt: FieldRef<"UserSkillProficiency", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSkillProficiency", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSkillProficiency findUnique
   */
  export type UserSkillProficiencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkillProficiency
     */
    select?: UserSkillProficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkillProficiency
     */
    omit?: UserSkillProficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillProficiencyInclude<ExtArgs> | null
    /**
     * Filter, which UserSkillProficiency to fetch.
     */
    where: UserSkillProficiencyWhereUniqueInput
  }

  /**
   * UserSkillProficiency findUniqueOrThrow
   */
  export type UserSkillProficiencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkillProficiency
     */
    select?: UserSkillProficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkillProficiency
     */
    omit?: UserSkillProficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillProficiencyInclude<ExtArgs> | null
    /**
     * Filter, which UserSkillProficiency to fetch.
     */
    where: UserSkillProficiencyWhereUniqueInput
  }

  /**
   * UserSkillProficiency findFirst
   */
  export type UserSkillProficiencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkillProficiency
     */
    select?: UserSkillProficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkillProficiency
     */
    omit?: UserSkillProficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillProficiencyInclude<ExtArgs> | null
    /**
     * Filter, which UserSkillProficiency to fetch.
     */
    where?: UserSkillProficiencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSkillProficiencies to fetch.
     */
    orderBy?: UserSkillProficiencyOrderByWithRelationInput | UserSkillProficiencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSkillProficiencies.
     */
    cursor?: UserSkillProficiencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSkillProficiencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSkillProficiencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSkillProficiencies.
     */
    distinct?: UserSkillProficiencyScalarFieldEnum | UserSkillProficiencyScalarFieldEnum[]
  }

  /**
   * UserSkillProficiency findFirstOrThrow
   */
  export type UserSkillProficiencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkillProficiency
     */
    select?: UserSkillProficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkillProficiency
     */
    omit?: UserSkillProficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillProficiencyInclude<ExtArgs> | null
    /**
     * Filter, which UserSkillProficiency to fetch.
     */
    where?: UserSkillProficiencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSkillProficiencies to fetch.
     */
    orderBy?: UserSkillProficiencyOrderByWithRelationInput | UserSkillProficiencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSkillProficiencies.
     */
    cursor?: UserSkillProficiencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSkillProficiencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSkillProficiencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSkillProficiencies.
     */
    distinct?: UserSkillProficiencyScalarFieldEnum | UserSkillProficiencyScalarFieldEnum[]
  }

  /**
   * UserSkillProficiency findMany
   */
  export type UserSkillProficiencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkillProficiency
     */
    select?: UserSkillProficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkillProficiency
     */
    omit?: UserSkillProficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillProficiencyInclude<ExtArgs> | null
    /**
     * Filter, which UserSkillProficiencies to fetch.
     */
    where?: UserSkillProficiencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSkillProficiencies to fetch.
     */
    orderBy?: UserSkillProficiencyOrderByWithRelationInput | UserSkillProficiencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSkillProficiencies.
     */
    cursor?: UserSkillProficiencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSkillProficiencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSkillProficiencies.
     */
    skip?: number
    distinct?: UserSkillProficiencyScalarFieldEnum | UserSkillProficiencyScalarFieldEnum[]
  }

  /**
   * UserSkillProficiency create
   */
  export type UserSkillProficiencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkillProficiency
     */
    select?: UserSkillProficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkillProficiency
     */
    omit?: UserSkillProficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillProficiencyInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSkillProficiency.
     */
    data: XOR<UserSkillProficiencyCreateInput, UserSkillProficiencyUncheckedCreateInput>
  }

  /**
   * UserSkillProficiency createMany
   */
  export type UserSkillProficiencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSkillProficiencies.
     */
    data: UserSkillProficiencyCreateManyInput | UserSkillProficiencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSkillProficiency createManyAndReturn
   */
  export type UserSkillProficiencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkillProficiency
     */
    select?: UserSkillProficiencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkillProficiency
     */
    omit?: UserSkillProficiencyOmit<ExtArgs> | null
    /**
     * The data used to create many UserSkillProficiencies.
     */
    data: UserSkillProficiencyCreateManyInput | UserSkillProficiencyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillProficiencyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSkillProficiency update
   */
  export type UserSkillProficiencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkillProficiency
     */
    select?: UserSkillProficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkillProficiency
     */
    omit?: UserSkillProficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillProficiencyInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSkillProficiency.
     */
    data: XOR<UserSkillProficiencyUpdateInput, UserSkillProficiencyUncheckedUpdateInput>
    /**
     * Choose, which UserSkillProficiency to update.
     */
    where: UserSkillProficiencyWhereUniqueInput
  }

  /**
   * UserSkillProficiency updateMany
   */
  export type UserSkillProficiencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSkillProficiencies.
     */
    data: XOR<UserSkillProficiencyUpdateManyMutationInput, UserSkillProficiencyUncheckedUpdateManyInput>
    /**
     * Filter which UserSkillProficiencies to update
     */
    where?: UserSkillProficiencyWhereInput
    /**
     * Limit how many UserSkillProficiencies to update.
     */
    limit?: number
  }

  /**
   * UserSkillProficiency updateManyAndReturn
   */
  export type UserSkillProficiencyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkillProficiency
     */
    select?: UserSkillProficiencySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkillProficiency
     */
    omit?: UserSkillProficiencyOmit<ExtArgs> | null
    /**
     * The data used to update UserSkillProficiencies.
     */
    data: XOR<UserSkillProficiencyUpdateManyMutationInput, UserSkillProficiencyUncheckedUpdateManyInput>
    /**
     * Filter which UserSkillProficiencies to update
     */
    where?: UserSkillProficiencyWhereInput
    /**
     * Limit how many UserSkillProficiencies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillProficiencyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSkillProficiency upsert
   */
  export type UserSkillProficiencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkillProficiency
     */
    select?: UserSkillProficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkillProficiency
     */
    omit?: UserSkillProficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillProficiencyInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSkillProficiency to update in case it exists.
     */
    where: UserSkillProficiencyWhereUniqueInput
    /**
     * In case the UserSkillProficiency found by the `where` argument doesn't exist, create a new UserSkillProficiency with this data.
     */
    create: XOR<UserSkillProficiencyCreateInput, UserSkillProficiencyUncheckedCreateInput>
    /**
     * In case the UserSkillProficiency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSkillProficiencyUpdateInput, UserSkillProficiencyUncheckedUpdateInput>
  }

  /**
   * UserSkillProficiency delete
   */
  export type UserSkillProficiencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkillProficiency
     */
    select?: UserSkillProficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkillProficiency
     */
    omit?: UserSkillProficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillProficiencyInclude<ExtArgs> | null
    /**
     * Filter which UserSkillProficiency to delete.
     */
    where: UserSkillProficiencyWhereUniqueInput
  }

  /**
   * UserSkillProficiency deleteMany
   */
  export type UserSkillProficiencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSkillProficiencies to delete
     */
    where?: UserSkillProficiencyWhereInput
    /**
     * Limit how many UserSkillProficiencies to delete.
     */
    limit?: number
  }

  /**
   * UserSkillProficiency without action
   */
  export type UserSkillProficiencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkillProficiency
     */
    select?: UserSkillProficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkillProficiency
     */
    omit?: UserSkillProficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillProficiencyInclude<ExtArgs> | null
  }


  /**
   * Model SkillPrerequisite
   */

  export type AggregateSkillPrerequisite = {
    _count: SkillPrerequisiteCountAggregateOutputType | null
    _min: SkillPrerequisiteMinAggregateOutputType | null
    _max: SkillPrerequisiteMaxAggregateOutputType | null
  }

  export type SkillPrerequisiteMinAggregateOutputType = {
    id: string | null
    skillId: string | null
    prerequisiteSkillId: string | null
    isRequired: boolean | null
    minimumLevel: $Enums.SkillLevel | null
  }

  export type SkillPrerequisiteMaxAggregateOutputType = {
    id: string | null
    skillId: string | null
    prerequisiteSkillId: string | null
    isRequired: boolean | null
    minimumLevel: $Enums.SkillLevel | null
  }

  export type SkillPrerequisiteCountAggregateOutputType = {
    id: number
    skillId: number
    prerequisiteSkillId: number
    isRequired: number
    minimumLevel: number
    _all: number
  }


  export type SkillPrerequisiteMinAggregateInputType = {
    id?: true
    skillId?: true
    prerequisiteSkillId?: true
    isRequired?: true
    minimumLevel?: true
  }

  export type SkillPrerequisiteMaxAggregateInputType = {
    id?: true
    skillId?: true
    prerequisiteSkillId?: true
    isRequired?: true
    minimumLevel?: true
  }

  export type SkillPrerequisiteCountAggregateInputType = {
    id?: true
    skillId?: true
    prerequisiteSkillId?: true
    isRequired?: true
    minimumLevel?: true
    _all?: true
  }

  export type SkillPrerequisiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkillPrerequisite to aggregate.
     */
    where?: SkillPrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillPrerequisites to fetch.
     */
    orderBy?: SkillPrerequisiteOrderByWithRelationInput | SkillPrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkillPrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillPrerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillPrerequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SkillPrerequisites
    **/
    _count?: true | SkillPrerequisiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillPrerequisiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillPrerequisiteMaxAggregateInputType
  }

  export type GetSkillPrerequisiteAggregateType<T extends SkillPrerequisiteAggregateArgs> = {
        [P in keyof T & keyof AggregateSkillPrerequisite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkillPrerequisite[P]>
      : GetScalarType<T[P], AggregateSkillPrerequisite[P]>
  }




  export type SkillPrerequisiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillPrerequisiteWhereInput
    orderBy?: SkillPrerequisiteOrderByWithAggregationInput | SkillPrerequisiteOrderByWithAggregationInput[]
    by: SkillPrerequisiteScalarFieldEnum[] | SkillPrerequisiteScalarFieldEnum
    having?: SkillPrerequisiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillPrerequisiteCountAggregateInputType | true
    _min?: SkillPrerequisiteMinAggregateInputType
    _max?: SkillPrerequisiteMaxAggregateInputType
  }

  export type SkillPrerequisiteGroupByOutputType = {
    id: string
    skillId: string
    prerequisiteSkillId: string
    isRequired: boolean
    minimumLevel: $Enums.SkillLevel
    _count: SkillPrerequisiteCountAggregateOutputType | null
    _min: SkillPrerequisiteMinAggregateOutputType | null
    _max: SkillPrerequisiteMaxAggregateOutputType | null
  }

  type GetSkillPrerequisiteGroupByPayload<T extends SkillPrerequisiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillPrerequisiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillPrerequisiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillPrerequisiteGroupByOutputType[P]>
            : GetScalarType<T[P], SkillPrerequisiteGroupByOutputType[P]>
        }
      >
    >


  export type SkillPrerequisiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skillId?: boolean
    prerequisiteSkillId?: boolean
    isRequired?: boolean
    minimumLevel?: boolean
    skill?: boolean | SkillDefaultArgs<ExtArgs>
    prerequisiteSkill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skillPrerequisite"]>

  export type SkillPrerequisiteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skillId?: boolean
    prerequisiteSkillId?: boolean
    isRequired?: boolean
    minimumLevel?: boolean
    skill?: boolean | SkillDefaultArgs<ExtArgs>
    prerequisiteSkill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skillPrerequisite"]>

  export type SkillPrerequisiteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skillId?: boolean
    prerequisiteSkillId?: boolean
    isRequired?: boolean
    minimumLevel?: boolean
    skill?: boolean | SkillDefaultArgs<ExtArgs>
    prerequisiteSkill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skillPrerequisite"]>

  export type SkillPrerequisiteSelectScalar = {
    id?: boolean
    skillId?: boolean
    prerequisiteSkillId?: boolean
    isRequired?: boolean
    minimumLevel?: boolean
  }

  export type SkillPrerequisiteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "skillId" | "prerequisiteSkillId" | "isRequired" | "minimumLevel", ExtArgs["result"]["skillPrerequisite"]>
  export type SkillPrerequisiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill?: boolean | SkillDefaultArgs<ExtArgs>
    prerequisiteSkill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type SkillPrerequisiteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill?: boolean | SkillDefaultArgs<ExtArgs>
    prerequisiteSkill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type SkillPrerequisiteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill?: boolean | SkillDefaultArgs<ExtArgs>
    prerequisiteSkill?: boolean | SkillDefaultArgs<ExtArgs>
  }

  export type $SkillPrerequisitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SkillPrerequisite"
    objects: {
      skill: Prisma.$SkillPayload<ExtArgs>
      prerequisiteSkill: Prisma.$SkillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      skillId: string
      prerequisiteSkillId: string
      isRequired: boolean
      minimumLevel: $Enums.SkillLevel
    }, ExtArgs["result"]["skillPrerequisite"]>
    composites: {}
  }

  type SkillPrerequisiteGetPayload<S extends boolean | null | undefined | SkillPrerequisiteDefaultArgs> = $Result.GetResult<Prisma.$SkillPrerequisitePayload, S>

  type SkillPrerequisiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SkillPrerequisiteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SkillPrerequisiteCountAggregateInputType | true
    }

  export interface SkillPrerequisiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SkillPrerequisite'], meta: { name: 'SkillPrerequisite' } }
    /**
     * Find zero or one SkillPrerequisite that matches the filter.
     * @param {SkillPrerequisiteFindUniqueArgs} args - Arguments to find a SkillPrerequisite
     * @example
     * // Get one SkillPrerequisite
     * const skillPrerequisite = await prisma.skillPrerequisite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkillPrerequisiteFindUniqueArgs>(args: SelectSubset<T, SkillPrerequisiteFindUniqueArgs<ExtArgs>>): Prisma__SkillPrerequisiteClient<$Result.GetResult<Prisma.$SkillPrerequisitePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SkillPrerequisite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SkillPrerequisiteFindUniqueOrThrowArgs} args - Arguments to find a SkillPrerequisite
     * @example
     * // Get one SkillPrerequisite
     * const skillPrerequisite = await prisma.skillPrerequisite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkillPrerequisiteFindUniqueOrThrowArgs>(args: SelectSubset<T, SkillPrerequisiteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkillPrerequisiteClient<$Result.GetResult<Prisma.$SkillPrerequisitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SkillPrerequisite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillPrerequisiteFindFirstArgs} args - Arguments to find a SkillPrerequisite
     * @example
     * // Get one SkillPrerequisite
     * const skillPrerequisite = await prisma.skillPrerequisite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkillPrerequisiteFindFirstArgs>(args?: SelectSubset<T, SkillPrerequisiteFindFirstArgs<ExtArgs>>): Prisma__SkillPrerequisiteClient<$Result.GetResult<Prisma.$SkillPrerequisitePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SkillPrerequisite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillPrerequisiteFindFirstOrThrowArgs} args - Arguments to find a SkillPrerequisite
     * @example
     * // Get one SkillPrerequisite
     * const skillPrerequisite = await prisma.skillPrerequisite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkillPrerequisiteFindFirstOrThrowArgs>(args?: SelectSubset<T, SkillPrerequisiteFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkillPrerequisiteClient<$Result.GetResult<Prisma.$SkillPrerequisitePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SkillPrerequisites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillPrerequisiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SkillPrerequisites
     * const skillPrerequisites = await prisma.skillPrerequisite.findMany()
     * 
     * // Get first 10 SkillPrerequisites
     * const skillPrerequisites = await prisma.skillPrerequisite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillPrerequisiteWithIdOnly = await prisma.skillPrerequisite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkillPrerequisiteFindManyArgs>(args?: SelectSubset<T, SkillPrerequisiteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPrerequisitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SkillPrerequisite.
     * @param {SkillPrerequisiteCreateArgs} args - Arguments to create a SkillPrerequisite.
     * @example
     * // Create one SkillPrerequisite
     * const SkillPrerequisite = await prisma.skillPrerequisite.create({
     *   data: {
     *     // ... data to create a SkillPrerequisite
     *   }
     * })
     * 
     */
    create<T extends SkillPrerequisiteCreateArgs>(args: SelectSubset<T, SkillPrerequisiteCreateArgs<ExtArgs>>): Prisma__SkillPrerequisiteClient<$Result.GetResult<Prisma.$SkillPrerequisitePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SkillPrerequisites.
     * @param {SkillPrerequisiteCreateManyArgs} args - Arguments to create many SkillPrerequisites.
     * @example
     * // Create many SkillPrerequisites
     * const skillPrerequisite = await prisma.skillPrerequisite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkillPrerequisiteCreateManyArgs>(args?: SelectSubset<T, SkillPrerequisiteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SkillPrerequisites and returns the data saved in the database.
     * @param {SkillPrerequisiteCreateManyAndReturnArgs} args - Arguments to create many SkillPrerequisites.
     * @example
     * // Create many SkillPrerequisites
     * const skillPrerequisite = await prisma.skillPrerequisite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SkillPrerequisites and only return the `id`
     * const skillPrerequisiteWithIdOnly = await prisma.skillPrerequisite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SkillPrerequisiteCreateManyAndReturnArgs>(args?: SelectSubset<T, SkillPrerequisiteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPrerequisitePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SkillPrerequisite.
     * @param {SkillPrerequisiteDeleteArgs} args - Arguments to delete one SkillPrerequisite.
     * @example
     * // Delete one SkillPrerequisite
     * const SkillPrerequisite = await prisma.skillPrerequisite.delete({
     *   where: {
     *     // ... filter to delete one SkillPrerequisite
     *   }
     * })
     * 
     */
    delete<T extends SkillPrerequisiteDeleteArgs>(args: SelectSubset<T, SkillPrerequisiteDeleteArgs<ExtArgs>>): Prisma__SkillPrerequisiteClient<$Result.GetResult<Prisma.$SkillPrerequisitePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SkillPrerequisite.
     * @param {SkillPrerequisiteUpdateArgs} args - Arguments to update one SkillPrerequisite.
     * @example
     * // Update one SkillPrerequisite
     * const skillPrerequisite = await prisma.skillPrerequisite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkillPrerequisiteUpdateArgs>(args: SelectSubset<T, SkillPrerequisiteUpdateArgs<ExtArgs>>): Prisma__SkillPrerequisiteClient<$Result.GetResult<Prisma.$SkillPrerequisitePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SkillPrerequisites.
     * @param {SkillPrerequisiteDeleteManyArgs} args - Arguments to filter SkillPrerequisites to delete.
     * @example
     * // Delete a few SkillPrerequisites
     * const { count } = await prisma.skillPrerequisite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkillPrerequisiteDeleteManyArgs>(args?: SelectSubset<T, SkillPrerequisiteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkillPrerequisites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillPrerequisiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SkillPrerequisites
     * const skillPrerequisite = await prisma.skillPrerequisite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkillPrerequisiteUpdateManyArgs>(args: SelectSubset<T, SkillPrerequisiteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkillPrerequisites and returns the data updated in the database.
     * @param {SkillPrerequisiteUpdateManyAndReturnArgs} args - Arguments to update many SkillPrerequisites.
     * @example
     * // Update many SkillPrerequisites
     * const skillPrerequisite = await prisma.skillPrerequisite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SkillPrerequisites and only return the `id`
     * const skillPrerequisiteWithIdOnly = await prisma.skillPrerequisite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SkillPrerequisiteUpdateManyAndReturnArgs>(args: SelectSubset<T, SkillPrerequisiteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPrerequisitePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SkillPrerequisite.
     * @param {SkillPrerequisiteUpsertArgs} args - Arguments to update or create a SkillPrerequisite.
     * @example
     * // Update or create a SkillPrerequisite
     * const skillPrerequisite = await prisma.skillPrerequisite.upsert({
     *   create: {
     *     // ... data to create a SkillPrerequisite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SkillPrerequisite we want to update
     *   }
     * })
     */
    upsert<T extends SkillPrerequisiteUpsertArgs>(args: SelectSubset<T, SkillPrerequisiteUpsertArgs<ExtArgs>>): Prisma__SkillPrerequisiteClient<$Result.GetResult<Prisma.$SkillPrerequisitePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SkillPrerequisites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillPrerequisiteCountArgs} args - Arguments to filter SkillPrerequisites to count.
     * @example
     * // Count the number of SkillPrerequisites
     * const count = await prisma.skillPrerequisite.count({
     *   where: {
     *     // ... the filter for the SkillPrerequisites we want to count
     *   }
     * })
    **/
    count<T extends SkillPrerequisiteCountArgs>(
      args?: Subset<T, SkillPrerequisiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillPrerequisiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SkillPrerequisite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillPrerequisiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillPrerequisiteAggregateArgs>(args: Subset<T, SkillPrerequisiteAggregateArgs>): Prisma.PrismaPromise<GetSkillPrerequisiteAggregateType<T>>

    /**
     * Group by SkillPrerequisite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillPrerequisiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillPrerequisiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillPrerequisiteGroupByArgs['orderBy'] }
        : { orderBy?: SkillPrerequisiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillPrerequisiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillPrerequisiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SkillPrerequisite model
   */
  readonly fields: SkillPrerequisiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SkillPrerequisite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkillPrerequisiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skill<T extends SkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillDefaultArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    prerequisiteSkill<T extends SkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillDefaultArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SkillPrerequisite model
   */
  interface SkillPrerequisiteFieldRefs {
    readonly id: FieldRef<"SkillPrerequisite", 'String'>
    readonly skillId: FieldRef<"SkillPrerequisite", 'String'>
    readonly prerequisiteSkillId: FieldRef<"SkillPrerequisite", 'String'>
    readonly isRequired: FieldRef<"SkillPrerequisite", 'Boolean'>
    readonly minimumLevel: FieldRef<"SkillPrerequisite", 'SkillLevel'>
  }
    

  // Custom InputTypes
  /**
   * SkillPrerequisite findUnique
   */
  export type SkillPrerequisiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillPrerequisite
     */
    select?: SkillPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillPrerequisite
     */
    omit?: SkillPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillPrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which SkillPrerequisite to fetch.
     */
    where: SkillPrerequisiteWhereUniqueInput
  }

  /**
   * SkillPrerequisite findUniqueOrThrow
   */
  export type SkillPrerequisiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillPrerequisite
     */
    select?: SkillPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillPrerequisite
     */
    omit?: SkillPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillPrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which SkillPrerequisite to fetch.
     */
    where: SkillPrerequisiteWhereUniqueInput
  }

  /**
   * SkillPrerequisite findFirst
   */
  export type SkillPrerequisiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillPrerequisite
     */
    select?: SkillPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillPrerequisite
     */
    omit?: SkillPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillPrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which SkillPrerequisite to fetch.
     */
    where?: SkillPrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillPrerequisites to fetch.
     */
    orderBy?: SkillPrerequisiteOrderByWithRelationInput | SkillPrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkillPrerequisites.
     */
    cursor?: SkillPrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillPrerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillPrerequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkillPrerequisites.
     */
    distinct?: SkillPrerequisiteScalarFieldEnum | SkillPrerequisiteScalarFieldEnum[]
  }

  /**
   * SkillPrerequisite findFirstOrThrow
   */
  export type SkillPrerequisiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillPrerequisite
     */
    select?: SkillPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillPrerequisite
     */
    omit?: SkillPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillPrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which SkillPrerequisite to fetch.
     */
    where?: SkillPrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillPrerequisites to fetch.
     */
    orderBy?: SkillPrerequisiteOrderByWithRelationInput | SkillPrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkillPrerequisites.
     */
    cursor?: SkillPrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillPrerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillPrerequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkillPrerequisites.
     */
    distinct?: SkillPrerequisiteScalarFieldEnum | SkillPrerequisiteScalarFieldEnum[]
  }

  /**
   * SkillPrerequisite findMany
   */
  export type SkillPrerequisiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillPrerequisite
     */
    select?: SkillPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillPrerequisite
     */
    omit?: SkillPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillPrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which SkillPrerequisites to fetch.
     */
    where?: SkillPrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillPrerequisites to fetch.
     */
    orderBy?: SkillPrerequisiteOrderByWithRelationInput | SkillPrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SkillPrerequisites.
     */
    cursor?: SkillPrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillPrerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillPrerequisites.
     */
    skip?: number
    distinct?: SkillPrerequisiteScalarFieldEnum | SkillPrerequisiteScalarFieldEnum[]
  }

  /**
   * SkillPrerequisite create
   */
  export type SkillPrerequisiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillPrerequisite
     */
    select?: SkillPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillPrerequisite
     */
    omit?: SkillPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillPrerequisiteInclude<ExtArgs> | null
    /**
     * The data needed to create a SkillPrerequisite.
     */
    data: XOR<SkillPrerequisiteCreateInput, SkillPrerequisiteUncheckedCreateInput>
  }

  /**
   * SkillPrerequisite createMany
   */
  export type SkillPrerequisiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SkillPrerequisites.
     */
    data: SkillPrerequisiteCreateManyInput | SkillPrerequisiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SkillPrerequisite createManyAndReturn
   */
  export type SkillPrerequisiteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillPrerequisite
     */
    select?: SkillPrerequisiteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SkillPrerequisite
     */
    omit?: SkillPrerequisiteOmit<ExtArgs> | null
    /**
     * The data used to create many SkillPrerequisites.
     */
    data: SkillPrerequisiteCreateManyInput | SkillPrerequisiteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillPrerequisiteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SkillPrerequisite update
   */
  export type SkillPrerequisiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillPrerequisite
     */
    select?: SkillPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillPrerequisite
     */
    omit?: SkillPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillPrerequisiteInclude<ExtArgs> | null
    /**
     * The data needed to update a SkillPrerequisite.
     */
    data: XOR<SkillPrerequisiteUpdateInput, SkillPrerequisiteUncheckedUpdateInput>
    /**
     * Choose, which SkillPrerequisite to update.
     */
    where: SkillPrerequisiteWhereUniqueInput
  }

  /**
   * SkillPrerequisite updateMany
   */
  export type SkillPrerequisiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SkillPrerequisites.
     */
    data: XOR<SkillPrerequisiteUpdateManyMutationInput, SkillPrerequisiteUncheckedUpdateManyInput>
    /**
     * Filter which SkillPrerequisites to update
     */
    where?: SkillPrerequisiteWhereInput
    /**
     * Limit how many SkillPrerequisites to update.
     */
    limit?: number
  }

  /**
   * SkillPrerequisite updateManyAndReturn
   */
  export type SkillPrerequisiteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillPrerequisite
     */
    select?: SkillPrerequisiteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SkillPrerequisite
     */
    omit?: SkillPrerequisiteOmit<ExtArgs> | null
    /**
     * The data used to update SkillPrerequisites.
     */
    data: XOR<SkillPrerequisiteUpdateManyMutationInput, SkillPrerequisiteUncheckedUpdateManyInput>
    /**
     * Filter which SkillPrerequisites to update
     */
    where?: SkillPrerequisiteWhereInput
    /**
     * Limit how many SkillPrerequisites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillPrerequisiteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SkillPrerequisite upsert
   */
  export type SkillPrerequisiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillPrerequisite
     */
    select?: SkillPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillPrerequisite
     */
    omit?: SkillPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillPrerequisiteInclude<ExtArgs> | null
    /**
     * The filter to search for the SkillPrerequisite to update in case it exists.
     */
    where: SkillPrerequisiteWhereUniqueInput
    /**
     * In case the SkillPrerequisite found by the `where` argument doesn't exist, create a new SkillPrerequisite with this data.
     */
    create: XOR<SkillPrerequisiteCreateInput, SkillPrerequisiteUncheckedCreateInput>
    /**
     * In case the SkillPrerequisite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkillPrerequisiteUpdateInput, SkillPrerequisiteUncheckedUpdateInput>
  }

  /**
   * SkillPrerequisite delete
   */
  export type SkillPrerequisiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillPrerequisite
     */
    select?: SkillPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillPrerequisite
     */
    omit?: SkillPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillPrerequisiteInclude<ExtArgs> | null
    /**
     * Filter which SkillPrerequisite to delete.
     */
    where: SkillPrerequisiteWhereUniqueInput
  }

  /**
   * SkillPrerequisite deleteMany
   */
  export type SkillPrerequisiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkillPrerequisites to delete
     */
    where?: SkillPrerequisiteWhereInput
    /**
     * Limit how many SkillPrerequisites to delete.
     */
    limit?: number
  }

  /**
   * SkillPrerequisite without action
   */
  export type SkillPrerequisiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillPrerequisite
     */
    select?: SkillPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillPrerequisite
     */
    omit?: SkillPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillPrerequisiteInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type CategorySumAggregateOutputType = {
    sortOrder: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    icon: string | null
    color: string | null
    parentId: string | null
    sortOrder: number | null
    isActive: boolean | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    icon: string | null
    color: string | null
    parentId: string | null
    sortOrder: number | null
    isActive: boolean | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    icon: number
    color: number
    parentId: number
    sortOrder: number
    isActive: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    sortOrder?: true
  }

  export type CategorySumAggregateInputType = {
    sortOrder?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    icon?: true
    color?: true
    parentId?: true
    sortOrder?: true
    isActive?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    icon?: true
    color?: true
    parentId?: true
    sortOrder?: true
    isActive?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    icon?: true
    color?: true
    parentId?: true
    sortOrder?: true
    isActive?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    icon: string | null
    color: string | null
    parentId: string | null
    sortOrder: number
    isActive: boolean
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    parentId?: boolean
    sortOrder?: boolean
    isActive?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
    children?: boolean | Category$childrenArgs<ExtArgs>
    courses?: boolean | Category$coursesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    parentId?: boolean
    sortOrder?: boolean
    isActive?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    parentId?: boolean
    sortOrder?: boolean
    isActive?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    parentId?: boolean
    sortOrder?: boolean
    isActive?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "icon" | "color" | "parentId" | "sortOrder" | "isActive", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
    children?: boolean | Category$childrenArgs<ExtArgs>
    courses?: boolean | Category$coursesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
  }
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      parent: Prisma.$CategoryPayload<ExtArgs> | null
      children: Prisma.$CategoryPayload<ExtArgs>[]
      courses: Prisma.$CourseCategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      icon: string | null
      color: string | null
      parentId: string | null
      sortOrder: number
      isActive: boolean
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends Category$parentArgs<ExtArgs> = {}>(args?: Subset<T, Category$parentArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Category$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Category$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    courses<T extends Category$coursesArgs<ExtArgs> = {}>(args?: Subset<T, Category$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly slug: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly icon: FieldRef<"Category", 'String'>
    readonly color: FieldRef<"Category", 'String'>
    readonly parentId: FieldRef<"Category", 'String'>
    readonly sortOrder: FieldRef<"Category", 'Int'>
    readonly isActive: FieldRef<"Category", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.parent
   */
  export type Category$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Category.children
   */
  export type Category$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category.courses
   */
  export type Category$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCategory
     */
    select?: CourseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseCategory
     */
    omit?: CourseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCategoryInclude<ExtArgs> | null
    where?: CourseCategoryWhereInput
    orderBy?: CourseCategoryOrderByWithRelationInput | CourseCategoryOrderByWithRelationInput[]
    cursor?: CourseCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseCategoryScalarFieldEnum | CourseCategoryScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model CourseCategory
   */

  export type AggregateCourseCategory = {
    _count: CourseCategoryCountAggregateOutputType | null
    _min: CourseCategoryMinAggregateOutputType | null
    _max: CourseCategoryMaxAggregateOutputType | null
  }

  export type CourseCategoryMinAggregateOutputType = {
    id: string | null
    courseId: string | null
    categoryId: string | null
    isPrimary: boolean | null
  }

  export type CourseCategoryMaxAggregateOutputType = {
    id: string | null
    courseId: string | null
    categoryId: string | null
    isPrimary: boolean | null
  }

  export type CourseCategoryCountAggregateOutputType = {
    id: number
    courseId: number
    categoryId: number
    isPrimary: number
    _all: number
  }


  export type CourseCategoryMinAggregateInputType = {
    id?: true
    courseId?: true
    categoryId?: true
    isPrimary?: true
  }

  export type CourseCategoryMaxAggregateInputType = {
    id?: true
    courseId?: true
    categoryId?: true
    isPrimary?: true
  }

  export type CourseCategoryCountAggregateInputType = {
    id?: true
    courseId?: true
    categoryId?: true
    isPrimary?: true
    _all?: true
  }

  export type CourseCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseCategory to aggregate.
     */
    where?: CourseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseCategories to fetch.
     */
    orderBy?: CourseCategoryOrderByWithRelationInput | CourseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseCategories
    **/
    _count?: true | CourseCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseCategoryMaxAggregateInputType
  }

  export type GetCourseCategoryAggregateType<T extends CourseCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseCategory[P]>
      : GetScalarType<T[P], AggregateCourseCategory[P]>
  }




  export type CourseCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseCategoryWhereInput
    orderBy?: CourseCategoryOrderByWithAggregationInput | CourseCategoryOrderByWithAggregationInput[]
    by: CourseCategoryScalarFieldEnum[] | CourseCategoryScalarFieldEnum
    having?: CourseCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCategoryCountAggregateInputType | true
    _min?: CourseCategoryMinAggregateInputType
    _max?: CourseCategoryMaxAggregateInputType
  }

  export type CourseCategoryGroupByOutputType = {
    id: string
    courseId: string
    categoryId: string
    isPrimary: boolean
    _count: CourseCategoryCountAggregateOutputType | null
    _min: CourseCategoryMinAggregateOutputType | null
    _max: CourseCategoryMaxAggregateOutputType | null
  }

  type GetCourseCategoryGroupByPayload<T extends CourseCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CourseCategoryGroupByOutputType[P]>
        }
      >
    >


  export type CourseCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    categoryId?: boolean
    isPrimary?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseCategory"]>

  export type CourseCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    categoryId?: boolean
    isPrimary?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseCategory"]>

  export type CourseCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    categoryId?: boolean
    isPrimary?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseCategory"]>

  export type CourseCategorySelectScalar = {
    id?: boolean
    courseId?: boolean
    categoryId?: boolean
    isPrimary?: boolean
  }

  export type CourseCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courseId" | "categoryId" | "isPrimary", ExtArgs["result"]["courseCategory"]>
  export type CourseCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type CourseCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type CourseCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $CourseCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseCategory"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      category: Prisma.$CategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      courseId: string
      categoryId: string
      isPrimary: boolean
    }, ExtArgs["result"]["courseCategory"]>
    composites: {}
  }

  type CourseCategoryGetPayload<S extends boolean | null | undefined | CourseCategoryDefaultArgs> = $Result.GetResult<Prisma.$CourseCategoryPayload, S>

  type CourseCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseCategoryCountAggregateInputType | true
    }

  export interface CourseCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseCategory'], meta: { name: 'CourseCategory' } }
    /**
     * Find zero or one CourseCategory that matches the filter.
     * @param {CourseCategoryFindUniqueArgs} args - Arguments to find a CourseCategory
     * @example
     * // Get one CourseCategory
     * const courseCategory = await prisma.courseCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseCategoryFindUniqueArgs>(args: SelectSubset<T, CourseCategoryFindUniqueArgs<ExtArgs>>): Prisma__CourseCategoryClient<$Result.GetResult<Prisma.$CourseCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourseCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseCategoryFindUniqueOrThrowArgs} args - Arguments to find a CourseCategory
     * @example
     * // Get one CourseCategory
     * const courseCategory = await prisma.courseCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseCategoryClient<$Result.GetResult<Prisma.$CourseCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCategoryFindFirstArgs} args - Arguments to find a CourseCategory
     * @example
     * // Get one CourseCategory
     * const courseCategory = await prisma.courseCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseCategoryFindFirstArgs>(args?: SelectSubset<T, CourseCategoryFindFirstArgs<ExtArgs>>): Prisma__CourseCategoryClient<$Result.GetResult<Prisma.$CourseCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCategoryFindFirstOrThrowArgs} args - Arguments to find a CourseCategory
     * @example
     * // Get one CourseCategory
     * const courseCategory = await prisma.courseCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseCategoryClient<$Result.GetResult<Prisma.$CourseCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourseCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseCategories
     * const courseCategories = await prisma.courseCategory.findMany()
     * 
     * // Get first 10 CourseCategories
     * const courseCategories = await prisma.courseCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseCategoryWithIdOnly = await prisma.courseCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseCategoryFindManyArgs>(args?: SelectSubset<T, CourseCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourseCategory.
     * @param {CourseCategoryCreateArgs} args - Arguments to create a CourseCategory.
     * @example
     * // Create one CourseCategory
     * const CourseCategory = await prisma.courseCategory.create({
     *   data: {
     *     // ... data to create a CourseCategory
     *   }
     * })
     * 
     */
    create<T extends CourseCategoryCreateArgs>(args: SelectSubset<T, CourseCategoryCreateArgs<ExtArgs>>): Prisma__CourseCategoryClient<$Result.GetResult<Prisma.$CourseCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourseCategories.
     * @param {CourseCategoryCreateManyArgs} args - Arguments to create many CourseCategories.
     * @example
     * // Create many CourseCategories
     * const courseCategory = await prisma.courseCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCategoryCreateManyArgs>(args?: SelectSubset<T, CourseCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseCategories and returns the data saved in the database.
     * @param {CourseCategoryCreateManyAndReturnArgs} args - Arguments to create many CourseCategories.
     * @example
     * // Create many CourseCategories
     * const courseCategory = await prisma.courseCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseCategories and only return the `id`
     * const courseCategoryWithIdOnly = await prisma.courseCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CourseCategory.
     * @param {CourseCategoryDeleteArgs} args - Arguments to delete one CourseCategory.
     * @example
     * // Delete one CourseCategory
     * const CourseCategory = await prisma.courseCategory.delete({
     *   where: {
     *     // ... filter to delete one CourseCategory
     *   }
     * })
     * 
     */
    delete<T extends CourseCategoryDeleteArgs>(args: SelectSubset<T, CourseCategoryDeleteArgs<ExtArgs>>): Prisma__CourseCategoryClient<$Result.GetResult<Prisma.$CourseCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourseCategory.
     * @param {CourseCategoryUpdateArgs} args - Arguments to update one CourseCategory.
     * @example
     * // Update one CourseCategory
     * const courseCategory = await prisma.courseCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseCategoryUpdateArgs>(args: SelectSubset<T, CourseCategoryUpdateArgs<ExtArgs>>): Prisma__CourseCategoryClient<$Result.GetResult<Prisma.$CourseCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourseCategories.
     * @param {CourseCategoryDeleteManyArgs} args - Arguments to filter CourseCategories to delete.
     * @example
     * // Delete a few CourseCategories
     * const { count } = await prisma.courseCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseCategoryDeleteManyArgs>(args?: SelectSubset<T, CourseCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseCategories
     * const courseCategory = await prisma.courseCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseCategoryUpdateManyArgs>(args: SelectSubset<T, CourseCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseCategories and returns the data updated in the database.
     * @param {CourseCategoryUpdateManyAndReturnArgs} args - Arguments to update many CourseCategories.
     * @example
     * // Update many CourseCategories
     * const courseCategory = await prisma.courseCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CourseCategories and only return the `id`
     * const courseCategoryWithIdOnly = await prisma.courseCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CourseCategory.
     * @param {CourseCategoryUpsertArgs} args - Arguments to update or create a CourseCategory.
     * @example
     * // Update or create a CourseCategory
     * const courseCategory = await prisma.courseCategory.upsert({
     *   create: {
     *     // ... data to create a CourseCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseCategory we want to update
     *   }
     * })
     */
    upsert<T extends CourseCategoryUpsertArgs>(args: SelectSubset<T, CourseCategoryUpsertArgs<ExtArgs>>): Prisma__CourseCategoryClient<$Result.GetResult<Prisma.$CourseCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourseCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCategoryCountArgs} args - Arguments to filter CourseCategories to count.
     * @example
     * // Count the number of CourseCategories
     * const count = await prisma.courseCategory.count({
     *   where: {
     *     // ... the filter for the CourseCategories we want to count
     *   }
     * })
    **/
    count<T extends CourseCategoryCountArgs>(
      args?: Subset<T, CourseCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseCategoryAggregateArgs>(args: Subset<T, CourseCategoryAggregateArgs>): Prisma.PrismaPromise<GetCourseCategoryAggregateType<T>>

    /**
     * Group by CourseCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseCategoryGroupByArgs['orderBy'] }
        : { orderBy?: CourseCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseCategory model
   */
  readonly fields: CourseCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseCategory model
   */
  interface CourseCategoryFieldRefs {
    readonly id: FieldRef<"CourseCategory", 'String'>
    readonly courseId: FieldRef<"CourseCategory", 'String'>
    readonly categoryId: FieldRef<"CourseCategory", 'String'>
    readonly isPrimary: FieldRef<"CourseCategory", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * CourseCategory findUnique
   */
  export type CourseCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCategory
     */
    select?: CourseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseCategory
     */
    omit?: CourseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CourseCategory to fetch.
     */
    where: CourseCategoryWhereUniqueInput
  }

  /**
   * CourseCategory findUniqueOrThrow
   */
  export type CourseCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCategory
     */
    select?: CourseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseCategory
     */
    omit?: CourseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CourseCategory to fetch.
     */
    where: CourseCategoryWhereUniqueInput
  }

  /**
   * CourseCategory findFirst
   */
  export type CourseCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCategory
     */
    select?: CourseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseCategory
     */
    omit?: CourseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CourseCategory to fetch.
     */
    where?: CourseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseCategories to fetch.
     */
    orderBy?: CourseCategoryOrderByWithRelationInput | CourseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseCategories.
     */
    cursor?: CourseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseCategories.
     */
    distinct?: CourseCategoryScalarFieldEnum | CourseCategoryScalarFieldEnum[]
  }

  /**
   * CourseCategory findFirstOrThrow
   */
  export type CourseCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCategory
     */
    select?: CourseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseCategory
     */
    omit?: CourseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CourseCategory to fetch.
     */
    where?: CourseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseCategories to fetch.
     */
    orderBy?: CourseCategoryOrderByWithRelationInput | CourseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseCategories.
     */
    cursor?: CourseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseCategories.
     */
    distinct?: CourseCategoryScalarFieldEnum | CourseCategoryScalarFieldEnum[]
  }

  /**
   * CourseCategory findMany
   */
  export type CourseCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCategory
     */
    select?: CourseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseCategory
     */
    omit?: CourseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CourseCategories to fetch.
     */
    where?: CourseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseCategories to fetch.
     */
    orderBy?: CourseCategoryOrderByWithRelationInput | CourseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseCategories.
     */
    cursor?: CourseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseCategories.
     */
    skip?: number
    distinct?: CourseCategoryScalarFieldEnum | CourseCategoryScalarFieldEnum[]
  }

  /**
   * CourseCategory create
   */
  export type CourseCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCategory
     */
    select?: CourseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseCategory
     */
    omit?: CourseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseCategory.
     */
    data: XOR<CourseCategoryCreateInput, CourseCategoryUncheckedCreateInput>
  }

  /**
   * CourseCategory createMany
   */
  export type CourseCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseCategories.
     */
    data: CourseCategoryCreateManyInput | CourseCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseCategory createManyAndReturn
   */
  export type CourseCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCategory
     */
    select?: CourseCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseCategory
     */
    omit?: CourseCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many CourseCategories.
     */
    data: CourseCategoryCreateManyInput | CourseCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseCategory update
   */
  export type CourseCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCategory
     */
    select?: CourseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseCategory
     */
    omit?: CourseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseCategory.
     */
    data: XOR<CourseCategoryUpdateInput, CourseCategoryUncheckedUpdateInput>
    /**
     * Choose, which CourseCategory to update.
     */
    where: CourseCategoryWhereUniqueInput
  }

  /**
   * CourseCategory updateMany
   */
  export type CourseCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseCategories.
     */
    data: XOR<CourseCategoryUpdateManyMutationInput, CourseCategoryUncheckedUpdateManyInput>
    /**
     * Filter which CourseCategories to update
     */
    where?: CourseCategoryWhereInput
    /**
     * Limit how many CourseCategories to update.
     */
    limit?: number
  }

  /**
   * CourseCategory updateManyAndReturn
   */
  export type CourseCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCategory
     */
    select?: CourseCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseCategory
     */
    omit?: CourseCategoryOmit<ExtArgs> | null
    /**
     * The data used to update CourseCategories.
     */
    data: XOR<CourseCategoryUpdateManyMutationInput, CourseCategoryUncheckedUpdateManyInput>
    /**
     * Filter which CourseCategories to update
     */
    where?: CourseCategoryWhereInput
    /**
     * Limit how many CourseCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseCategory upsert
   */
  export type CourseCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCategory
     */
    select?: CourseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseCategory
     */
    omit?: CourseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseCategory to update in case it exists.
     */
    where: CourseCategoryWhereUniqueInput
    /**
     * In case the CourseCategory found by the `where` argument doesn't exist, create a new CourseCategory with this data.
     */
    create: XOR<CourseCategoryCreateInput, CourseCategoryUncheckedCreateInput>
    /**
     * In case the CourseCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseCategoryUpdateInput, CourseCategoryUncheckedUpdateInput>
  }

  /**
   * CourseCategory delete
   */
  export type CourseCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCategory
     */
    select?: CourseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseCategory
     */
    omit?: CourseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCategoryInclude<ExtArgs> | null
    /**
     * Filter which CourseCategory to delete.
     */
    where: CourseCategoryWhereUniqueInput
  }

  /**
   * CourseCategory deleteMany
   */
  export type CourseCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseCategories to delete
     */
    where?: CourseCategoryWhereInput
    /**
     * Limit how many CourseCategories to delete.
     */
    limit?: number
  }

  /**
   * CourseCategory without action
   */
  export type CourseCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCategory
     */
    select?: CourseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseCategory
     */
    omit?: CourseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    createdAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    createdAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    color: number
    createdAt: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    color?: true
    createdAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    color?: true
    createdAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    color?: true
    createdAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    name: string
    color: string | null
    createdAt: Date
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    createdAt?: boolean
    courses?: boolean | Tag$coursesArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    color?: boolean
    createdAt?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "color" | "createdAt", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | Tag$coursesArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      courses: Prisma.$CourseTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      color: string | null
      createdAt: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courses<T extends Tag$coursesArgs<ExtArgs> = {}>(args?: Subset<T, Tag$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly color: FieldRef<"Tag", 'String'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.courses
   */
  export type Tag$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTag
     */
    omit?: CourseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
    where?: CourseTagWhereInput
    orderBy?: CourseTagOrderByWithRelationInput | CourseTagOrderByWithRelationInput[]
    cursor?: CourseTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseTagScalarFieldEnum | CourseTagScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model CourseTag
   */

  export type AggregateCourseTag = {
    _count: CourseTagCountAggregateOutputType | null
    _min: CourseTagMinAggregateOutputType | null
    _max: CourseTagMaxAggregateOutputType | null
  }

  export type CourseTagMinAggregateOutputType = {
    id: string | null
    courseId: string | null
    tagId: string | null
  }

  export type CourseTagMaxAggregateOutputType = {
    id: string | null
    courseId: string | null
    tagId: string | null
  }

  export type CourseTagCountAggregateOutputType = {
    id: number
    courseId: number
    tagId: number
    _all: number
  }


  export type CourseTagMinAggregateInputType = {
    id?: true
    courseId?: true
    tagId?: true
  }

  export type CourseTagMaxAggregateInputType = {
    id?: true
    courseId?: true
    tagId?: true
  }

  export type CourseTagCountAggregateInputType = {
    id?: true
    courseId?: true
    tagId?: true
    _all?: true
  }

  export type CourseTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseTag to aggregate.
     */
    where?: CourseTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseTags to fetch.
     */
    orderBy?: CourseTagOrderByWithRelationInput | CourseTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseTags
    **/
    _count?: true | CourseTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseTagMaxAggregateInputType
  }

  export type GetCourseTagAggregateType<T extends CourseTagAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseTag[P]>
      : GetScalarType<T[P], AggregateCourseTag[P]>
  }




  export type CourseTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseTagWhereInput
    orderBy?: CourseTagOrderByWithAggregationInput | CourseTagOrderByWithAggregationInput[]
    by: CourseTagScalarFieldEnum[] | CourseTagScalarFieldEnum
    having?: CourseTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseTagCountAggregateInputType | true
    _min?: CourseTagMinAggregateInputType
    _max?: CourseTagMaxAggregateInputType
  }

  export type CourseTagGroupByOutputType = {
    id: string
    courseId: string
    tagId: string
    _count: CourseTagCountAggregateOutputType | null
    _min: CourseTagMinAggregateOutputType | null
    _max: CourseTagMaxAggregateOutputType | null
  }

  type GetCourseTagGroupByPayload<T extends CourseTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseTagGroupByOutputType[P]>
            : GetScalarType<T[P], CourseTagGroupByOutputType[P]>
        }
      >
    >


  export type CourseTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    tagId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseTag"]>

  export type CourseTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    tagId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseTag"]>

  export type CourseTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    tagId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseTag"]>

  export type CourseTagSelectScalar = {
    id?: boolean
    courseId?: boolean
    tagId?: boolean
  }

  export type CourseTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courseId" | "tagId", ExtArgs["result"]["courseTag"]>
  export type CourseTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type CourseTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type CourseTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $CourseTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseTag"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      courseId: string
      tagId: string
    }, ExtArgs["result"]["courseTag"]>
    composites: {}
  }

  type CourseTagGetPayload<S extends boolean | null | undefined | CourseTagDefaultArgs> = $Result.GetResult<Prisma.$CourseTagPayload, S>

  type CourseTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseTagCountAggregateInputType | true
    }

  export interface CourseTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseTag'], meta: { name: 'CourseTag' } }
    /**
     * Find zero or one CourseTag that matches the filter.
     * @param {CourseTagFindUniqueArgs} args - Arguments to find a CourseTag
     * @example
     * // Get one CourseTag
     * const courseTag = await prisma.courseTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseTagFindUniqueArgs>(args: SelectSubset<T, CourseTagFindUniqueArgs<ExtArgs>>): Prisma__CourseTagClient<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourseTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseTagFindUniqueOrThrowArgs} args - Arguments to find a CourseTag
     * @example
     * // Get one CourseTag
     * const courseTag = await prisma.courseTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseTagFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseTagClient<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagFindFirstArgs} args - Arguments to find a CourseTag
     * @example
     * // Get one CourseTag
     * const courseTag = await prisma.courseTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseTagFindFirstArgs>(args?: SelectSubset<T, CourseTagFindFirstArgs<ExtArgs>>): Prisma__CourseTagClient<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagFindFirstOrThrowArgs} args - Arguments to find a CourseTag
     * @example
     * // Get one CourseTag
     * const courseTag = await prisma.courseTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseTagFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseTagClient<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourseTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseTags
     * const courseTags = await prisma.courseTag.findMany()
     * 
     * // Get first 10 CourseTags
     * const courseTags = await prisma.courseTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseTagWithIdOnly = await prisma.courseTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseTagFindManyArgs>(args?: SelectSubset<T, CourseTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourseTag.
     * @param {CourseTagCreateArgs} args - Arguments to create a CourseTag.
     * @example
     * // Create one CourseTag
     * const CourseTag = await prisma.courseTag.create({
     *   data: {
     *     // ... data to create a CourseTag
     *   }
     * })
     * 
     */
    create<T extends CourseTagCreateArgs>(args: SelectSubset<T, CourseTagCreateArgs<ExtArgs>>): Prisma__CourseTagClient<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourseTags.
     * @param {CourseTagCreateManyArgs} args - Arguments to create many CourseTags.
     * @example
     * // Create many CourseTags
     * const courseTag = await prisma.courseTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseTagCreateManyArgs>(args?: SelectSubset<T, CourseTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseTags and returns the data saved in the database.
     * @param {CourseTagCreateManyAndReturnArgs} args - Arguments to create many CourseTags.
     * @example
     * // Create many CourseTags
     * const courseTag = await prisma.courseTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseTags and only return the `id`
     * const courseTagWithIdOnly = await prisma.courseTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseTagCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CourseTag.
     * @param {CourseTagDeleteArgs} args - Arguments to delete one CourseTag.
     * @example
     * // Delete one CourseTag
     * const CourseTag = await prisma.courseTag.delete({
     *   where: {
     *     // ... filter to delete one CourseTag
     *   }
     * })
     * 
     */
    delete<T extends CourseTagDeleteArgs>(args: SelectSubset<T, CourseTagDeleteArgs<ExtArgs>>): Prisma__CourseTagClient<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourseTag.
     * @param {CourseTagUpdateArgs} args - Arguments to update one CourseTag.
     * @example
     * // Update one CourseTag
     * const courseTag = await prisma.courseTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseTagUpdateArgs>(args: SelectSubset<T, CourseTagUpdateArgs<ExtArgs>>): Prisma__CourseTagClient<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourseTags.
     * @param {CourseTagDeleteManyArgs} args - Arguments to filter CourseTags to delete.
     * @example
     * // Delete a few CourseTags
     * const { count } = await prisma.courseTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseTagDeleteManyArgs>(args?: SelectSubset<T, CourseTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseTags
     * const courseTag = await prisma.courseTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseTagUpdateManyArgs>(args: SelectSubset<T, CourseTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseTags and returns the data updated in the database.
     * @param {CourseTagUpdateManyAndReturnArgs} args - Arguments to update many CourseTags.
     * @example
     * // Update many CourseTags
     * const courseTag = await prisma.courseTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CourseTags and only return the `id`
     * const courseTagWithIdOnly = await prisma.courseTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseTagUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CourseTag.
     * @param {CourseTagUpsertArgs} args - Arguments to update or create a CourseTag.
     * @example
     * // Update or create a CourseTag
     * const courseTag = await prisma.courseTag.upsert({
     *   create: {
     *     // ... data to create a CourseTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseTag we want to update
     *   }
     * })
     */
    upsert<T extends CourseTagUpsertArgs>(args: SelectSubset<T, CourseTagUpsertArgs<ExtArgs>>): Prisma__CourseTagClient<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourseTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagCountArgs} args - Arguments to filter CourseTags to count.
     * @example
     * // Count the number of CourseTags
     * const count = await prisma.courseTag.count({
     *   where: {
     *     // ... the filter for the CourseTags we want to count
     *   }
     * })
    **/
    count<T extends CourseTagCountArgs>(
      args?: Subset<T, CourseTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseTagAggregateArgs>(args: Subset<T, CourseTagAggregateArgs>): Prisma.PrismaPromise<GetCourseTagAggregateType<T>>

    /**
     * Group by CourseTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseTagGroupByArgs['orderBy'] }
        : { orderBy?: CourseTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseTag model
   */
  readonly fields: CourseTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseTag model
   */
  interface CourseTagFieldRefs {
    readonly id: FieldRef<"CourseTag", 'String'>
    readonly courseId: FieldRef<"CourseTag", 'String'>
    readonly tagId: FieldRef<"CourseTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CourseTag findUnique
   */
  export type CourseTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTag
     */
    omit?: CourseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
    /**
     * Filter, which CourseTag to fetch.
     */
    where: CourseTagWhereUniqueInput
  }

  /**
   * CourseTag findUniqueOrThrow
   */
  export type CourseTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTag
     */
    omit?: CourseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
    /**
     * Filter, which CourseTag to fetch.
     */
    where: CourseTagWhereUniqueInput
  }

  /**
   * CourseTag findFirst
   */
  export type CourseTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTag
     */
    omit?: CourseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
    /**
     * Filter, which CourseTag to fetch.
     */
    where?: CourseTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseTags to fetch.
     */
    orderBy?: CourseTagOrderByWithRelationInput | CourseTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseTags.
     */
    cursor?: CourseTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseTags.
     */
    distinct?: CourseTagScalarFieldEnum | CourseTagScalarFieldEnum[]
  }

  /**
   * CourseTag findFirstOrThrow
   */
  export type CourseTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTag
     */
    omit?: CourseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
    /**
     * Filter, which CourseTag to fetch.
     */
    where?: CourseTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseTags to fetch.
     */
    orderBy?: CourseTagOrderByWithRelationInput | CourseTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseTags.
     */
    cursor?: CourseTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseTags.
     */
    distinct?: CourseTagScalarFieldEnum | CourseTagScalarFieldEnum[]
  }

  /**
   * CourseTag findMany
   */
  export type CourseTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTag
     */
    omit?: CourseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
    /**
     * Filter, which CourseTags to fetch.
     */
    where?: CourseTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseTags to fetch.
     */
    orderBy?: CourseTagOrderByWithRelationInput | CourseTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseTags.
     */
    cursor?: CourseTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseTags.
     */
    skip?: number
    distinct?: CourseTagScalarFieldEnum | CourseTagScalarFieldEnum[]
  }

  /**
   * CourseTag create
   */
  export type CourseTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTag
     */
    omit?: CourseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseTag.
     */
    data: XOR<CourseTagCreateInput, CourseTagUncheckedCreateInput>
  }

  /**
   * CourseTag createMany
   */
  export type CourseTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseTags.
     */
    data: CourseTagCreateManyInput | CourseTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseTag createManyAndReturn
   */
  export type CourseTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTag
     */
    omit?: CourseTagOmit<ExtArgs> | null
    /**
     * The data used to create many CourseTags.
     */
    data: CourseTagCreateManyInput | CourseTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseTag update
   */
  export type CourseTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTag
     */
    omit?: CourseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseTag.
     */
    data: XOR<CourseTagUpdateInput, CourseTagUncheckedUpdateInput>
    /**
     * Choose, which CourseTag to update.
     */
    where: CourseTagWhereUniqueInput
  }

  /**
   * CourseTag updateMany
   */
  export type CourseTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseTags.
     */
    data: XOR<CourseTagUpdateManyMutationInput, CourseTagUncheckedUpdateManyInput>
    /**
     * Filter which CourseTags to update
     */
    where?: CourseTagWhereInput
    /**
     * Limit how many CourseTags to update.
     */
    limit?: number
  }

  /**
   * CourseTag updateManyAndReturn
   */
  export type CourseTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTag
     */
    omit?: CourseTagOmit<ExtArgs> | null
    /**
     * The data used to update CourseTags.
     */
    data: XOR<CourseTagUpdateManyMutationInput, CourseTagUncheckedUpdateManyInput>
    /**
     * Filter which CourseTags to update
     */
    where?: CourseTagWhereInput
    /**
     * Limit how many CourseTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseTag upsert
   */
  export type CourseTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTag
     */
    omit?: CourseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseTag to update in case it exists.
     */
    where: CourseTagWhereUniqueInput
    /**
     * In case the CourseTag found by the `where` argument doesn't exist, create a new CourseTag with this data.
     */
    create: XOR<CourseTagCreateInput, CourseTagUncheckedCreateInput>
    /**
     * In case the CourseTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseTagUpdateInput, CourseTagUncheckedUpdateInput>
  }

  /**
   * CourseTag delete
   */
  export type CourseTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTag
     */
    omit?: CourseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
    /**
     * Filter which CourseTag to delete.
     */
    where: CourseTagWhereUniqueInput
  }

  /**
   * CourseTag deleteMany
   */
  export type CourseTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseTags to delete
     */
    where?: CourseTagWhereInput
    /**
     * Limit how many CourseTags to delete.
     */
    limit?: number
  }

  /**
   * CourseTag without action
   */
  export type CourseTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseTag
     */
    omit?: CourseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
  }


  /**
   * Model CourseModule
   */

  export type AggregateCourseModule = {
    _count: CourseModuleCountAggregateOutputType | null
    _avg: CourseModuleAvgAggregateOutputType | null
    _sum: CourseModuleSumAggregateOutputType | null
    _min: CourseModuleMinAggregateOutputType | null
    _max: CourseModuleMaxAggregateOutputType | null
  }

  export type CourseModuleAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type CourseModuleSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type CourseModuleMinAggregateOutputType = {
    id: string | null
    courseId: string | null
    title: string | null
    description: string | null
    sortOrder: number | null
    duration: string | null
    isOptional: boolean | null
  }

  export type CourseModuleMaxAggregateOutputType = {
    id: string | null
    courseId: string | null
    title: string | null
    description: string | null
    sortOrder: number | null
    duration: string | null
    isOptional: boolean | null
  }

  export type CourseModuleCountAggregateOutputType = {
    id: number
    courseId: number
    title: number
    description: number
    sortOrder: number
    duration: number
    isOptional: number
    _all: number
  }


  export type CourseModuleAvgAggregateInputType = {
    sortOrder?: true
  }

  export type CourseModuleSumAggregateInputType = {
    sortOrder?: true
  }

  export type CourseModuleMinAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    description?: true
    sortOrder?: true
    duration?: true
    isOptional?: true
  }

  export type CourseModuleMaxAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    description?: true
    sortOrder?: true
    duration?: true
    isOptional?: true
  }

  export type CourseModuleCountAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    description?: true
    sortOrder?: true
    duration?: true
    isOptional?: true
    _all?: true
  }

  export type CourseModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseModule to aggregate.
     */
    where?: CourseModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseModules to fetch.
     */
    orderBy?: CourseModuleOrderByWithRelationInput | CourseModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseModules
    **/
    _count?: true | CourseModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseModuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseModuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseModuleMaxAggregateInputType
  }

  export type GetCourseModuleAggregateType<T extends CourseModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseModule[P]>
      : GetScalarType<T[P], AggregateCourseModule[P]>
  }




  export type CourseModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseModuleWhereInput
    orderBy?: CourseModuleOrderByWithAggregationInput | CourseModuleOrderByWithAggregationInput[]
    by: CourseModuleScalarFieldEnum[] | CourseModuleScalarFieldEnum
    having?: CourseModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseModuleCountAggregateInputType | true
    _avg?: CourseModuleAvgAggregateInputType
    _sum?: CourseModuleSumAggregateInputType
    _min?: CourseModuleMinAggregateInputType
    _max?: CourseModuleMaxAggregateInputType
  }

  export type CourseModuleGroupByOutputType = {
    id: string
    courseId: string
    title: string
    description: string | null
    sortOrder: number
    duration: string | null
    isOptional: boolean
    _count: CourseModuleCountAggregateOutputType | null
    _avg: CourseModuleAvgAggregateOutputType | null
    _sum: CourseModuleSumAggregateOutputType | null
    _min: CourseModuleMinAggregateOutputType | null
    _max: CourseModuleMaxAggregateOutputType | null
  }

  type GetCourseModuleGroupByPayload<T extends CourseModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseModuleGroupByOutputType[P]>
            : GetScalarType<T[P], CourseModuleGroupByOutputType[P]>
        }
      >
    >


  export type CourseModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    sortOrder?: boolean
    duration?: boolean
    isOptional?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseModule"]>

  export type CourseModuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    sortOrder?: boolean
    duration?: boolean
    isOptional?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseModule"]>

  export type CourseModuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    sortOrder?: boolean
    duration?: boolean
    isOptional?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseModule"]>

  export type CourseModuleSelectScalar = {
    id?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    sortOrder?: boolean
    duration?: boolean
    isOptional?: boolean
  }

  export type CourseModuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courseId" | "title" | "description" | "sortOrder" | "duration" | "isOptional", ExtArgs["result"]["courseModule"]>
  export type CourseModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type CourseModuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type CourseModuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $CourseModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseModule"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      courseId: string
      title: string
      description: string | null
      sortOrder: number
      duration: string | null
      isOptional: boolean
    }, ExtArgs["result"]["courseModule"]>
    composites: {}
  }

  type CourseModuleGetPayload<S extends boolean | null | undefined | CourseModuleDefaultArgs> = $Result.GetResult<Prisma.$CourseModulePayload, S>

  type CourseModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseModuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseModuleCountAggregateInputType | true
    }

  export interface CourseModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseModule'], meta: { name: 'CourseModule' } }
    /**
     * Find zero or one CourseModule that matches the filter.
     * @param {CourseModuleFindUniqueArgs} args - Arguments to find a CourseModule
     * @example
     * // Get one CourseModule
     * const courseModule = await prisma.courseModule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseModuleFindUniqueArgs>(args: SelectSubset<T, CourseModuleFindUniqueArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourseModule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseModuleFindUniqueOrThrowArgs} args - Arguments to find a CourseModule
     * @example
     * // Get one CourseModule
     * const courseModule = await prisma.courseModule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseModule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleFindFirstArgs} args - Arguments to find a CourseModule
     * @example
     * // Get one CourseModule
     * const courseModule = await prisma.courseModule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseModuleFindFirstArgs>(args?: SelectSubset<T, CourseModuleFindFirstArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseModule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleFindFirstOrThrowArgs} args - Arguments to find a CourseModule
     * @example
     * // Get one CourseModule
     * const courseModule = await prisma.courseModule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourseModules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseModules
     * const courseModules = await prisma.courseModule.findMany()
     * 
     * // Get first 10 CourseModules
     * const courseModules = await prisma.courseModule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseModuleWithIdOnly = await prisma.courseModule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseModuleFindManyArgs>(args?: SelectSubset<T, CourseModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourseModule.
     * @param {CourseModuleCreateArgs} args - Arguments to create a CourseModule.
     * @example
     * // Create one CourseModule
     * const CourseModule = await prisma.courseModule.create({
     *   data: {
     *     // ... data to create a CourseModule
     *   }
     * })
     * 
     */
    create<T extends CourseModuleCreateArgs>(args: SelectSubset<T, CourseModuleCreateArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourseModules.
     * @param {CourseModuleCreateManyArgs} args - Arguments to create many CourseModules.
     * @example
     * // Create many CourseModules
     * const courseModule = await prisma.courseModule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseModuleCreateManyArgs>(args?: SelectSubset<T, CourseModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseModules and returns the data saved in the database.
     * @param {CourseModuleCreateManyAndReturnArgs} args - Arguments to create many CourseModules.
     * @example
     * // Create many CourseModules
     * const courseModule = await prisma.courseModule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseModules and only return the `id`
     * const courseModuleWithIdOnly = await prisma.courseModule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseModuleCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseModuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CourseModule.
     * @param {CourseModuleDeleteArgs} args - Arguments to delete one CourseModule.
     * @example
     * // Delete one CourseModule
     * const CourseModule = await prisma.courseModule.delete({
     *   where: {
     *     // ... filter to delete one CourseModule
     *   }
     * })
     * 
     */
    delete<T extends CourseModuleDeleteArgs>(args: SelectSubset<T, CourseModuleDeleteArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourseModule.
     * @param {CourseModuleUpdateArgs} args - Arguments to update one CourseModule.
     * @example
     * // Update one CourseModule
     * const courseModule = await prisma.courseModule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseModuleUpdateArgs>(args: SelectSubset<T, CourseModuleUpdateArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourseModules.
     * @param {CourseModuleDeleteManyArgs} args - Arguments to filter CourseModules to delete.
     * @example
     * // Delete a few CourseModules
     * const { count } = await prisma.courseModule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseModuleDeleteManyArgs>(args?: SelectSubset<T, CourseModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseModules
     * const courseModule = await prisma.courseModule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseModuleUpdateManyArgs>(args: SelectSubset<T, CourseModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseModules and returns the data updated in the database.
     * @param {CourseModuleUpdateManyAndReturnArgs} args - Arguments to update many CourseModules.
     * @example
     * // Update many CourseModules
     * const courseModule = await prisma.courseModule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CourseModules and only return the `id`
     * const courseModuleWithIdOnly = await prisma.courseModule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseModuleUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseModuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CourseModule.
     * @param {CourseModuleUpsertArgs} args - Arguments to update or create a CourseModule.
     * @example
     * // Update or create a CourseModule
     * const courseModule = await prisma.courseModule.upsert({
     *   create: {
     *     // ... data to create a CourseModule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseModule we want to update
     *   }
     * })
     */
    upsert<T extends CourseModuleUpsertArgs>(args: SelectSubset<T, CourseModuleUpsertArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourseModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleCountArgs} args - Arguments to filter CourseModules to count.
     * @example
     * // Count the number of CourseModules
     * const count = await prisma.courseModule.count({
     *   where: {
     *     // ... the filter for the CourseModules we want to count
     *   }
     * })
    **/
    count<T extends CourseModuleCountArgs>(
      args?: Subset<T, CourseModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseModuleAggregateArgs>(args: Subset<T, CourseModuleAggregateArgs>): Prisma.PrismaPromise<GetCourseModuleAggregateType<T>>

    /**
     * Group by CourseModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseModuleGroupByArgs['orderBy'] }
        : { orderBy?: CourseModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseModule model
   */
  readonly fields: CourseModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseModule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseModule model
   */
  interface CourseModuleFieldRefs {
    readonly id: FieldRef<"CourseModule", 'String'>
    readonly courseId: FieldRef<"CourseModule", 'String'>
    readonly title: FieldRef<"CourseModule", 'String'>
    readonly description: FieldRef<"CourseModule", 'String'>
    readonly sortOrder: FieldRef<"CourseModule", 'Int'>
    readonly duration: FieldRef<"CourseModule", 'String'>
    readonly isOptional: FieldRef<"CourseModule", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * CourseModule findUnique
   */
  export type CourseModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * Filter, which CourseModule to fetch.
     */
    where: CourseModuleWhereUniqueInput
  }

  /**
   * CourseModule findUniqueOrThrow
   */
  export type CourseModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * Filter, which CourseModule to fetch.
     */
    where: CourseModuleWhereUniqueInput
  }

  /**
   * CourseModule findFirst
   */
  export type CourseModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * Filter, which CourseModule to fetch.
     */
    where?: CourseModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseModules to fetch.
     */
    orderBy?: CourseModuleOrderByWithRelationInput | CourseModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseModules.
     */
    cursor?: CourseModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseModules.
     */
    distinct?: CourseModuleScalarFieldEnum | CourseModuleScalarFieldEnum[]
  }

  /**
   * CourseModule findFirstOrThrow
   */
  export type CourseModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * Filter, which CourseModule to fetch.
     */
    where?: CourseModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseModules to fetch.
     */
    orderBy?: CourseModuleOrderByWithRelationInput | CourseModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseModules.
     */
    cursor?: CourseModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseModules.
     */
    distinct?: CourseModuleScalarFieldEnum | CourseModuleScalarFieldEnum[]
  }

  /**
   * CourseModule findMany
   */
  export type CourseModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * Filter, which CourseModules to fetch.
     */
    where?: CourseModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseModules to fetch.
     */
    orderBy?: CourseModuleOrderByWithRelationInput | CourseModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseModules.
     */
    cursor?: CourseModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseModules.
     */
    skip?: number
    distinct?: CourseModuleScalarFieldEnum | CourseModuleScalarFieldEnum[]
  }

  /**
   * CourseModule create
   */
  export type CourseModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseModule.
     */
    data: XOR<CourseModuleCreateInput, CourseModuleUncheckedCreateInput>
  }

  /**
   * CourseModule createMany
   */
  export type CourseModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseModules.
     */
    data: CourseModuleCreateManyInput | CourseModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseModule createManyAndReturn
   */
  export type CourseModuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * The data used to create many CourseModules.
     */
    data: CourseModuleCreateManyInput | CourseModuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseModule update
   */
  export type CourseModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseModule.
     */
    data: XOR<CourseModuleUpdateInput, CourseModuleUncheckedUpdateInput>
    /**
     * Choose, which CourseModule to update.
     */
    where: CourseModuleWhereUniqueInput
  }

  /**
   * CourseModule updateMany
   */
  export type CourseModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseModules.
     */
    data: XOR<CourseModuleUpdateManyMutationInput, CourseModuleUncheckedUpdateManyInput>
    /**
     * Filter which CourseModules to update
     */
    where?: CourseModuleWhereInput
    /**
     * Limit how many CourseModules to update.
     */
    limit?: number
  }

  /**
   * CourseModule updateManyAndReturn
   */
  export type CourseModuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * The data used to update CourseModules.
     */
    data: XOR<CourseModuleUpdateManyMutationInput, CourseModuleUncheckedUpdateManyInput>
    /**
     * Filter which CourseModules to update
     */
    where?: CourseModuleWhereInput
    /**
     * Limit how many CourseModules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseModule upsert
   */
  export type CourseModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseModule to update in case it exists.
     */
    where: CourseModuleWhereUniqueInput
    /**
     * In case the CourseModule found by the `where` argument doesn't exist, create a new CourseModule with this data.
     */
    create: XOR<CourseModuleCreateInput, CourseModuleUncheckedCreateInput>
    /**
     * In case the CourseModule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseModuleUpdateInput, CourseModuleUncheckedUpdateInput>
  }

  /**
   * CourseModule delete
   */
  export type CourseModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * Filter which CourseModule to delete.
     */
    where: CourseModuleWhereUniqueInput
  }

  /**
   * CourseModule deleteMany
   */
  export type CourseModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseModules to delete
     */
    where?: CourseModuleWhereInput
    /**
     * Limit how many CourseModules to delete.
     */
    limit?: number
  }

  /**
   * CourseModule without action
   */
  export type CourseModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
  }


  /**
   * Model Achievement
   */

  export type AggregateAchievement = {
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  export type AchievementAvgAggregateOutputType = {
    points: number | null
  }

  export type AchievementSumAggregateOutputType = {
    points: number | null
  }

  export type AchievementMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    icon: string | null
    type: $Enums.AchievementType | null
    points: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type AchievementMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    icon: string | null
    type: $Enums.AchievementType | null
    points: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type AchievementCountAggregateOutputType = {
    id: number
    name: number
    description: number
    icon: number
    type: number
    criteria: number
    points: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type AchievementAvgAggregateInputType = {
    points?: true
  }

  export type AchievementSumAggregateInputType = {
    points?: true
  }

  export type AchievementMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    type?: true
    points?: true
    isActive?: true
    createdAt?: true
  }

  export type AchievementMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    type?: true
    points?: true
    isActive?: true
    createdAt?: true
  }

  export type AchievementCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    type?: true
    criteria?: true
    points?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type AchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievement to aggregate.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Achievements
    **/
    _count?: true | AchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementMaxAggregateInputType
  }

  export type GetAchievementAggregateType<T extends AchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievement[P]>
      : GetScalarType<T[P], AggregateAchievement[P]>
  }




  export type AchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithAggregationInput | AchievementOrderByWithAggregationInput[]
    by: AchievementScalarFieldEnum[] | AchievementScalarFieldEnum
    having?: AchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementCountAggregateInputType | true
    _avg?: AchievementAvgAggregateInputType
    _sum?: AchievementSumAggregateInputType
    _min?: AchievementMinAggregateInputType
    _max?: AchievementMaxAggregateInputType
  }

  export type AchievementGroupByOutputType = {
    id: string
    name: string
    description: string
    icon: string | null
    type: $Enums.AchievementType
    criteria: JsonValue
    points: number
    isActive: boolean
    createdAt: Date
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  type GetAchievementGroupByPayload<T extends AchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementGroupByOutputType[P]>
        }
      >
    >


  export type AchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    type?: boolean
    criteria?: boolean
    points?: boolean
    isActive?: boolean
    createdAt?: boolean
    users?: boolean | Achievement$usersArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    type?: boolean
    criteria?: boolean
    points?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    type?: boolean
    criteria?: boolean
    points?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    type?: boolean
    criteria?: boolean
    points?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type AchievementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "icon" | "type" | "criteria" | "points" | "isActive" | "createdAt", ExtArgs["result"]["achievement"]>
  export type AchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Achievement$usersArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AchievementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Achievement"
    objects: {
      users: Prisma.$UserAchievementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      icon: string | null
      type: $Enums.AchievementType
      criteria: Prisma.JsonValue
      points: number
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["achievement"]>
    composites: {}
  }

  type AchievementGetPayload<S extends boolean | null | undefined | AchievementDefaultArgs> = $Result.GetResult<Prisma.$AchievementPayload, S>

  type AchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AchievementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AchievementCountAggregateInputType | true
    }

  export interface AchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Achievement'], meta: { name: 'Achievement' } }
    /**
     * Find zero or one Achievement that matches the filter.
     * @param {AchievementFindUniqueArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AchievementFindUniqueArgs>(args: SelectSubset<T, AchievementFindUniqueArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Achievement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AchievementFindUniqueOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, AchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AchievementFindFirstArgs>(args?: SelectSubset<T, AchievementFindFirstArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, AchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Achievements
     * const achievements = await prisma.achievement.findMany()
     * 
     * // Get first 10 Achievements
     * const achievements = await prisma.achievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementWithIdOnly = await prisma.achievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AchievementFindManyArgs>(args?: SelectSubset<T, AchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Achievement.
     * @param {AchievementCreateArgs} args - Arguments to create a Achievement.
     * @example
     * // Create one Achievement
     * const Achievement = await prisma.achievement.create({
     *   data: {
     *     // ... data to create a Achievement
     *   }
     * })
     * 
     */
    create<T extends AchievementCreateArgs>(args: SelectSubset<T, AchievementCreateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Achievements.
     * @param {AchievementCreateManyArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AchievementCreateManyArgs>(args?: SelectSubset<T, AchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Achievements and returns the data saved in the database.
     * @param {AchievementCreateManyAndReturnArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, AchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Achievement.
     * @param {AchievementDeleteArgs} args - Arguments to delete one Achievement.
     * @example
     * // Delete one Achievement
     * const Achievement = await prisma.achievement.delete({
     *   where: {
     *     // ... filter to delete one Achievement
     *   }
     * })
     * 
     */
    delete<T extends AchievementDeleteArgs>(args: SelectSubset<T, AchievementDeleteArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Achievement.
     * @param {AchievementUpdateArgs} args - Arguments to update one Achievement.
     * @example
     * // Update one Achievement
     * const achievement = await prisma.achievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AchievementUpdateArgs>(args: SelectSubset<T, AchievementUpdateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Achievements.
     * @param {AchievementDeleteManyArgs} args - Arguments to filter Achievements to delete.
     * @example
     * // Delete a few Achievements
     * const { count } = await prisma.achievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AchievementDeleteManyArgs>(args?: SelectSubset<T, AchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AchievementUpdateManyArgs>(args: SelectSubset<T, AchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements and returns the data updated in the database.
     * @param {AchievementUpdateManyAndReturnArgs} args - Arguments to update many Achievements.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AchievementUpdateManyAndReturnArgs>(args: SelectSubset<T, AchievementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Achievement.
     * @param {AchievementUpsertArgs} args - Arguments to update or create a Achievement.
     * @example
     * // Update or create a Achievement
     * const achievement = await prisma.achievement.upsert({
     *   create: {
     *     // ... data to create a Achievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Achievement we want to update
     *   }
     * })
     */
    upsert<T extends AchievementUpsertArgs>(args: SelectSubset<T, AchievementUpsertArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCountArgs} args - Arguments to filter Achievements to count.
     * @example
     * // Count the number of Achievements
     * const count = await prisma.achievement.count({
     *   where: {
     *     // ... the filter for the Achievements we want to count
     *   }
     * })
    **/
    count<T extends AchievementCountArgs>(
      args?: Subset<T, AchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementAggregateArgs>(args: Subset<T, AchievementAggregateArgs>): Prisma.PrismaPromise<GetAchievementAggregateType<T>>

    /**
     * Group by Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchievementGroupByArgs['orderBy'] }
        : { orderBy?: AchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Achievement model
   */
  readonly fields: AchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Achievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Achievement$usersArgs<ExtArgs> = {}>(args?: Subset<T, Achievement$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Achievement model
   */
  interface AchievementFieldRefs {
    readonly id: FieldRef<"Achievement", 'String'>
    readonly name: FieldRef<"Achievement", 'String'>
    readonly description: FieldRef<"Achievement", 'String'>
    readonly icon: FieldRef<"Achievement", 'String'>
    readonly type: FieldRef<"Achievement", 'AchievementType'>
    readonly criteria: FieldRef<"Achievement", 'Json'>
    readonly points: FieldRef<"Achievement", 'Int'>
    readonly isActive: FieldRef<"Achievement", 'Boolean'>
    readonly createdAt: FieldRef<"Achievement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Achievement findUnique
   */
  export type AchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findUniqueOrThrow
   */
  export type AchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findFirst
   */
  export type AchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findFirstOrThrow
   */
  export type AchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findMany
   */
  export type AchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievements to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement create
   */
  export type AchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a Achievement.
     */
    data: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
  }

  /**
   * Achievement createMany
   */
  export type AchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement createManyAndReturn
   */
  export type AchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement update
   */
  export type AchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a Achievement.
     */
    data: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
    /**
     * Choose, which Achievement to update.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement updateMany
   */
  export type AchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to update.
     */
    limit?: number
  }

  /**
   * Achievement updateManyAndReturn
   */
  export type AchievementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to update.
     */
    limit?: number
  }

  /**
   * Achievement upsert
   */
  export type AchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the Achievement to update in case it exists.
     */
    where: AchievementWhereUniqueInput
    /**
     * In case the Achievement found by the `where` argument doesn't exist, create a new Achievement with this data.
     */
    create: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
    /**
     * In case the Achievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
  }

  /**
   * Achievement delete
   */
  export type AchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter which Achievement to delete.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement deleteMany
   */
  export type AchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievements to delete
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to delete.
     */
    limit?: number
  }

  /**
   * Achievement.users
   */
  export type Achievement$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    cursor?: UserAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * Achievement without action
   */
  export type AchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
  }


  /**
   * Model UserAchievement
   */

  export type AggregateUserAchievement = {
    _count: UserAchievementCountAggregateOutputType | null
    _min: UserAchievementMinAggregateOutputType | null
    _max: UserAchievementMaxAggregateOutputType | null
  }

  export type UserAchievementMinAggregateOutputType = {
    id: string | null
    userId: string | null
    achievementId: string | null
    earnedAt: Date | null
  }

  export type UserAchievementMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    achievementId: string | null
    earnedAt: Date | null
  }

  export type UserAchievementCountAggregateOutputType = {
    id: number
    userId: number
    achievementId: number
    earnedAt: number
    progress: number
    _all: number
  }


  export type UserAchievementMinAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
    earnedAt?: true
  }

  export type UserAchievementMaxAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
    earnedAt?: true
  }

  export type UserAchievementCountAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
    earnedAt?: true
    progress?: true
    _all?: true
  }

  export type UserAchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAchievement to aggregate.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAchievements
    **/
    _count?: true | UserAchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAchievementMaxAggregateInputType
  }

  export type GetUserAchievementAggregateType<T extends UserAchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAchievement[P]>
      : GetScalarType<T[P], AggregateUserAchievement[P]>
  }




  export type UserAchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithAggregationInput | UserAchievementOrderByWithAggregationInput[]
    by: UserAchievementScalarFieldEnum[] | UserAchievementScalarFieldEnum
    having?: UserAchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAchievementCountAggregateInputType | true
    _min?: UserAchievementMinAggregateInputType
    _max?: UserAchievementMaxAggregateInputType
  }

  export type UserAchievementGroupByOutputType = {
    id: string
    userId: string
    achievementId: string
    earnedAt: Date
    progress: JsonValue | null
    _count: UserAchievementCountAggregateOutputType | null
    _min: UserAchievementMinAggregateOutputType | null
    _max: UserAchievementMaxAggregateOutputType | null
  }

  type GetUserAchievementGroupByPayload<T extends UserAchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAchievementGroupByOutputType[P]>
            : GetScalarType<T[P], UserAchievementGroupByOutputType[P]>
        }
      >
    >


  export type UserAchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    earnedAt?: boolean
    progress?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    earnedAt?: boolean
    progress?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    earnedAt?: boolean
    progress?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectScalar = {
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    earnedAt?: boolean
    progress?: boolean
  }

  export type UserAchievementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "achievementId" | "earnedAt" | "progress", ExtArgs["result"]["userAchievement"]>
  export type UserAchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }
  export type UserAchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }
  export type UserAchievementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }

  export type $UserAchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAchievement"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      achievement: Prisma.$AchievementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      achievementId: string
      earnedAt: Date
      progress: Prisma.JsonValue | null
    }, ExtArgs["result"]["userAchievement"]>
    composites: {}
  }

  type UserAchievementGetPayload<S extends boolean | null | undefined | UserAchievementDefaultArgs> = $Result.GetResult<Prisma.$UserAchievementPayload, S>

  type UserAchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserAchievementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserAchievementCountAggregateInputType | true
    }

  export interface UserAchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAchievement'], meta: { name: 'UserAchievement' } }
    /**
     * Find zero or one UserAchievement that matches the filter.
     * @param {UserAchievementFindUniqueArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAchievementFindUniqueArgs>(args: SelectSubset<T, UserAchievementFindUniqueArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserAchievement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAchievementFindUniqueOrThrowArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAchievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindFirstArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAchievementFindFirstArgs>(args?: SelectSubset<T, UserAchievementFindFirstArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAchievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindFirstOrThrowArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserAchievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAchievements
     * const userAchievements = await prisma.userAchievement.findMany()
     * 
     * // Get first 10 UserAchievements
     * const userAchievements = await prisma.userAchievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAchievementFindManyArgs>(args?: SelectSubset<T, UserAchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserAchievement.
     * @param {UserAchievementCreateArgs} args - Arguments to create a UserAchievement.
     * @example
     * // Create one UserAchievement
     * const UserAchievement = await prisma.userAchievement.create({
     *   data: {
     *     // ... data to create a UserAchievement
     *   }
     * })
     * 
     */
    create<T extends UserAchievementCreateArgs>(args: SelectSubset<T, UserAchievementCreateArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserAchievements.
     * @param {UserAchievementCreateManyArgs} args - Arguments to create many UserAchievements.
     * @example
     * // Create many UserAchievements
     * const userAchievement = await prisma.userAchievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAchievementCreateManyArgs>(args?: SelectSubset<T, UserAchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAchievements and returns the data saved in the database.
     * @param {UserAchievementCreateManyAndReturnArgs} args - Arguments to create many UserAchievements.
     * @example
     * // Create many UserAchievements
     * const userAchievement = await prisma.userAchievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAchievements and only return the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserAchievement.
     * @param {UserAchievementDeleteArgs} args - Arguments to delete one UserAchievement.
     * @example
     * // Delete one UserAchievement
     * const UserAchievement = await prisma.userAchievement.delete({
     *   where: {
     *     // ... filter to delete one UserAchievement
     *   }
     * })
     * 
     */
    delete<T extends UserAchievementDeleteArgs>(args: SelectSubset<T, UserAchievementDeleteArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserAchievement.
     * @param {UserAchievementUpdateArgs} args - Arguments to update one UserAchievement.
     * @example
     * // Update one UserAchievement
     * const userAchievement = await prisma.userAchievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAchievementUpdateArgs>(args: SelectSubset<T, UserAchievementUpdateArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserAchievements.
     * @param {UserAchievementDeleteManyArgs} args - Arguments to filter UserAchievements to delete.
     * @example
     * // Delete a few UserAchievements
     * const { count } = await prisma.userAchievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAchievementDeleteManyArgs>(args?: SelectSubset<T, UserAchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAchievements
     * const userAchievement = await prisma.userAchievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAchievementUpdateManyArgs>(args: SelectSubset<T, UserAchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAchievements and returns the data updated in the database.
     * @param {UserAchievementUpdateManyAndReturnArgs} args - Arguments to update many UserAchievements.
     * @example
     * // Update many UserAchievements
     * const userAchievement = await prisma.userAchievement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserAchievements and only return the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserAchievementUpdateManyAndReturnArgs>(args: SelectSubset<T, UserAchievementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserAchievement.
     * @param {UserAchievementUpsertArgs} args - Arguments to update or create a UserAchievement.
     * @example
     * // Update or create a UserAchievement
     * const userAchievement = await prisma.userAchievement.upsert({
     *   create: {
     *     // ... data to create a UserAchievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAchievement we want to update
     *   }
     * })
     */
    upsert<T extends UserAchievementUpsertArgs>(args: SelectSubset<T, UserAchievementUpsertArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementCountArgs} args - Arguments to filter UserAchievements to count.
     * @example
     * // Count the number of UserAchievements
     * const count = await prisma.userAchievement.count({
     *   where: {
     *     // ... the filter for the UserAchievements we want to count
     *   }
     * })
    **/
    count<T extends UserAchievementCountArgs>(
      args?: Subset<T, UserAchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAchievementAggregateArgs>(args: Subset<T, UserAchievementAggregateArgs>): Prisma.PrismaPromise<GetUserAchievementAggregateType<T>>

    /**
     * Group by UserAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAchievementGroupByArgs['orderBy'] }
        : { orderBy?: UserAchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAchievement model
   */
  readonly fields: UserAchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAchievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    achievement<T extends AchievementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AchievementDefaultArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAchievement model
   */
  interface UserAchievementFieldRefs {
    readonly id: FieldRef<"UserAchievement", 'String'>
    readonly userId: FieldRef<"UserAchievement", 'String'>
    readonly achievementId: FieldRef<"UserAchievement", 'String'>
    readonly earnedAt: FieldRef<"UserAchievement", 'DateTime'>
    readonly progress: FieldRef<"UserAchievement", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * UserAchievement findUnique
   */
  export type UserAchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement findUniqueOrThrow
   */
  export type UserAchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement findFirst
   */
  export type UserAchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAchievements.
     */
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement findFirstOrThrow
   */
  export type UserAchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAchievements.
     */
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement findMany
   */
  export type UserAchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievements to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement create
   */
  export type UserAchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAchievement.
     */
    data: XOR<UserAchievementCreateInput, UserAchievementUncheckedCreateInput>
  }

  /**
   * UserAchievement createMany
   */
  export type UserAchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAchievements.
     */
    data: UserAchievementCreateManyInput | UserAchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAchievement createManyAndReturn
   */
  export type UserAchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * The data used to create many UserAchievements.
     */
    data: UserAchievementCreateManyInput | UserAchievementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAchievement update
   */
  export type UserAchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAchievement.
     */
    data: XOR<UserAchievementUpdateInput, UserAchievementUncheckedUpdateInput>
    /**
     * Choose, which UserAchievement to update.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement updateMany
   */
  export type UserAchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAchievements.
     */
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyInput>
    /**
     * Filter which UserAchievements to update
     */
    where?: UserAchievementWhereInput
    /**
     * Limit how many UserAchievements to update.
     */
    limit?: number
  }

  /**
   * UserAchievement updateManyAndReturn
   */
  export type UserAchievementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * The data used to update UserAchievements.
     */
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyInput>
    /**
     * Filter which UserAchievements to update
     */
    where?: UserAchievementWhereInput
    /**
     * Limit how many UserAchievements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAchievement upsert
   */
  export type UserAchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAchievement to update in case it exists.
     */
    where: UserAchievementWhereUniqueInput
    /**
     * In case the UserAchievement found by the `where` argument doesn't exist, create a new UserAchievement with this data.
     */
    create: XOR<UserAchievementCreateInput, UserAchievementUncheckedCreateInput>
    /**
     * In case the UserAchievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAchievementUpdateInput, UserAchievementUncheckedUpdateInput>
  }

  /**
   * UserAchievement delete
   */
  export type UserAchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter which UserAchievement to delete.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement deleteMany
   */
  export type UserAchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAchievements to delete
     */
    where?: UserAchievementWhereInput
    /**
     * Limit how many UserAchievements to delete.
     */
    limit?: number
  }

  /**
   * UserAchievement without action
   */
  export type UserAchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: string | null
    isRead: boolean | null
    createdAt: Date | null
    readAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: string | null
    isRead: boolean | null
    createdAt: Date | null
    readAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    message: number
    type: number
    isRead: number
    data: number
    createdAt: number
    readAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    isRead?: true
    createdAt?: true
    readAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    isRead?: true
    createdAt?: true
    readAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    isRead?: true
    data?: true
    createdAt?: true
    readAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    title: string
    message: string
    type: string
    isRead: boolean
    data: JsonValue | null
    createdAt: Date
    readAt: Date | null
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    data?: boolean
    createdAt?: boolean
    readAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    data?: boolean
    createdAt?: boolean
    readAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    data?: boolean
    createdAt?: boolean
    readAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    data?: boolean
    createdAt?: boolean
    readAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "message" | "type" | "isRead" | "data" | "createdAt" | "readAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      message: string
      type: string
      isRead: boolean
      data: Prisma.JsonValue | null
      createdAt: Date
      readAt: Date | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly data: FieldRef<"Notification", 'Json'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model ProgressReport
   */

  export type AggregateProgressReport = {
    _count: ProgressReportCountAggregateOutputType | null
    _avg: ProgressReportAvgAggregateOutputType | null
    _sum: ProgressReportSumAggregateOutputType | null
    _min: ProgressReportMinAggregateOutputType | null
    _max: ProgressReportMaxAggregateOutputType | null
  }

  export type ProgressReportAvgAggregateOutputType = {
    coursesCompleted: number | null
    reviewsWritten: number | null
    pointsEarned: number | null
  }

  export type ProgressReportSumAggregateOutputType = {
    coursesCompleted: number | null
    reviewsWritten: number | null
    pointsEarned: number | null
  }

  export type ProgressReportMinAggregateOutputType = {
    id: string | null
    userId: string | null
    reportDate: Date | null
    coursesCompleted: number | null
    reviewsWritten: number | null
    pointsEarned: number | null
    weeklyGoalMet: boolean | null
    monthlyGoalMet: boolean | null
  }

  export type ProgressReportMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    reportDate: Date | null
    coursesCompleted: number | null
    reviewsWritten: number | null
    pointsEarned: number | null
    weeklyGoalMet: boolean | null
    monthlyGoalMet: boolean | null
  }

  export type ProgressReportCountAggregateOutputType = {
    id: number
    userId: number
    reportDate: number
    coursesCompleted: number
    reviewsWritten: number
    pointsEarned: number
    skillsLearned: number
    weeklyGoalMet: number
    monthlyGoalMet: number
    _all: number
  }


  export type ProgressReportAvgAggregateInputType = {
    coursesCompleted?: true
    reviewsWritten?: true
    pointsEarned?: true
  }

  export type ProgressReportSumAggregateInputType = {
    coursesCompleted?: true
    reviewsWritten?: true
    pointsEarned?: true
  }

  export type ProgressReportMinAggregateInputType = {
    id?: true
    userId?: true
    reportDate?: true
    coursesCompleted?: true
    reviewsWritten?: true
    pointsEarned?: true
    weeklyGoalMet?: true
    monthlyGoalMet?: true
  }

  export type ProgressReportMaxAggregateInputType = {
    id?: true
    userId?: true
    reportDate?: true
    coursesCompleted?: true
    reviewsWritten?: true
    pointsEarned?: true
    weeklyGoalMet?: true
    monthlyGoalMet?: true
  }

  export type ProgressReportCountAggregateInputType = {
    id?: true
    userId?: true
    reportDate?: true
    coursesCompleted?: true
    reviewsWritten?: true
    pointsEarned?: true
    skillsLearned?: true
    weeklyGoalMet?: true
    monthlyGoalMet?: true
    _all?: true
  }

  export type ProgressReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgressReport to aggregate.
     */
    where?: ProgressReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgressReports to fetch.
     */
    orderBy?: ProgressReportOrderByWithRelationInput | ProgressReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgressReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgressReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgressReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProgressReports
    **/
    _count?: true | ProgressReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgressReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgressReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgressReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgressReportMaxAggregateInputType
  }

  export type GetProgressReportAggregateType<T extends ProgressReportAggregateArgs> = {
        [P in keyof T & keyof AggregateProgressReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgressReport[P]>
      : GetScalarType<T[P], AggregateProgressReport[P]>
  }




  export type ProgressReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgressReportWhereInput
    orderBy?: ProgressReportOrderByWithAggregationInput | ProgressReportOrderByWithAggregationInput[]
    by: ProgressReportScalarFieldEnum[] | ProgressReportScalarFieldEnum
    having?: ProgressReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgressReportCountAggregateInputType | true
    _avg?: ProgressReportAvgAggregateInputType
    _sum?: ProgressReportSumAggregateInputType
    _min?: ProgressReportMinAggregateInputType
    _max?: ProgressReportMaxAggregateInputType
  }

  export type ProgressReportGroupByOutputType = {
    id: string
    userId: string
    reportDate: Date
    coursesCompleted: number
    reviewsWritten: number
    pointsEarned: number
    skillsLearned: string[]
    weeklyGoalMet: boolean
    monthlyGoalMet: boolean
    _count: ProgressReportCountAggregateOutputType | null
    _avg: ProgressReportAvgAggregateOutputType | null
    _sum: ProgressReportSumAggregateOutputType | null
    _min: ProgressReportMinAggregateOutputType | null
    _max: ProgressReportMaxAggregateOutputType | null
  }

  type GetProgressReportGroupByPayload<T extends ProgressReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgressReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgressReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgressReportGroupByOutputType[P]>
            : GetScalarType<T[P], ProgressReportGroupByOutputType[P]>
        }
      >
    >


  export type ProgressReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    reportDate?: boolean
    coursesCompleted?: boolean
    reviewsWritten?: boolean
    pointsEarned?: boolean
    skillsLearned?: boolean
    weeklyGoalMet?: boolean
    monthlyGoalMet?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["progressReport"]>

  export type ProgressReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    reportDate?: boolean
    coursesCompleted?: boolean
    reviewsWritten?: boolean
    pointsEarned?: boolean
    skillsLearned?: boolean
    weeklyGoalMet?: boolean
    monthlyGoalMet?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["progressReport"]>

  export type ProgressReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    reportDate?: boolean
    coursesCompleted?: boolean
    reviewsWritten?: boolean
    pointsEarned?: boolean
    skillsLearned?: boolean
    weeklyGoalMet?: boolean
    monthlyGoalMet?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["progressReport"]>

  export type ProgressReportSelectScalar = {
    id?: boolean
    userId?: boolean
    reportDate?: boolean
    coursesCompleted?: boolean
    reviewsWritten?: boolean
    pointsEarned?: boolean
    skillsLearned?: boolean
    weeklyGoalMet?: boolean
    monthlyGoalMet?: boolean
  }

  export type ProgressReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "reportDate" | "coursesCompleted" | "reviewsWritten" | "pointsEarned" | "skillsLearned" | "weeklyGoalMet" | "monthlyGoalMet", ExtArgs["result"]["progressReport"]>
  export type ProgressReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProgressReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProgressReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProgressReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProgressReport"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      reportDate: Date
      coursesCompleted: number
      reviewsWritten: number
      pointsEarned: number
      skillsLearned: string[]
      weeklyGoalMet: boolean
      monthlyGoalMet: boolean
    }, ExtArgs["result"]["progressReport"]>
    composites: {}
  }

  type ProgressReportGetPayload<S extends boolean | null | undefined | ProgressReportDefaultArgs> = $Result.GetResult<Prisma.$ProgressReportPayload, S>

  type ProgressReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProgressReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProgressReportCountAggregateInputType | true
    }

  export interface ProgressReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProgressReport'], meta: { name: 'ProgressReport' } }
    /**
     * Find zero or one ProgressReport that matches the filter.
     * @param {ProgressReportFindUniqueArgs} args - Arguments to find a ProgressReport
     * @example
     * // Get one ProgressReport
     * const progressReport = await prisma.progressReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgressReportFindUniqueArgs>(args: SelectSubset<T, ProgressReportFindUniqueArgs<ExtArgs>>): Prisma__ProgressReportClient<$Result.GetResult<Prisma.$ProgressReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProgressReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProgressReportFindUniqueOrThrowArgs} args - Arguments to find a ProgressReport
     * @example
     * // Get one ProgressReport
     * const progressReport = await prisma.progressReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgressReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgressReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgressReportClient<$Result.GetResult<Prisma.$ProgressReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProgressReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressReportFindFirstArgs} args - Arguments to find a ProgressReport
     * @example
     * // Get one ProgressReport
     * const progressReport = await prisma.progressReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgressReportFindFirstArgs>(args?: SelectSubset<T, ProgressReportFindFirstArgs<ExtArgs>>): Prisma__ProgressReportClient<$Result.GetResult<Prisma.$ProgressReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProgressReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressReportFindFirstOrThrowArgs} args - Arguments to find a ProgressReport
     * @example
     * // Get one ProgressReport
     * const progressReport = await prisma.progressReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgressReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgressReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgressReportClient<$Result.GetResult<Prisma.$ProgressReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProgressReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProgressReports
     * const progressReports = await prisma.progressReport.findMany()
     * 
     * // Get first 10 ProgressReports
     * const progressReports = await prisma.progressReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const progressReportWithIdOnly = await prisma.progressReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgressReportFindManyArgs>(args?: SelectSubset<T, ProgressReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgressReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProgressReport.
     * @param {ProgressReportCreateArgs} args - Arguments to create a ProgressReport.
     * @example
     * // Create one ProgressReport
     * const ProgressReport = await prisma.progressReport.create({
     *   data: {
     *     // ... data to create a ProgressReport
     *   }
     * })
     * 
     */
    create<T extends ProgressReportCreateArgs>(args: SelectSubset<T, ProgressReportCreateArgs<ExtArgs>>): Prisma__ProgressReportClient<$Result.GetResult<Prisma.$ProgressReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProgressReports.
     * @param {ProgressReportCreateManyArgs} args - Arguments to create many ProgressReports.
     * @example
     * // Create many ProgressReports
     * const progressReport = await prisma.progressReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgressReportCreateManyArgs>(args?: SelectSubset<T, ProgressReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProgressReports and returns the data saved in the database.
     * @param {ProgressReportCreateManyAndReturnArgs} args - Arguments to create many ProgressReports.
     * @example
     * // Create many ProgressReports
     * const progressReport = await prisma.progressReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProgressReports and only return the `id`
     * const progressReportWithIdOnly = await prisma.progressReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgressReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgressReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgressReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProgressReport.
     * @param {ProgressReportDeleteArgs} args - Arguments to delete one ProgressReport.
     * @example
     * // Delete one ProgressReport
     * const ProgressReport = await prisma.progressReport.delete({
     *   where: {
     *     // ... filter to delete one ProgressReport
     *   }
     * })
     * 
     */
    delete<T extends ProgressReportDeleteArgs>(args: SelectSubset<T, ProgressReportDeleteArgs<ExtArgs>>): Prisma__ProgressReportClient<$Result.GetResult<Prisma.$ProgressReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProgressReport.
     * @param {ProgressReportUpdateArgs} args - Arguments to update one ProgressReport.
     * @example
     * // Update one ProgressReport
     * const progressReport = await prisma.progressReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgressReportUpdateArgs>(args: SelectSubset<T, ProgressReportUpdateArgs<ExtArgs>>): Prisma__ProgressReportClient<$Result.GetResult<Prisma.$ProgressReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProgressReports.
     * @param {ProgressReportDeleteManyArgs} args - Arguments to filter ProgressReports to delete.
     * @example
     * // Delete a few ProgressReports
     * const { count } = await prisma.progressReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgressReportDeleteManyArgs>(args?: SelectSubset<T, ProgressReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgressReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProgressReports
     * const progressReport = await prisma.progressReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgressReportUpdateManyArgs>(args: SelectSubset<T, ProgressReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgressReports and returns the data updated in the database.
     * @param {ProgressReportUpdateManyAndReturnArgs} args - Arguments to update many ProgressReports.
     * @example
     * // Update many ProgressReports
     * const progressReport = await prisma.progressReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProgressReports and only return the `id`
     * const progressReportWithIdOnly = await prisma.progressReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProgressReportUpdateManyAndReturnArgs>(args: SelectSubset<T, ProgressReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgressReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProgressReport.
     * @param {ProgressReportUpsertArgs} args - Arguments to update or create a ProgressReport.
     * @example
     * // Update or create a ProgressReport
     * const progressReport = await prisma.progressReport.upsert({
     *   create: {
     *     // ... data to create a ProgressReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProgressReport we want to update
     *   }
     * })
     */
    upsert<T extends ProgressReportUpsertArgs>(args: SelectSubset<T, ProgressReportUpsertArgs<ExtArgs>>): Prisma__ProgressReportClient<$Result.GetResult<Prisma.$ProgressReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProgressReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressReportCountArgs} args - Arguments to filter ProgressReports to count.
     * @example
     * // Count the number of ProgressReports
     * const count = await prisma.progressReport.count({
     *   where: {
     *     // ... the filter for the ProgressReports we want to count
     *   }
     * })
    **/
    count<T extends ProgressReportCountArgs>(
      args?: Subset<T, ProgressReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgressReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProgressReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgressReportAggregateArgs>(args: Subset<T, ProgressReportAggregateArgs>): Prisma.PrismaPromise<GetProgressReportAggregateType<T>>

    /**
     * Group by ProgressReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgressReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgressReportGroupByArgs['orderBy'] }
        : { orderBy?: ProgressReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgressReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgressReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProgressReport model
   */
  readonly fields: ProgressReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProgressReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgressReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProgressReport model
   */
  interface ProgressReportFieldRefs {
    readonly id: FieldRef<"ProgressReport", 'String'>
    readonly userId: FieldRef<"ProgressReport", 'String'>
    readonly reportDate: FieldRef<"ProgressReport", 'DateTime'>
    readonly coursesCompleted: FieldRef<"ProgressReport", 'Int'>
    readonly reviewsWritten: FieldRef<"ProgressReport", 'Int'>
    readonly pointsEarned: FieldRef<"ProgressReport", 'Int'>
    readonly skillsLearned: FieldRef<"ProgressReport", 'String[]'>
    readonly weeklyGoalMet: FieldRef<"ProgressReport", 'Boolean'>
    readonly monthlyGoalMet: FieldRef<"ProgressReport", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ProgressReport findUnique
   */
  export type ProgressReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressReport
     */
    select?: ProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressReport
     */
    omit?: ProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressReportInclude<ExtArgs> | null
    /**
     * Filter, which ProgressReport to fetch.
     */
    where: ProgressReportWhereUniqueInput
  }

  /**
   * ProgressReport findUniqueOrThrow
   */
  export type ProgressReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressReport
     */
    select?: ProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressReport
     */
    omit?: ProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressReportInclude<ExtArgs> | null
    /**
     * Filter, which ProgressReport to fetch.
     */
    where: ProgressReportWhereUniqueInput
  }

  /**
   * ProgressReport findFirst
   */
  export type ProgressReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressReport
     */
    select?: ProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressReport
     */
    omit?: ProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressReportInclude<ExtArgs> | null
    /**
     * Filter, which ProgressReport to fetch.
     */
    where?: ProgressReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgressReports to fetch.
     */
    orderBy?: ProgressReportOrderByWithRelationInput | ProgressReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgressReports.
     */
    cursor?: ProgressReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgressReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgressReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgressReports.
     */
    distinct?: ProgressReportScalarFieldEnum | ProgressReportScalarFieldEnum[]
  }

  /**
   * ProgressReport findFirstOrThrow
   */
  export type ProgressReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressReport
     */
    select?: ProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressReport
     */
    omit?: ProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressReportInclude<ExtArgs> | null
    /**
     * Filter, which ProgressReport to fetch.
     */
    where?: ProgressReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgressReports to fetch.
     */
    orderBy?: ProgressReportOrderByWithRelationInput | ProgressReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgressReports.
     */
    cursor?: ProgressReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgressReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgressReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgressReports.
     */
    distinct?: ProgressReportScalarFieldEnum | ProgressReportScalarFieldEnum[]
  }

  /**
   * ProgressReport findMany
   */
  export type ProgressReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressReport
     */
    select?: ProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressReport
     */
    omit?: ProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressReportInclude<ExtArgs> | null
    /**
     * Filter, which ProgressReports to fetch.
     */
    where?: ProgressReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgressReports to fetch.
     */
    orderBy?: ProgressReportOrderByWithRelationInput | ProgressReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProgressReports.
     */
    cursor?: ProgressReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgressReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgressReports.
     */
    skip?: number
    distinct?: ProgressReportScalarFieldEnum | ProgressReportScalarFieldEnum[]
  }

  /**
   * ProgressReport create
   */
  export type ProgressReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressReport
     */
    select?: ProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressReport
     */
    omit?: ProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressReportInclude<ExtArgs> | null
    /**
     * The data needed to create a ProgressReport.
     */
    data: XOR<ProgressReportCreateInput, ProgressReportUncheckedCreateInput>
  }

  /**
   * ProgressReport createMany
   */
  export type ProgressReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProgressReports.
     */
    data: ProgressReportCreateManyInput | ProgressReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProgressReport createManyAndReturn
   */
  export type ProgressReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressReport
     */
    select?: ProgressReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressReport
     */
    omit?: ProgressReportOmit<ExtArgs> | null
    /**
     * The data used to create many ProgressReports.
     */
    data: ProgressReportCreateManyInput | ProgressReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProgressReport update
   */
  export type ProgressReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressReport
     */
    select?: ProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressReport
     */
    omit?: ProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressReportInclude<ExtArgs> | null
    /**
     * The data needed to update a ProgressReport.
     */
    data: XOR<ProgressReportUpdateInput, ProgressReportUncheckedUpdateInput>
    /**
     * Choose, which ProgressReport to update.
     */
    where: ProgressReportWhereUniqueInput
  }

  /**
   * ProgressReport updateMany
   */
  export type ProgressReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProgressReports.
     */
    data: XOR<ProgressReportUpdateManyMutationInput, ProgressReportUncheckedUpdateManyInput>
    /**
     * Filter which ProgressReports to update
     */
    where?: ProgressReportWhereInput
    /**
     * Limit how many ProgressReports to update.
     */
    limit?: number
  }

  /**
   * ProgressReport updateManyAndReturn
   */
  export type ProgressReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressReport
     */
    select?: ProgressReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressReport
     */
    omit?: ProgressReportOmit<ExtArgs> | null
    /**
     * The data used to update ProgressReports.
     */
    data: XOR<ProgressReportUpdateManyMutationInput, ProgressReportUncheckedUpdateManyInput>
    /**
     * Filter which ProgressReports to update
     */
    where?: ProgressReportWhereInput
    /**
     * Limit how many ProgressReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProgressReport upsert
   */
  export type ProgressReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressReport
     */
    select?: ProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressReport
     */
    omit?: ProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressReportInclude<ExtArgs> | null
    /**
     * The filter to search for the ProgressReport to update in case it exists.
     */
    where: ProgressReportWhereUniqueInput
    /**
     * In case the ProgressReport found by the `where` argument doesn't exist, create a new ProgressReport with this data.
     */
    create: XOR<ProgressReportCreateInput, ProgressReportUncheckedCreateInput>
    /**
     * In case the ProgressReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgressReportUpdateInput, ProgressReportUncheckedUpdateInput>
  }

  /**
   * ProgressReport delete
   */
  export type ProgressReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressReport
     */
    select?: ProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressReport
     */
    omit?: ProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressReportInclude<ExtArgs> | null
    /**
     * Filter which ProgressReport to delete.
     */
    where: ProgressReportWhereUniqueInput
  }

  /**
   * ProgressReport deleteMany
   */
  export type ProgressReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgressReports to delete
     */
    where?: ProgressReportWhereInput
    /**
     * Limit how many ProgressReports to delete.
     */
    limit?: number
  }

  /**
   * ProgressReport without action
   */
  export type ProgressReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressReport
     */
    select?: ProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressReport
     */
    omit?: ProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressReportInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    firstName: 'firstName',
    lastName: 'lastName',
    profileImage: 'profileImage',
    bio: 'bio',
    role: 'role',
    isVerified: 'isVerified',
    verificationToken: 'verificationToken',
    passwordHash: 'passwordHash',
    totalPoints: 'totalPoints',
    reviewStreak: 'reviewStreak',
    lastActiveAt: 'lastActiveAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    shortDescription: 'shortDescription',
    imageUrl: 'imageUrl',
    thumbnailUrl: 'thumbnailUrl',
    courseUrl: 'courseUrl',
    instructor: 'instructor',
    institution: 'institution',
    duration: 'duration',
    difficulty: 'difficulty',
    status: 'status',
    price: 'price',
    isFree: 'isFree',
    language: 'language',
    rating: 'rating',
    reviewCount: 'reviewCount',
    enrollmentCount: 'enrollmentCount',
    isActive: 'isActive',
    prerequisites: 'prerequisites',
    learningOutcomes: 'learningOutcomes',
    syllabus: 'syllabus',
    lastUpdated: 'lastUpdated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const SkillScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category',
    icon: 'icon',
    color: 'color',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SkillScalarFieldEnum = (typeof SkillScalarFieldEnum)[keyof typeof SkillScalarFieldEnum]


  export const CourseSkillScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    skillId: 'skillId',
    level: 'level',
    isCore: 'isCore',
    percentage: 'percentage',
    createdAt: 'createdAt'
  };

  export type CourseSkillScalarFieldEnum = (typeof CourseSkillScalarFieldEnum)[keyof typeof CourseSkillScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    courseId: 'courseId',
    overallRating: 'overallRating',
    difficultyRating: 'difficultyRating',
    contentQuality: 'contentQuality',
    instructorRating: 'instructorRating',
    valueForMoney: 'valueForMoney',
    wouldRecommend: 'wouldRecommend',
    title: 'title',
    content: 'content',
    pros: 'pros',
    cons: 'cons',
    isAnonymous: 'isAnonymous',
    isVerified: 'isVerified',
    helpfulCount: 'helpfulCount',
    flagCount: 'flagCount',
    isHidden: 'isHidden',
    moderatorNotes: 'moderatorNotes',
    completionDate: 'completionDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const ReviewVoteScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    reviewId: 'reviewId',
    isUpvote: 'isUpvote',
    createdAt: 'createdAt'
  };

  export type ReviewVoteScalarFieldEnum = (typeof ReviewVoteScalarFieldEnum)[keyof typeof ReviewVoteScalarFieldEnum]


  export const ReviewHelpfulVoteScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    reviewId: 'reviewId',
    isHelpful: 'isHelpful',
    createdAt: 'createdAt'
  };

  export type ReviewHelpfulVoteScalarFieldEnum = (typeof ReviewHelpfulVoteScalarFieldEnum)[keyof typeof ReviewHelpfulVoteScalarFieldEnum]


  export const ReviewSkillRatingScalarFieldEnum: {
    id: 'id',
    reviewId: 'reviewId',
    skillId: 'skillId',
    rating: 'rating',
    createdAt: 'createdAt'
  };

  export type ReviewSkillRatingScalarFieldEnum = (typeof ReviewSkillRatingScalarFieldEnum)[keyof typeof ReviewSkillRatingScalarFieldEnum]


  export const CourseEnrollmentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    courseId: 'courseId',
    enrolledAt: 'enrolledAt',
    completedAt: 'completedAt',
    progress: 'progress',
    lastAccessed: 'lastAccessed',
    status: 'status',
    certificateUrl: 'certificateUrl'
  };

  export type CourseEnrollmentScalarFieldEnum = (typeof CourseEnrollmentScalarFieldEnum)[keyof typeof CourseEnrollmentScalarFieldEnum]


  export const UserSkillProficiencyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    skillId: 'skillId',
    level: 'level',
    yearsExperience: 'yearsExperience',
    lastUsed: 'lastUsed',
    isVerified: 'isVerified',
    verificationSource: 'verificationSource',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserSkillProficiencyScalarFieldEnum = (typeof UserSkillProficiencyScalarFieldEnum)[keyof typeof UserSkillProficiencyScalarFieldEnum]


  export const SkillPrerequisiteScalarFieldEnum: {
    id: 'id',
    skillId: 'skillId',
    prerequisiteSkillId: 'prerequisiteSkillId',
    isRequired: 'isRequired',
    minimumLevel: 'minimumLevel'
  };

  export type SkillPrerequisiteScalarFieldEnum = (typeof SkillPrerequisiteScalarFieldEnum)[keyof typeof SkillPrerequisiteScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    icon: 'icon',
    color: 'color',
    parentId: 'parentId',
    sortOrder: 'sortOrder',
    isActive: 'isActive'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const CourseCategoryScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    categoryId: 'categoryId',
    isPrimary: 'isPrimary'
  };

  export type CourseCategoryScalarFieldEnum = (typeof CourseCategoryScalarFieldEnum)[keyof typeof CourseCategoryScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color',
    createdAt: 'createdAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const CourseTagScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    tagId: 'tagId'
  };

  export type CourseTagScalarFieldEnum = (typeof CourseTagScalarFieldEnum)[keyof typeof CourseTagScalarFieldEnum]


  export const CourseModuleScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    title: 'title',
    description: 'description',
    sortOrder: 'sortOrder',
    duration: 'duration',
    isOptional: 'isOptional'
  };

  export type CourseModuleScalarFieldEnum = (typeof CourseModuleScalarFieldEnum)[keyof typeof CourseModuleScalarFieldEnum]


  export const AchievementScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    icon: 'icon',
    type: 'type',
    criteria: 'criteria',
    points: 'points',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type AchievementScalarFieldEnum = (typeof AchievementScalarFieldEnum)[keyof typeof AchievementScalarFieldEnum]


  export const UserAchievementScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    achievementId: 'achievementId',
    earnedAt: 'earnedAt',
    progress: 'progress'
  };

  export type UserAchievementScalarFieldEnum = (typeof UserAchievementScalarFieldEnum)[keyof typeof UserAchievementScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    message: 'message',
    type: 'type',
    isRead: 'isRead',
    data: 'data',
    createdAt: 'createdAt',
    readAt: 'readAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const ProgressReportScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    reportDate: 'reportDate',
    coursesCompleted: 'coursesCompleted',
    reviewsWritten: 'reviewsWritten',
    pointsEarned: 'pointsEarned',
    skillsLearned: 'skillsLearned',
    weeklyGoalMet: 'weeklyGoalMet',
    monthlyGoalMet: 'monthlyGoalMet'
  };

  export type ProgressReportScalarFieldEnum = (typeof ProgressReportScalarFieldEnum)[keyof typeof ProgressReportScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Difficulty'
   */
  export type EnumDifficultyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Difficulty'>
    


  /**
   * Reference to a field of type 'Difficulty[]'
   */
  export type ListEnumDifficultyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Difficulty[]'>
    


  /**
   * Reference to a field of type 'CourseStatus'
   */
  export type EnumCourseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseStatus'>
    


  /**
   * Reference to a field of type 'CourseStatus[]'
   */
  export type ListEnumCourseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseStatus[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'SkillLevel'
   */
  export type EnumSkillLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SkillLevel'>
    


  /**
   * Reference to a field of type 'SkillLevel[]'
   */
  export type ListEnumSkillLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SkillLevel[]'>
    


  /**
   * Reference to a field of type 'AchievementType'
   */
  export type EnumAchievementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AchievementType'>
    


  /**
   * Reference to a field of type 'AchievementType[]'
   */
  export type ListEnumAchievementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AchievementType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    profileImage?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isVerified?: BoolFilter<"User"> | boolean
    verificationToken?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringFilter<"User"> | string
    totalPoints?: IntFilter<"User"> | number
    reviewStreak?: IntFilter<"User"> | number
    lastActiveAt?: DateTimeFilter<"User"> | Date | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    reviews?: ReviewListRelationFilter
    reviewVotes?: ReviewVoteListRelationFilter
    enrollments?: CourseEnrollmentListRelationFilter
    achievements?: UserAchievementListRelationFilter
    notifications?: NotificationListRelationFilter
    courses?: CourseListRelationFilter
    skillProficiencies?: UserSkillProficiencyListRelationFilter
    reviewHelpfulVotes?: ReviewHelpfulVoteListRelationFilter
    progressReports?: ProgressReportListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    verificationToken?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    totalPoints?: SortOrder
    reviewStreak?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviews?: ReviewOrderByRelationAggregateInput
    reviewVotes?: ReviewVoteOrderByRelationAggregateInput
    enrollments?: CourseEnrollmentOrderByRelationAggregateInput
    achievements?: UserAchievementOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    courses?: CourseOrderByRelationAggregateInput
    skillProficiencies?: UserSkillProficiencyOrderByRelationAggregateInput
    reviewHelpfulVotes?: ReviewHelpfulVoteOrderByRelationAggregateInput
    progressReports?: ProgressReportOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    profileImage?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isVerified?: BoolFilter<"User"> | boolean
    verificationToken?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringFilter<"User"> | string
    totalPoints?: IntFilter<"User"> | number
    reviewStreak?: IntFilter<"User"> | number
    lastActiveAt?: DateTimeFilter<"User"> | Date | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    reviews?: ReviewListRelationFilter
    reviewVotes?: ReviewVoteListRelationFilter
    enrollments?: CourseEnrollmentListRelationFilter
    achievements?: UserAchievementListRelationFilter
    notifications?: NotificationListRelationFilter
    courses?: CourseListRelationFilter
    skillProficiencies?: UserSkillProficiencyListRelationFilter
    reviewHelpfulVotes?: ReviewHelpfulVoteListRelationFilter
    progressReports?: ProgressReportListRelationFilter
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    verificationToken?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    totalPoints?: SortOrder
    reviewStreak?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    profileImage?: StringNullableWithAggregatesFilter<"User"> | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
    verificationToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    totalPoints?: IntWithAggregatesFilter<"User"> | number
    reviewStreak?: IntWithAggregatesFilter<"User"> | number
    lastActiveAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    id?: StringFilter<"Course"> | string
    title?: StringFilter<"Course"> | string
    description?: StringFilter<"Course"> | string
    shortDescription?: StringNullableFilter<"Course"> | string | null
    imageUrl?: StringNullableFilter<"Course"> | string | null
    thumbnailUrl?: StringNullableFilter<"Course"> | string | null
    courseUrl?: StringFilter<"Course"> | string
    instructor?: StringFilter<"Course"> | string
    institution?: StringNullableFilter<"Course"> | string | null
    duration?: StringNullableFilter<"Course"> | string | null
    difficulty?: EnumDifficultyFilter<"Course"> | $Enums.Difficulty
    status?: EnumCourseStatusFilter<"Course"> | $Enums.CourseStatus
    price?: DecimalNullableFilter<"Course"> | Decimal | DecimalJsLike | number | string | null
    isFree?: BoolFilter<"Course"> | boolean
    language?: StringFilter<"Course"> | string
    rating?: DecimalNullableFilter<"Course"> | Decimal | DecimalJsLike | number | string | null
    reviewCount?: IntFilter<"Course"> | number
    enrollmentCount?: IntFilter<"Course"> | number
    isActive?: BoolFilter<"Course"> | boolean
    prerequisites?: StringNullableListFilter<"Course">
    learningOutcomes?: StringNullableListFilter<"Course">
    syllabus?: JsonNullableFilter<"Course">
    lastUpdated?: DateTimeNullableFilter<"Course"> | Date | string | null
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    createdById?: StringFilter<"Course"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    reviews?: ReviewListRelationFilter
    skills?: CourseSkillListRelationFilter
    enrollments?: CourseEnrollmentListRelationFilter
    categories?: CourseCategoryListRelationFilter
    tags?: CourseTagListRelationFilter
    modules?: CourseModuleListRelationFilter
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    courseUrl?: SortOrder
    instructor?: SortOrder
    institution?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    difficulty?: SortOrder
    status?: SortOrder
    price?: SortOrderInput | SortOrder
    isFree?: SortOrder
    language?: SortOrder
    rating?: SortOrderInput | SortOrder
    reviewCount?: SortOrder
    enrollmentCount?: SortOrder
    isActive?: SortOrder
    prerequisites?: SortOrder
    learningOutcomes?: SortOrder
    syllabus?: SortOrderInput | SortOrder
    lastUpdated?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    reviews?: ReviewOrderByRelationAggregateInput
    skills?: CourseSkillOrderByRelationAggregateInput
    enrollments?: CourseEnrollmentOrderByRelationAggregateInput
    categories?: CourseCategoryOrderByRelationAggregateInput
    tags?: CourseTagOrderByRelationAggregateInput
    modules?: CourseModuleOrderByRelationAggregateInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    title?: StringFilter<"Course"> | string
    description?: StringFilter<"Course"> | string
    shortDescription?: StringNullableFilter<"Course"> | string | null
    imageUrl?: StringNullableFilter<"Course"> | string | null
    thumbnailUrl?: StringNullableFilter<"Course"> | string | null
    courseUrl?: StringFilter<"Course"> | string
    instructor?: StringFilter<"Course"> | string
    institution?: StringNullableFilter<"Course"> | string | null
    duration?: StringNullableFilter<"Course"> | string | null
    difficulty?: EnumDifficultyFilter<"Course"> | $Enums.Difficulty
    status?: EnumCourseStatusFilter<"Course"> | $Enums.CourseStatus
    price?: DecimalNullableFilter<"Course"> | Decimal | DecimalJsLike | number | string | null
    isFree?: BoolFilter<"Course"> | boolean
    language?: StringFilter<"Course"> | string
    rating?: DecimalNullableFilter<"Course"> | Decimal | DecimalJsLike | number | string | null
    reviewCount?: IntFilter<"Course"> | number
    enrollmentCount?: IntFilter<"Course"> | number
    isActive?: BoolFilter<"Course"> | boolean
    prerequisites?: StringNullableListFilter<"Course">
    learningOutcomes?: StringNullableListFilter<"Course">
    syllabus?: JsonNullableFilter<"Course">
    lastUpdated?: DateTimeNullableFilter<"Course"> | Date | string | null
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    createdById?: StringFilter<"Course"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    reviews?: ReviewListRelationFilter
    skills?: CourseSkillListRelationFilter
    enrollments?: CourseEnrollmentListRelationFilter
    categories?: CourseCategoryListRelationFilter
    tags?: CourseTagListRelationFilter
    modules?: CourseModuleListRelationFilter
  }, "id">

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    courseUrl?: SortOrder
    instructor?: SortOrder
    institution?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    difficulty?: SortOrder
    status?: SortOrder
    price?: SortOrderInput | SortOrder
    isFree?: SortOrder
    language?: SortOrder
    rating?: SortOrderInput | SortOrder
    reviewCount?: SortOrder
    enrollmentCount?: SortOrder
    isActive?: SortOrder
    prerequisites?: SortOrder
    learningOutcomes?: SortOrder
    syllabus?: SortOrderInput | SortOrder
    lastUpdated?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    _count?: CourseCountOrderByAggregateInput
    _avg?: CourseAvgOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
    _sum?: CourseSumOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Course"> | string
    title?: StringWithAggregatesFilter<"Course"> | string
    description?: StringWithAggregatesFilter<"Course"> | string
    shortDescription?: StringNullableWithAggregatesFilter<"Course"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Course"> | string | null
    thumbnailUrl?: StringNullableWithAggregatesFilter<"Course"> | string | null
    courseUrl?: StringWithAggregatesFilter<"Course"> | string
    instructor?: StringWithAggregatesFilter<"Course"> | string
    institution?: StringNullableWithAggregatesFilter<"Course"> | string | null
    duration?: StringNullableWithAggregatesFilter<"Course"> | string | null
    difficulty?: EnumDifficultyWithAggregatesFilter<"Course"> | $Enums.Difficulty
    status?: EnumCourseStatusWithAggregatesFilter<"Course"> | $Enums.CourseStatus
    price?: DecimalNullableWithAggregatesFilter<"Course"> | Decimal | DecimalJsLike | number | string | null
    isFree?: BoolWithAggregatesFilter<"Course"> | boolean
    language?: StringWithAggregatesFilter<"Course"> | string
    rating?: DecimalNullableWithAggregatesFilter<"Course"> | Decimal | DecimalJsLike | number | string | null
    reviewCount?: IntWithAggregatesFilter<"Course"> | number
    enrollmentCount?: IntWithAggregatesFilter<"Course"> | number
    isActive?: BoolWithAggregatesFilter<"Course"> | boolean
    prerequisites?: StringNullableListFilter<"Course">
    learningOutcomes?: StringNullableListFilter<"Course">
    syllabus?: JsonNullableWithAggregatesFilter<"Course">
    lastUpdated?: DateTimeNullableWithAggregatesFilter<"Course"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
    createdById?: StringWithAggregatesFilter<"Course"> | string
  }

  export type SkillWhereInput = {
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    id?: StringFilter<"Skill"> | string
    name?: StringFilter<"Skill"> | string
    description?: StringNullableFilter<"Skill"> | string | null
    category?: StringNullableFilter<"Skill"> | string | null
    icon?: StringNullableFilter<"Skill"> | string | null
    color?: StringNullableFilter<"Skill"> | string | null
    isActive?: BoolFilter<"Skill"> | boolean
    createdAt?: DateTimeFilter<"Skill"> | Date | string
    updatedAt?: DateTimeFilter<"Skill"> | Date | string
    courses?: CourseSkillListRelationFilter
    userProficiencies?: UserSkillProficiencyListRelationFilter
    prerequisiteFor?: SkillPrerequisiteListRelationFilter
    prerequisites?: SkillPrerequisiteListRelationFilter
    reviewRatings?: ReviewSkillRatingListRelationFilter
  }

  export type SkillOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courses?: CourseSkillOrderByRelationAggregateInput
    userProficiencies?: UserSkillProficiencyOrderByRelationAggregateInput
    prerequisiteFor?: SkillPrerequisiteOrderByRelationAggregateInput
    prerequisites?: SkillPrerequisiteOrderByRelationAggregateInput
    reviewRatings?: ReviewSkillRatingOrderByRelationAggregateInput
  }

  export type SkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    description?: StringNullableFilter<"Skill"> | string | null
    category?: StringNullableFilter<"Skill"> | string | null
    icon?: StringNullableFilter<"Skill"> | string | null
    color?: StringNullableFilter<"Skill"> | string | null
    isActive?: BoolFilter<"Skill"> | boolean
    createdAt?: DateTimeFilter<"Skill"> | Date | string
    updatedAt?: DateTimeFilter<"Skill"> | Date | string
    courses?: CourseSkillListRelationFilter
    userProficiencies?: UserSkillProficiencyListRelationFilter
    prerequisiteFor?: SkillPrerequisiteListRelationFilter
    prerequisites?: SkillPrerequisiteListRelationFilter
    reviewRatings?: ReviewSkillRatingListRelationFilter
  }, "id" | "name">

  export type SkillOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SkillCountOrderByAggregateInput
    _max?: SkillMaxOrderByAggregateInput
    _min?: SkillMinOrderByAggregateInput
  }

  export type SkillScalarWhereWithAggregatesInput = {
    AND?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    OR?: SkillScalarWhereWithAggregatesInput[]
    NOT?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Skill"> | string
    name?: StringWithAggregatesFilter<"Skill"> | string
    description?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    category?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    color?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    isActive?: BoolWithAggregatesFilter<"Skill"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Skill"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Skill"> | Date | string
  }

  export type CourseSkillWhereInput = {
    AND?: CourseSkillWhereInput | CourseSkillWhereInput[]
    OR?: CourseSkillWhereInput[]
    NOT?: CourseSkillWhereInput | CourseSkillWhereInput[]
    id?: StringFilter<"CourseSkill"> | string
    courseId?: StringFilter<"CourseSkill"> | string
    skillId?: StringFilter<"CourseSkill"> | string
    level?: EnumSkillLevelFilter<"CourseSkill"> | $Enums.SkillLevel
    isCore?: BoolFilter<"CourseSkill"> | boolean
    percentage?: IntNullableFilter<"CourseSkill"> | number | null
    createdAt?: DateTimeFilter<"CourseSkill"> | Date | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    skill?: XOR<SkillScalarRelationFilter, SkillWhereInput>
  }

  export type CourseSkillOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    isCore?: SortOrder
    percentage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    course?: CourseOrderByWithRelationInput
    skill?: SkillOrderByWithRelationInput
  }

  export type CourseSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    courseId_skillId?: CourseSkillCourseIdSkillIdCompoundUniqueInput
    AND?: CourseSkillWhereInput | CourseSkillWhereInput[]
    OR?: CourseSkillWhereInput[]
    NOT?: CourseSkillWhereInput | CourseSkillWhereInput[]
    courseId?: StringFilter<"CourseSkill"> | string
    skillId?: StringFilter<"CourseSkill"> | string
    level?: EnumSkillLevelFilter<"CourseSkill"> | $Enums.SkillLevel
    isCore?: BoolFilter<"CourseSkill"> | boolean
    percentage?: IntNullableFilter<"CourseSkill"> | number | null
    createdAt?: DateTimeFilter<"CourseSkill"> | Date | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    skill?: XOR<SkillScalarRelationFilter, SkillWhereInput>
  }, "id" | "courseId_skillId">

  export type CourseSkillOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    isCore?: SortOrder
    percentage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CourseSkillCountOrderByAggregateInput
    _avg?: CourseSkillAvgOrderByAggregateInput
    _max?: CourseSkillMaxOrderByAggregateInput
    _min?: CourseSkillMinOrderByAggregateInput
    _sum?: CourseSkillSumOrderByAggregateInput
  }

  export type CourseSkillScalarWhereWithAggregatesInput = {
    AND?: CourseSkillScalarWhereWithAggregatesInput | CourseSkillScalarWhereWithAggregatesInput[]
    OR?: CourseSkillScalarWhereWithAggregatesInput[]
    NOT?: CourseSkillScalarWhereWithAggregatesInput | CourseSkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CourseSkill"> | string
    courseId?: StringWithAggregatesFilter<"CourseSkill"> | string
    skillId?: StringWithAggregatesFilter<"CourseSkill"> | string
    level?: EnumSkillLevelWithAggregatesFilter<"CourseSkill"> | $Enums.SkillLevel
    isCore?: BoolWithAggregatesFilter<"CourseSkill"> | boolean
    percentage?: IntNullableWithAggregatesFilter<"CourseSkill"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"CourseSkill"> | Date | string
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    userId?: StringFilter<"Review"> | string
    courseId?: StringFilter<"Review"> | string
    overallRating?: IntFilter<"Review"> | number
    difficultyRating?: IntNullableFilter<"Review"> | number | null
    contentQuality?: IntNullableFilter<"Review"> | number | null
    instructorRating?: IntNullableFilter<"Review"> | number | null
    valueForMoney?: IntNullableFilter<"Review"> | number | null
    wouldRecommend?: BoolNullableFilter<"Review"> | boolean | null
    title?: StringFilter<"Review"> | string
    content?: StringFilter<"Review"> | string
    pros?: StringNullableListFilter<"Review">
    cons?: StringNullableListFilter<"Review">
    isAnonymous?: BoolFilter<"Review"> | boolean
    isVerified?: BoolFilter<"Review"> | boolean
    helpfulCount?: IntFilter<"Review"> | number
    flagCount?: IntFilter<"Review"> | number
    isHidden?: BoolFilter<"Review"> | boolean
    moderatorNotes?: StringNullableFilter<"Review"> | string | null
    completionDate?: DateTimeNullableFilter<"Review"> | Date | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    votes?: ReviewVoteListRelationFilter
    helpfulVotes?: ReviewHelpfulVoteListRelationFilter
    skillRatings?: ReviewSkillRatingListRelationFilter
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    overallRating?: SortOrder
    difficultyRating?: SortOrderInput | SortOrder
    contentQuality?: SortOrderInput | SortOrder
    instructorRating?: SortOrderInput | SortOrder
    valueForMoney?: SortOrderInput | SortOrder
    wouldRecommend?: SortOrderInput | SortOrder
    title?: SortOrder
    content?: SortOrder
    pros?: SortOrder
    cons?: SortOrder
    isAnonymous?: SortOrder
    isVerified?: SortOrder
    helpfulCount?: SortOrder
    flagCount?: SortOrder
    isHidden?: SortOrder
    moderatorNotes?: SortOrderInput | SortOrder
    completionDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    votes?: ReviewVoteOrderByRelationAggregateInput
    helpfulVotes?: ReviewHelpfulVoteOrderByRelationAggregateInput
    skillRatings?: ReviewSkillRatingOrderByRelationAggregateInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_courseId?: ReviewUserIdCourseIdCompoundUniqueInput
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    userId?: StringFilter<"Review"> | string
    courseId?: StringFilter<"Review"> | string
    overallRating?: IntFilter<"Review"> | number
    difficultyRating?: IntNullableFilter<"Review"> | number | null
    contentQuality?: IntNullableFilter<"Review"> | number | null
    instructorRating?: IntNullableFilter<"Review"> | number | null
    valueForMoney?: IntNullableFilter<"Review"> | number | null
    wouldRecommend?: BoolNullableFilter<"Review"> | boolean | null
    title?: StringFilter<"Review"> | string
    content?: StringFilter<"Review"> | string
    pros?: StringNullableListFilter<"Review">
    cons?: StringNullableListFilter<"Review">
    isAnonymous?: BoolFilter<"Review"> | boolean
    isVerified?: BoolFilter<"Review"> | boolean
    helpfulCount?: IntFilter<"Review"> | number
    flagCount?: IntFilter<"Review"> | number
    isHidden?: BoolFilter<"Review"> | boolean
    moderatorNotes?: StringNullableFilter<"Review"> | string | null
    completionDate?: DateTimeNullableFilter<"Review"> | Date | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    votes?: ReviewVoteListRelationFilter
    helpfulVotes?: ReviewHelpfulVoteListRelationFilter
    skillRatings?: ReviewSkillRatingListRelationFilter
  }, "id" | "userId_courseId">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    overallRating?: SortOrder
    difficultyRating?: SortOrderInput | SortOrder
    contentQuality?: SortOrderInput | SortOrder
    instructorRating?: SortOrderInput | SortOrder
    valueForMoney?: SortOrderInput | SortOrder
    wouldRecommend?: SortOrderInput | SortOrder
    title?: SortOrder
    content?: SortOrder
    pros?: SortOrder
    cons?: SortOrder
    isAnonymous?: SortOrder
    isVerified?: SortOrder
    helpfulCount?: SortOrder
    flagCount?: SortOrder
    isHidden?: SortOrder
    moderatorNotes?: SortOrderInput | SortOrder
    completionDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    userId?: StringWithAggregatesFilter<"Review"> | string
    courseId?: StringWithAggregatesFilter<"Review"> | string
    overallRating?: IntWithAggregatesFilter<"Review"> | number
    difficultyRating?: IntNullableWithAggregatesFilter<"Review"> | number | null
    contentQuality?: IntNullableWithAggregatesFilter<"Review"> | number | null
    instructorRating?: IntNullableWithAggregatesFilter<"Review"> | number | null
    valueForMoney?: IntNullableWithAggregatesFilter<"Review"> | number | null
    wouldRecommend?: BoolNullableWithAggregatesFilter<"Review"> | boolean | null
    title?: StringWithAggregatesFilter<"Review"> | string
    content?: StringWithAggregatesFilter<"Review"> | string
    pros?: StringNullableListFilter<"Review">
    cons?: StringNullableListFilter<"Review">
    isAnonymous?: BoolWithAggregatesFilter<"Review"> | boolean
    isVerified?: BoolWithAggregatesFilter<"Review"> | boolean
    helpfulCount?: IntWithAggregatesFilter<"Review"> | number
    flagCount?: IntWithAggregatesFilter<"Review"> | number
    isHidden?: BoolWithAggregatesFilter<"Review"> | boolean
    moderatorNotes?: StringNullableWithAggregatesFilter<"Review"> | string | null
    completionDate?: DateTimeNullableWithAggregatesFilter<"Review"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type ReviewVoteWhereInput = {
    AND?: ReviewVoteWhereInput | ReviewVoteWhereInput[]
    OR?: ReviewVoteWhereInput[]
    NOT?: ReviewVoteWhereInput | ReviewVoteWhereInput[]
    id?: StringFilter<"ReviewVote"> | string
    userId?: StringFilter<"ReviewVote"> | string
    reviewId?: StringFilter<"ReviewVote"> | string
    isUpvote?: BoolFilter<"ReviewVote"> | boolean
    createdAt?: DateTimeFilter<"ReviewVote"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    review?: XOR<ReviewScalarRelationFilter, ReviewWhereInput>
  }

  export type ReviewVoteOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    reviewId?: SortOrder
    isUpvote?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    review?: ReviewOrderByWithRelationInput
  }

  export type ReviewVoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_reviewId?: ReviewVoteUserIdReviewIdCompoundUniqueInput
    AND?: ReviewVoteWhereInput | ReviewVoteWhereInput[]
    OR?: ReviewVoteWhereInput[]
    NOT?: ReviewVoteWhereInput | ReviewVoteWhereInput[]
    userId?: StringFilter<"ReviewVote"> | string
    reviewId?: StringFilter<"ReviewVote"> | string
    isUpvote?: BoolFilter<"ReviewVote"> | boolean
    createdAt?: DateTimeFilter<"ReviewVote"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    review?: XOR<ReviewScalarRelationFilter, ReviewWhereInput>
  }, "id" | "userId_reviewId">

  export type ReviewVoteOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    reviewId?: SortOrder
    isUpvote?: SortOrder
    createdAt?: SortOrder
    _count?: ReviewVoteCountOrderByAggregateInput
    _max?: ReviewVoteMaxOrderByAggregateInput
    _min?: ReviewVoteMinOrderByAggregateInput
  }

  export type ReviewVoteScalarWhereWithAggregatesInput = {
    AND?: ReviewVoteScalarWhereWithAggregatesInput | ReviewVoteScalarWhereWithAggregatesInput[]
    OR?: ReviewVoteScalarWhereWithAggregatesInput[]
    NOT?: ReviewVoteScalarWhereWithAggregatesInput | ReviewVoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReviewVote"> | string
    userId?: StringWithAggregatesFilter<"ReviewVote"> | string
    reviewId?: StringWithAggregatesFilter<"ReviewVote"> | string
    isUpvote?: BoolWithAggregatesFilter<"ReviewVote"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ReviewVote"> | Date | string
  }

  export type ReviewHelpfulVoteWhereInput = {
    AND?: ReviewHelpfulVoteWhereInput | ReviewHelpfulVoteWhereInput[]
    OR?: ReviewHelpfulVoteWhereInput[]
    NOT?: ReviewHelpfulVoteWhereInput | ReviewHelpfulVoteWhereInput[]
    id?: StringFilter<"ReviewHelpfulVote"> | string
    userId?: StringFilter<"ReviewHelpfulVote"> | string
    reviewId?: StringFilter<"ReviewHelpfulVote"> | string
    isHelpful?: BoolFilter<"ReviewHelpfulVote"> | boolean
    createdAt?: DateTimeFilter<"ReviewHelpfulVote"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    review?: XOR<ReviewScalarRelationFilter, ReviewWhereInput>
  }

  export type ReviewHelpfulVoteOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    reviewId?: SortOrder
    isHelpful?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    review?: ReviewOrderByWithRelationInput
  }

  export type ReviewHelpfulVoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_reviewId?: ReviewHelpfulVoteUserIdReviewIdCompoundUniqueInput
    AND?: ReviewHelpfulVoteWhereInput | ReviewHelpfulVoteWhereInput[]
    OR?: ReviewHelpfulVoteWhereInput[]
    NOT?: ReviewHelpfulVoteWhereInput | ReviewHelpfulVoteWhereInput[]
    userId?: StringFilter<"ReviewHelpfulVote"> | string
    reviewId?: StringFilter<"ReviewHelpfulVote"> | string
    isHelpful?: BoolFilter<"ReviewHelpfulVote"> | boolean
    createdAt?: DateTimeFilter<"ReviewHelpfulVote"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    review?: XOR<ReviewScalarRelationFilter, ReviewWhereInput>
  }, "id" | "userId_reviewId">

  export type ReviewHelpfulVoteOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    reviewId?: SortOrder
    isHelpful?: SortOrder
    createdAt?: SortOrder
    _count?: ReviewHelpfulVoteCountOrderByAggregateInput
    _max?: ReviewHelpfulVoteMaxOrderByAggregateInput
    _min?: ReviewHelpfulVoteMinOrderByAggregateInput
  }

  export type ReviewHelpfulVoteScalarWhereWithAggregatesInput = {
    AND?: ReviewHelpfulVoteScalarWhereWithAggregatesInput | ReviewHelpfulVoteScalarWhereWithAggregatesInput[]
    OR?: ReviewHelpfulVoteScalarWhereWithAggregatesInput[]
    NOT?: ReviewHelpfulVoteScalarWhereWithAggregatesInput | ReviewHelpfulVoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReviewHelpfulVote"> | string
    userId?: StringWithAggregatesFilter<"ReviewHelpfulVote"> | string
    reviewId?: StringWithAggregatesFilter<"ReviewHelpfulVote"> | string
    isHelpful?: BoolWithAggregatesFilter<"ReviewHelpfulVote"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ReviewHelpfulVote"> | Date | string
  }

  export type ReviewSkillRatingWhereInput = {
    AND?: ReviewSkillRatingWhereInput | ReviewSkillRatingWhereInput[]
    OR?: ReviewSkillRatingWhereInput[]
    NOT?: ReviewSkillRatingWhereInput | ReviewSkillRatingWhereInput[]
    id?: StringFilter<"ReviewSkillRating"> | string
    reviewId?: StringFilter<"ReviewSkillRating"> | string
    skillId?: StringFilter<"ReviewSkillRating"> | string
    rating?: IntFilter<"ReviewSkillRating"> | number
    createdAt?: DateTimeFilter<"ReviewSkillRating"> | Date | string
    review?: XOR<ReviewScalarRelationFilter, ReviewWhereInput>
    skill?: XOR<SkillScalarRelationFilter, SkillWhereInput>
  }

  export type ReviewSkillRatingOrderByWithRelationInput = {
    id?: SortOrder
    reviewId?: SortOrder
    skillId?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    review?: ReviewOrderByWithRelationInput
    skill?: SkillOrderByWithRelationInput
  }

  export type ReviewSkillRatingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    reviewId_skillId?: ReviewSkillRatingReviewIdSkillIdCompoundUniqueInput
    AND?: ReviewSkillRatingWhereInput | ReviewSkillRatingWhereInput[]
    OR?: ReviewSkillRatingWhereInput[]
    NOT?: ReviewSkillRatingWhereInput | ReviewSkillRatingWhereInput[]
    reviewId?: StringFilter<"ReviewSkillRating"> | string
    skillId?: StringFilter<"ReviewSkillRating"> | string
    rating?: IntFilter<"ReviewSkillRating"> | number
    createdAt?: DateTimeFilter<"ReviewSkillRating"> | Date | string
    review?: XOR<ReviewScalarRelationFilter, ReviewWhereInput>
    skill?: XOR<SkillScalarRelationFilter, SkillWhereInput>
  }, "id" | "reviewId_skillId">

  export type ReviewSkillRatingOrderByWithAggregationInput = {
    id?: SortOrder
    reviewId?: SortOrder
    skillId?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    _count?: ReviewSkillRatingCountOrderByAggregateInput
    _avg?: ReviewSkillRatingAvgOrderByAggregateInput
    _max?: ReviewSkillRatingMaxOrderByAggregateInput
    _min?: ReviewSkillRatingMinOrderByAggregateInput
    _sum?: ReviewSkillRatingSumOrderByAggregateInput
  }

  export type ReviewSkillRatingScalarWhereWithAggregatesInput = {
    AND?: ReviewSkillRatingScalarWhereWithAggregatesInput | ReviewSkillRatingScalarWhereWithAggregatesInput[]
    OR?: ReviewSkillRatingScalarWhereWithAggregatesInput[]
    NOT?: ReviewSkillRatingScalarWhereWithAggregatesInput | ReviewSkillRatingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReviewSkillRating"> | string
    reviewId?: StringWithAggregatesFilter<"ReviewSkillRating"> | string
    skillId?: StringWithAggregatesFilter<"ReviewSkillRating"> | string
    rating?: IntWithAggregatesFilter<"ReviewSkillRating"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ReviewSkillRating"> | Date | string
  }

  export type CourseEnrollmentWhereInput = {
    AND?: CourseEnrollmentWhereInput | CourseEnrollmentWhereInput[]
    OR?: CourseEnrollmentWhereInput[]
    NOT?: CourseEnrollmentWhereInput | CourseEnrollmentWhereInput[]
    id?: StringFilter<"CourseEnrollment"> | string
    userId?: StringFilter<"CourseEnrollment"> | string
    courseId?: StringFilter<"CourseEnrollment"> | string
    enrolledAt?: DateTimeFilter<"CourseEnrollment"> | Date | string
    completedAt?: DateTimeNullableFilter<"CourseEnrollment"> | Date | string | null
    progress?: IntFilter<"CourseEnrollment"> | number
    lastAccessed?: DateTimeFilter<"CourseEnrollment"> | Date | string
    status?: StringFilter<"CourseEnrollment"> | string
    certificateUrl?: StringNullableFilter<"CourseEnrollment"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }

  export type CourseEnrollmentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    progress?: SortOrder
    lastAccessed?: SortOrder
    status?: SortOrder
    certificateUrl?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type CourseEnrollmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_courseId?: CourseEnrollmentUserIdCourseIdCompoundUniqueInput
    AND?: CourseEnrollmentWhereInput | CourseEnrollmentWhereInput[]
    OR?: CourseEnrollmentWhereInput[]
    NOT?: CourseEnrollmentWhereInput | CourseEnrollmentWhereInput[]
    userId?: StringFilter<"CourseEnrollment"> | string
    courseId?: StringFilter<"CourseEnrollment"> | string
    enrolledAt?: DateTimeFilter<"CourseEnrollment"> | Date | string
    completedAt?: DateTimeNullableFilter<"CourseEnrollment"> | Date | string | null
    progress?: IntFilter<"CourseEnrollment"> | number
    lastAccessed?: DateTimeFilter<"CourseEnrollment"> | Date | string
    status?: StringFilter<"CourseEnrollment"> | string
    certificateUrl?: StringNullableFilter<"CourseEnrollment"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }, "id" | "userId_courseId">

  export type CourseEnrollmentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    progress?: SortOrder
    lastAccessed?: SortOrder
    status?: SortOrder
    certificateUrl?: SortOrderInput | SortOrder
    _count?: CourseEnrollmentCountOrderByAggregateInput
    _avg?: CourseEnrollmentAvgOrderByAggregateInput
    _max?: CourseEnrollmentMaxOrderByAggregateInput
    _min?: CourseEnrollmentMinOrderByAggregateInput
    _sum?: CourseEnrollmentSumOrderByAggregateInput
  }

  export type CourseEnrollmentScalarWhereWithAggregatesInput = {
    AND?: CourseEnrollmentScalarWhereWithAggregatesInput | CourseEnrollmentScalarWhereWithAggregatesInput[]
    OR?: CourseEnrollmentScalarWhereWithAggregatesInput[]
    NOT?: CourseEnrollmentScalarWhereWithAggregatesInput | CourseEnrollmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CourseEnrollment"> | string
    userId?: StringWithAggregatesFilter<"CourseEnrollment"> | string
    courseId?: StringWithAggregatesFilter<"CourseEnrollment"> | string
    enrolledAt?: DateTimeWithAggregatesFilter<"CourseEnrollment"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"CourseEnrollment"> | Date | string | null
    progress?: IntWithAggregatesFilter<"CourseEnrollment"> | number
    lastAccessed?: DateTimeWithAggregatesFilter<"CourseEnrollment"> | Date | string
    status?: StringWithAggregatesFilter<"CourseEnrollment"> | string
    certificateUrl?: StringNullableWithAggregatesFilter<"CourseEnrollment"> | string | null
  }

  export type UserSkillProficiencyWhereInput = {
    AND?: UserSkillProficiencyWhereInput | UserSkillProficiencyWhereInput[]
    OR?: UserSkillProficiencyWhereInput[]
    NOT?: UserSkillProficiencyWhereInput | UserSkillProficiencyWhereInput[]
    id?: StringFilter<"UserSkillProficiency"> | string
    userId?: StringFilter<"UserSkillProficiency"> | string
    skillId?: StringFilter<"UserSkillProficiency"> | string
    level?: EnumSkillLevelFilter<"UserSkillProficiency"> | $Enums.SkillLevel
    yearsExperience?: IntNullableFilter<"UserSkillProficiency"> | number | null
    lastUsed?: DateTimeNullableFilter<"UserSkillProficiency"> | Date | string | null
    isVerified?: BoolFilter<"UserSkillProficiency"> | boolean
    verificationSource?: StringNullableFilter<"UserSkillProficiency"> | string | null
    createdAt?: DateTimeFilter<"UserSkillProficiency"> | Date | string
    updatedAt?: DateTimeFilter<"UserSkillProficiency"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    skill?: XOR<SkillScalarRelationFilter, SkillWhereInput>
  }

  export type UserSkillProficiencyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    yearsExperience?: SortOrderInput | SortOrder
    lastUsed?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    verificationSource?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    skill?: SkillOrderByWithRelationInput
  }

  export type UserSkillProficiencyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_skillId?: UserSkillProficiencyUserIdSkillIdCompoundUniqueInput
    AND?: UserSkillProficiencyWhereInput | UserSkillProficiencyWhereInput[]
    OR?: UserSkillProficiencyWhereInput[]
    NOT?: UserSkillProficiencyWhereInput | UserSkillProficiencyWhereInput[]
    userId?: StringFilter<"UserSkillProficiency"> | string
    skillId?: StringFilter<"UserSkillProficiency"> | string
    level?: EnumSkillLevelFilter<"UserSkillProficiency"> | $Enums.SkillLevel
    yearsExperience?: IntNullableFilter<"UserSkillProficiency"> | number | null
    lastUsed?: DateTimeNullableFilter<"UserSkillProficiency"> | Date | string | null
    isVerified?: BoolFilter<"UserSkillProficiency"> | boolean
    verificationSource?: StringNullableFilter<"UserSkillProficiency"> | string | null
    createdAt?: DateTimeFilter<"UserSkillProficiency"> | Date | string
    updatedAt?: DateTimeFilter<"UserSkillProficiency"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    skill?: XOR<SkillScalarRelationFilter, SkillWhereInput>
  }, "id" | "userId_skillId">

  export type UserSkillProficiencyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    yearsExperience?: SortOrderInput | SortOrder
    lastUsed?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    verificationSource?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserSkillProficiencyCountOrderByAggregateInput
    _avg?: UserSkillProficiencyAvgOrderByAggregateInput
    _max?: UserSkillProficiencyMaxOrderByAggregateInput
    _min?: UserSkillProficiencyMinOrderByAggregateInput
    _sum?: UserSkillProficiencySumOrderByAggregateInput
  }

  export type UserSkillProficiencyScalarWhereWithAggregatesInput = {
    AND?: UserSkillProficiencyScalarWhereWithAggregatesInput | UserSkillProficiencyScalarWhereWithAggregatesInput[]
    OR?: UserSkillProficiencyScalarWhereWithAggregatesInput[]
    NOT?: UserSkillProficiencyScalarWhereWithAggregatesInput | UserSkillProficiencyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSkillProficiency"> | string
    userId?: StringWithAggregatesFilter<"UserSkillProficiency"> | string
    skillId?: StringWithAggregatesFilter<"UserSkillProficiency"> | string
    level?: EnumSkillLevelWithAggregatesFilter<"UserSkillProficiency"> | $Enums.SkillLevel
    yearsExperience?: IntNullableWithAggregatesFilter<"UserSkillProficiency"> | number | null
    lastUsed?: DateTimeNullableWithAggregatesFilter<"UserSkillProficiency"> | Date | string | null
    isVerified?: BoolWithAggregatesFilter<"UserSkillProficiency"> | boolean
    verificationSource?: StringNullableWithAggregatesFilter<"UserSkillProficiency"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserSkillProficiency"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSkillProficiency"> | Date | string
  }

  export type SkillPrerequisiteWhereInput = {
    AND?: SkillPrerequisiteWhereInput | SkillPrerequisiteWhereInput[]
    OR?: SkillPrerequisiteWhereInput[]
    NOT?: SkillPrerequisiteWhereInput | SkillPrerequisiteWhereInput[]
    id?: StringFilter<"SkillPrerequisite"> | string
    skillId?: StringFilter<"SkillPrerequisite"> | string
    prerequisiteSkillId?: StringFilter<"SkillPrerequisite"> | string
    isRequired?: BoolFilter<"SkillPrerequisite"> | boolean
    minimumLevel?: EnumSkillLevelFilter<"SkillPrerequisite"> | $Enums.SkillLevel
    skill?: XOR<SkillScalarRelationFilter, SkillWhereInput>
    prerequisiteSkill?: XOR<SkillScalarRelationFilter, SkillWhereInput>
  }

  export type SkillPrerequisiteOrderByWithRelationInput = {
    id?: SortOrder
    skillId?: SortOrder
    prerequisiteSkillId?: SortOrder
    isRequired?: SortOrder
    minimumLevel?: SortOrder
    skill?: SkillOrderByWithRelationInput
    prerequisiteSkill?: SkillOrderByWithRelationInput
  }

  export type SkillPrerequisiteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    skillId_prerequisiteSkillId?: SkillPrerequisiteSkillIdPrerequisiteSkillIdCompoundUniqueInput
    AND?: SkillPrerequisiteWhereInput | SkillPrerequisiteWhereInput[]
    OR?: SkillPrerequisiteWhereInput[]
    NOT?: SkillPrerequisiteWhereInput | SkillPrerequisiteWhereInput[]
    skillId?: StringFilter<"SkillPrerequisite"> | string
    prerequisiteSkillId?: StringFilter<"SkillPrerequisite"> | string
    isRequired?: BoolFilter<"SkillPrerequisite"> | boolean
    minimumLevel?: EnumSkillLevelFilter<"SkillPrerequisite"> | $Enums.SkillLevel
    skill?: XOR<SkillScalarRelationFilter, SkillWhereInput>
    prerequisiteSkill?: XOR<SkillScalarRelationFilter, SkillWhereInput>
  }, "id" | "skillId_prerequisiteSkillId">

  export type SkillPrerequisiteOrderByWithAggregationInput = {
    id?: SortOrder
    skillId?: SortOrder
    prerequisiteSkillId?: SortOrder
    isRequired?: SortOrder
    minimumLevel?: SortOrder
    _count?: SkillPrerequisiteCountOrderByAggregateInput
    _max?: SkillPrerequisiteMaxOrderByAggregateInput
    _min?: SkillPrerequisiteMinOrderByAggregateInput
  }

  export type SkillPrerequisiteScalarWhereWithAggregatesInput = {
    AND?: SkillPrerequisiteScalarWhereWithAggregatesInput | SkillPrerequisiteScalarWhereWithAggregatesInput[]
    OR?: SkillPrerequisiteScalarWhereWithAggregatesInput[]
    NOT?: SkillPrerequisiteScalarWhereWithAggregatesInput | SkillPrerequisiteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SkillPrerequisite"> | string
    skillId?: StringWithAggregatesFilter<"SkillPrerequisite"> | string
    prerequisiteSkillId?: StringWithAggregatesFilter<"SkillPrerequisite"> | string
    isRequired?: BoolWithAggregatesFilter<"SkillPrerequisite"> | boolean
    minimumLevel?: EnumSkillLevelWithAggregatesFilter<"SkillPrerequisite"> | $Enums.SkillLevel
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    icon?: StringNullableFilter<"Category"> | string | null
    color?: StringNullableFilter<"Category"> | string | null
    parentId?: StringNullableFilter<"Category"> | string | null
    sortOrder?: IntFilter<"Category"> | number
    isActive?: BoolFilter<"Category"> | boolean
    parent?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    children?: CategoryListRelationFilter
    courses?: CourseCategoryListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    parent?: CategoryOrderByWithRelationInput
    children?: CategoryOrderByRelationAggregateInput
    courses?: CourseCategoryOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    description?: StringNullableFilter<"Category"> | string | null
    icon?: StringNullableFilter<"Category"> | string | null
    color?: StringNullableFilter<"Category"> | string | null
    parentId?: StringNullableFilter<"Category"> | string | null
    sortOrder?: IntFilter<"Category"> | number
    isActive?: BoolFilter<"Category"> | boolean
    parent?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    children?: CategoryListRelationFilter
    courses?: CourseCategoryListRelationFilter
  }, "id" | "name" | "slug">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    slug?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Category"> | string | null
    color?: StringNullableWithAggregatesFilter<"Category"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"Category"> | string | null
    sortOrder?: IntWithAggregatesFilter<"Category"> | number
    isActive?: BoolWithAggregatesFilter<"Category"> | boolean
  }

  export type CourseCategoryWhereInput = {
    AND?: CourseCategoryWhereInput | CourseCategoryWhereInput[]
    OR?: CourseCategoryWhereInput[]
    NOT?: CourseCategoryWhereInput | CourseCategoryWhereInput[]
    id?: StringFilter<"CourseCategory"> | string
    courseId?: StringFilter<"CourseCategory"> | string
    categoryId?: StringFilter<"CourseCategory"> | string
    isPrimary?: BoolFilter<"CourseCategory"> | boolean
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }

  export type CourseCategoryOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    categoryId?: SortOrder
    isPrimary?: SortOrder
    course?: CourseOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
  }

  export type CourseCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    courseId_categoryId?: CourseCategoryCourseIdCategoryIdCompoundUniqueInput
    AND?: CourseCategoryWhereInput | CourseCategoryWhereInput[]
    OR?: CourseCategoryWhereInput[]
    NOT?: CourseCategoryWhereInput | CourseCategoryWhereInput[]
    courseId?: StringFilter<"CourseCategory"> | string
    categoryId?: StringFilter<"CourseCategory"> | string
    isPrimary?: BoolFilter<"CourseCategory"> | boolean
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }, "id" | "courseId_categoryId">

  export type CourseCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    categoryId?: SortOrder
    isPrimary?: SortOrder
    _count?: CourseCategoryCountOrderByAggregateInput
    _max?: CourseCategoryMaxOrderByAggregateInput
    _min?: CourseCategoryMinOrderByAggregateInput
  }

  export type CourseCategoryScalarWhereWithAggregatesInput = {
    AND?: CourseCategoryScalarWhereWithAggregatesInput | CourseCategoryScalarWhereWithAggregatesInput[]
    OR?: CourseCategoryScalarWhereWithAggregatesInput[]
    NOT?: CourseCategoryScalarWhereWithAggregatesInput | CourseCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CourseCategory"> | string
    courseId?: StringWithAggregatesFilter<"CourseCategory"> | string
    categoryId?: StringWithAggregatesFilter<"CourseCategory"> | string
    isPrimary?: BoolWithAggregatesFilter<"CourseCategory"> | boolean
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    color?: StringNullableFilter<"Tag"> | string | null
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    courses?: CourseTagListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    courses?: CourseTagOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    color?: StringNullableFilter<"Tag"> | string | null
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    courses?: CourseTagListRelationFilter
  }, "id" | "name">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
    color?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
  }

  export type CourseTagWhereInput = {
    AND?: CourseTagWhereInput | CourseTagWhereInput[]
    OR?: CourseTagWhereInput[]
    NOT?: CourseTagWhereInput | CourseTagWhereInput[]
    id?: StringFilter<"CourseTag"> | string
    courseId?: StringFilter<"CourseTag"> | string
    tagId?: StringFilter<"CourseTag"> | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type CourseTagOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    tagId?: SortOrder
    course?: CourseOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type CourseTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    courseId_tagId?: CourseTagCourseIdTagIdCompoundUniqueInput
    AND?: CourseTagWhereInput | CourseTagWhereInput[]
    OR?: CourseTagWhereInput[]
    NOT?: CourseTagWhereInput | CourseTagWhereInput[]
    courseId?: StringFilter<"CourseTag"> | string
    tagId?: StringFilter<"CourseTag"> | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "id" | "courseId_tagId">

  export type CourseTagOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    tagId?: SortOrder
    _count?: CourseTagCountOrderByAggregateInput
    _max?: CourseTagMaxOrderByAggregateInput
    _min?: CourseTagMinOrderByAggregateInput
  }

  export type CourseTagScalarWhereWithAggregatesInput = {
    AND?: CourseTagScalarWhereWithAggregatesInput | CourseTagScalarWhereWithAggregatesInput[]
    OR?: CourseTagScalarWhereWithAggregatesInput[]
    NOT?: CourseTagScalarWhereWithAggregatesInput | CourseTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CourseTag"> | string
    courseId?: StringWithAggregatesFilter<"CourseTag"> | string
    tagId?: StringWithAggregatesFilter<"CourseTag"> | string
  }

  export type CourseModuleWhereInput = {
    AND?: CourseModuleWhereInput | CourseModuleWhereInput[]
    OR?: CourseModuleWhereInput[]
    NOT?: CourseModuleWhereInput | CourseModuleWhereInput[]
    id?: StringFilter<"CourseModule"> | string
    courseId?: StringFilter<"CourseModule"> | string
    title?: StringFilter<"CourseModule"> | string
    description?: StringNullableFilter<"CourseModule"> | string | null
    sortOrder?: IntFilter<"CourseModule"> | number
    duration?: StringNullableFilter<"CourseModule"> | string | null
    isOptional?: BoolFilter<"CourseModule"> | boolean
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }

  export type CourseModuleOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    duration?: SortOrderInput | SortOrder
    isOptional?: SortOrder
    course?: CourseOrderByWithRelationInput
  }

  export type CourseModuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CourseModuleWhereInput | CourseModuleWhereInput[]
    OR?: CourseModuleWhereInput[]
    NOT?: CourseModuleWhereInput | CourseModuleWhereInput[]
    courseId?: StringFilter<"CourseModule"> | string
    title?: StringFilter<"CourseModule"> | string
    description?: StringNullableFilter<"CourseModule"> | string | null
    sortOrder?: IntFilter<"CourseModule"> | number
    duration?: StringNullableFilter<"CourseModule"> | string | null
    isOptional?: BoolFilter<"CourseModule"> | boolean
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }, "id">

  export type CourseModuleOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    duration?: SortOrderInput | SortOrder
    isOptional?: SortOrder
    _count?: CourseModuleCountOrderByAggregateInput
    _avg?: CourseModuleAvgOrderByAggregateInput
    _max?: CourseModuleMaxOrderByAggregateInput
    _min?: CourseModuleMinOrderByAggregateInput
    _sum?: CourseModuleSumOrderByAggregateInput
  }

  export type CourseModuleScalarWhereWithAggregatesInput = {
    AND?: CourseModuleScalarWhereWithAggregatesInput | CourseModuleScalarWhereWithAggregatesInput[]
    OR?: CourseModuleScalarWhereWithAggregatesInput[]
    NOT?: CourseModuleScalarWhereWithAggregatesInput | CourseModuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CourseModule"> | string
    courseId?: StringWithAggregatesFilter<"CourseModule"> | string
    title?: StringWithAggregatesFilter<"CourseModule"> | string
    description?: StringNullableWithAggregatesFilter<"CourseModule"> | string | null
    sortOrder?: IntWithAggregatesFilter<"CourseModule"> | number
    duration?: StringNullableWithAggregatesFilter<"CourseModule"> | string | null
    isOptional?: BoolWithAggregatesFilter<"CourseModule"> | boolean
  }

  export type AchievementWhereInput = {
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    id?: StringFilter<"Achievement"> | string
    name?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    icon?: StringNullableFilter<"Achievement"> | string | null
    type?: EnumAchievementTypeFilter<"Achievement"> | $Enums.AchievementType
    criteria?: JsonFilter<"Achievement">
    points?: IntFilter<"Achievement"> | number
    isActive?: BoolFilter<"Achievement"> | boolean
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    users?: UserAchievementListRelationFilter
  }

  export type AchievementOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrderInput | SortOrder
    type?: SortOrder
    criteria?: SortOrder
    points?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    users?: UserAchievementOrderByRelationAggregateInput
  }

  export type AchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    description?: StringFilter<"Achievement"> | string
    icon?: StringNullableFilter<"Achievement"> | string | null
    type?: EnumAchievementTypeFilter<"Achievement"> | $Enums.AchievementType
    criteria?: JsonFilter<"Achievement">
    points?: IntFilter<"Achievement"> | number
    isActive?: BoolFilter<"Achievement"> | boolean
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    users?: UserAchievementListRelationFilter
  }, "id" | "name">

  export type AchievementOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrderInput | SortOrder
    type?: SortOrder
    criteria?: SortOrder
    points?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: AchievementCountOrderByAggregateInput
    _avg?: AchievementAvgOrderByAggregateInput
    _max?: AchievementMaxOrderByAggregateInput
    _min?: AchievementMinOrderByAggregateInput
    _sum?: AchievementSumOrderByAggregateInput
  }

  export type AchievementScalarWhereWithAggregatesInput = {
    AND?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    OR?: AchievementScalarWhereWithAggregatesInput[]
    NOT?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Achievement"> | string
    name?: StringWithAggregatesFilter<"Achievement"> | string
    description?: StringWithAggregatesFilter<"Achievement"> | string
    icon?: StringNullableWithAggregatesFilter<"Achievement"> | string | null
    type?: EnumAchievementTypeWithAggregatesFilter<"Achievement"> | $Enums.AchievementType
    criteria?: JsonWithAggregatesFilter<"Achievement">
    points?: IntWithAggregatesFilter<"Achievement"> | number
    isActive?: BoolWithAggregatesFilter<"Achievement"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Achievement"> | Date | string
  }

  export type UserAchievementWhereInput = {
    AND?: UserAchievementWhereInput | UserAchievementWhereInput[]
    OR?: UserAchievementWhereInput[]
    NOT?: UserAchievementWhereInput | UserAchievementWhereInput[]
    id?: StringFilter<"UserAchievement"> | string
    userId?: StringFilter<"UserAchievement"> | string
    achievementId?: StringFilter<"UserAchievement"> | string
    earnedAt?: DateTimeFilter<"UserAchievement"> | Date | string
    progress?: JsonNullableFilter<"UserAchievement">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    achievement?: XOR<AchievementScalarRelationFilter, AchievementWhereInput>
  }

  export type UserAchievementOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    earnedAt?: SortOrder
    progress?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    achievement?: AchievementOrderByWithRelationInput
  }

  export type UserAchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_achievementId?: UserAchievementUserIdAchievementIdCompoundUniqueInput
    AND?: UserAchievementWhereInput | UserAchievementWhereInput[]
    OR?: UserAchievementWhereInput[]
    NOT?: UserAchievementWhereInput | UserAchievementWhereInput[]
    userId?: StringFilter<"UserAchievement"> | string
    achievementId?: StringFilter<"UserAchievement"> | string
    earnedAt?: DateTimeFilter<"UserAchievement"> | Date | string
    progress?: JsonNullableFilter<"UserAchievement">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    achievement?: XOR<AchievementScalarRelationFilter, AchievementWhereInput>
  }, "id" | "userId_achievementId">

  export type UserAchievementOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    earnedAt?: SortOrder
    progress?: SortOrderInput | SortOrder
    _count?: UserAchievementCountOrderByAggregateInput
    _max?: UserAchievementMaxOrderByAggregateInput
    _min?: UserAchievementMinOrderByAggregateInput
  }

  export type UserAchievementScalarWhereWithAggregatesInput = {
    AND?: UserAchievementScalarWhereWithAggregatesInput | UserAchievementScalarWhereWithAggregatesInput[]
    OR?: UserAchievementScalarWhereWithAggregatesInput[]
    NOT?: UserAchievementScalarWhereWithAggregatesInput | UserAchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserAchievement"> | string
    userId?: StringWithAggregatesFilter<"UserAchievement"> | string
    achievementId?: StringWithAggregatesFilter<"UserAchievement"> | string
    earnedAt?: DateTimeWithAggregatesFilter<"UserAchievement"> | Date | string
    progress?: JsonNullableWithAggregatesFilter<"UserAchievement">
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    data?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    data?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    data?: JsonNullableWithAggregatesFilter<"Notification">
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
  }

  export type ProgressReportWhereInput = {
    AND?: ProgressReportWhereInput | ProgressReportWhereInput[]
    OR?: ProgressReportWhereInput[]
    NOT?: ProgressReportWhereInput | ProgressReportWhereInput[]
    id?: StringFilter<"ProgressReport"> | string
    userId?: StringFilter<"ProgressReport"> | string
    reportDate?: DateTimeFilter<"ProgressReport"> | Date | string
    coursesCompleted?: IntFilter<"ProgressReport"> | number
    reviewsWritten?: IntFilter<"ProgressReport"> | number
    pointsEarned?: IntFilter<"ProgressReport"> | number
    skillsLearned?: StringNullableListFilter<"ProgressReport">
    weeklyGoalMet?: BoolFilter<"ProgressReport"> | boolean
    monthlyGoalMet?: BoolFilter<"ProgressReport"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ProgressReportOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    reportDate?: SortOrder
    coursesCompleted?: SortOrder
    reviewsWritten?: SortOrder
    pointsEarned?: SortOrder
    skillsLearned?: SortOrder
    weeklyGoalMet?: SortOrder
    monthlyGoalMet?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ProgressReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProgressReportWhereInput | ProgressReportWhereInput[]
    OR?: ProgressReportWhereInput[]
    NOT?: ProgressReportWhereInput | ProgressReportWhereInput[]
    userId?: StringFilter<"ProgressReport"> | string
    reportDate?: DateTimeFilter<"ProgressReport"> | Date | string
    coursesCompleted?: IntFilter<"ProgressReport"> | number
    reviewsWritten?: IntFilter<"ProgressReport"> | number
    pointsEarned?: IntFilter<"ProgressReport"> | number
    skillsLearned?: StringNullableListFilter<"ProgressReport">
    weeklyGoalMet?: BoolFilter<"ProgressReport"> | boolean
    monthlyGoalMet?: BoolFilter<"ProgressReport"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ProgressReportOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    reportDate?: SortOrder
    coursesCompleted?: SortOrder
    reviewsWritten?: SortOrder
    pointsEarned?: SortOrder
    skillsLearned?: SortOrder
    weeklyGoalMet?: SortOrder
    monthlyGoalMet?: SortOrder
    _count?: ProgressReportCountOrderByAggregateInput
    _avg?: ProgressReportAvgOrderByAggregateInput
    _max?: ProgressReportMaxOrderByAggregateInput
    _min?: ProgressReportMinOrderByAggregateInput
    _sum?: ProgressReportSumOrderByAggregateInput
  }

  export type ProgressReportScalarWhereWithAggregatesInput = {
    AND?: ProgressReportScalarWhereWithAggregatesInput | ProgressReportScalarWhereWithAggregatesInput[]
    OR?: ProgressReportScalarWhereWithAggregatesInput[]
    NOT?: ProgressReportScalarWhereWithAggregatesInput | ProgressReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProgressReport"> | string
    userId?: StringWithAggregatesFilter<"ProgressReport"> | string
    reportDate?: DateTimeWithAggregatesFilter<"ProgressReport"> | Date | string
    coursesCompleted?: IntWithAggregatesFilter<"ProgressReport"> | number
    reviewsWritten?: IntWithAggregatesFilter<"ProgressReport"> | number
    pointsEarned?: IntWithAggregatesFilter<"ProgressReport"> | number
    skillsLearned?: StringNullableListFilter<"ProgressReport">
    weeklyGoalMet?: BoolWithAggregatesFilter<"ProgressReport"> | boolean
    monthlyGoalMet?: BoolWithAggregatesFilter<"ProgressReport"> | boolean
  }

  export type UserCreateInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    profileImage?: string | null
    bio?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationToken?: string | null
    passwordHash: string
    totalPoints?: number
    reviewStreak?: number
    lastActiveAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    enrollments?: CourseEnrollmentCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutCreatedByInput
    skillProficiencies?: UserSkillProficiencyCreateNestedManyWithoutUserInput
    reviewHelpfulVotes?: ReviewHelpfulVoteCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    profileImage?: string | null
    bio?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationToken?: string | null
    passwordHash: string
    totalPoints?: number
    reviewStreak?: number
    lastActiveAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatedByInput
    skillProficiencies?: UserSkillProficiencyUncheckedCreateNestedManyWithoutUserInput
    reviewHelpfulVotes?: ReviewHelpfulVoteUncheckedCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    reviewStreak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    enrollments?: CourseEnrollmentUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutCreatedByNestedInput
    skillProficiencies?: UserSkillProficiencyUpdateManyWithoutUserNestedInput
    reviewHelpfulVotes?: ReviewHelpfulVoteUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    reviewStreak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatedByNestedInput
    skillProficiencies?: UserSkillProficiencyUncheckedUpdateManyWithoutUserNestedInput
    reviewHelpfulVotes?: ReviewHelpfulVoteUncheckedUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    profileImage?: string | null
    bio?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationToken?: string | null
    passwordHash: string
    totalPoints?: number
    reviewStreak?: number
    lastActiveAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    reviewStreak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    reviewStreak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseCreateInput = {
    id?: string
    title: string
    description: string
    shortDescription?: string | null
    imageUrl?: string | null
    thumbnailUrl?: string | null
    courseUrl: string
    instructor: string
    institution?: string | null
    duration?: string | null
    difficulty: $Enums.Difficulty
    status?: $Enums.CourseStatus
    price?: Decimal | DecimalJsLike | number | string | null
    isFree?: boolean
    language?: string
    rating?: Decimal | DecimalJsLike | number | string | null
    reviewCount?: number
    enrollmentCount?: number
    isActive?: boolean
    prerequisites?: CourseCreateprerequisitesInput | string[]
    learningOutcomes?: CourseCreatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCoursesInput
    reviews?: ReviewCreateNestedManyWithoutCourseInput
    skills?: CourseSkillCreateNestedManyWithoutCourseInput
    enrollments?: CourseEnrollmentCreateNestedManyWithoutCourseInput
    categories?: CourseCategoryCreateNestedManyWithoutCourseInput
    tags?: CourseTagCreateNestedManyWithoutCourseInput
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    shortDescription?: string | null
    imageUrl?: string | null
    thumbnailUrl?: string | null
    courseUrl: string
    instructor: string
    institution?: string | null
    duration?: string | null
    difficulty: $Enums.Difficulty
    status?: $Enums.CourseStatus
    price?: Decimal | DecimalJsLike | number | string | null
    isFree?: boolean
    language?: string
    rating?: Decimal | DecimalJsLike | number | string | null
    reviewCount?: number
    enrollmentCount?: number
    isActive?: boolean
    prerequisites?: CourseCreateprerequisitesInput | string[]
    learningOutcomes?: CourseCreatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    reviews?: ReviewUncheckedCreateNestedManyWithoutCourseInput
    skills?: CourseSkillUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutCourseInput
    categories?: CourseCategoryUncheckedCreateNestedManyWithoutCourseInput
    tags?: CourseTagUncheckedCreateNestedManyWithoutCourseInput
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    courseUrl?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    enrollmentCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    prerequisites?: CourseUpdateprerequisitesInput | string[]
    learningOutcomes?: CourseUpdatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCoursesNestedInput
    reviews?: ReviewUpdateManyWithoutCourseNestedInput
    skills?: CourseSkillUpdateManyWithoutCourseNestedInput
    enrollments?: CourseEnrollmentUpdateManyWithoutCourseNestedInput
    categories?: CourseCategoryUpdateManyWithoutCourseNestedInput
    tags?: CourseTagUpdateManyWithoutCourseNestedInput
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    courseUrl?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    enrollmentCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    prerequisites?: CourseUpdateprerequisitesInput | string[]
    learningOutcomes?: CourseUpdatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    reviews?: ReviewUncheckedUpdateManyWithoutCourseNestedInput
    skills?: CourseSkillUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    categories?: CourseCategoryUncheckedUpdateManyWithoutCourseNestedInput
    tags?: CourseTagUncheckedUpdateManyWithoutCourseNestedInput
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateManyInput = {
    id?: string
    title: string
    description: string
    shortDescription?: string | null
    imageUrl?: string | null
    thumbnailUrl?: string | null
    courseUrl: string
    instructor: string
    institution?: string | null
    duration?: string | null
    difficulty: $Enums.Difficulty
    status?: $Enums.CourseStatus
    price?: Decimal | DecimalJsLike | number | string | null
    isFree?: boolean
    language?: string
    rating?: Decimal | DecimalJsLike | number | string | null
    reviewCount?: number
    enrollmentCount?: number
    isActive?: boolean
    prerequisites?: CourseCreateprerequisitesInput | string[]
    learningOutcomes?: CourseCreatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type CourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    courseUrl?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    enrollmentCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    prerequisites?: CourseUpdateprerequisitesInput | string[]
    learningOutcomes?: CourseUpdatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    courseUrl?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    enrollmentCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    prerequisites?: CourseUpdateprerequisitesInput | string[]
    learningOutcomes?: CourseUpdatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type SkillCreateInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseSkillCreateNestedManyWithoutSkillInput
    userProficiencies?: UserSkillProficiencyCreateNestedManyWithoutSkillInput
    prerequisiteFor?: SkillPrerequisiteCreateNestedManyWithoutPrerequisiteSkillInput
    prerequisites?: SkillPrerequisiteCreateNestedManyWithoutSkillInput
    reviewRatings?: ReviewSkillRatingCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseSkillUncheckedCreateNestedManyWithoutSkillInput
    userProficiencies?: UserSkillProficiencyUncheckedCreateNestedManyWithoutSkillInput
    prerequisiteFor?: SkillPrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteSkillInput
    prerequisites?: SkillPrerequisiteUncheckedCreateNestedManyWithoutSkillInput
    reviewRatings?: ReviewSkillRatingUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseSkillUpdateManyWithoutSkillNestedInput
    userProficiencies?: UserSkillProficiencyUpdateManyWithoutSkillNestedInput
    prerequisiteFor?: SkillPrerequisiteUpdateManyWithoutPrerequisiteSkillNestedInput
    prerequisites?: SkillPrerequisiteUpdateManyWithoutSkillNestedInput
    reviewRatings?: ReviewSkillRatingUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseSkillUncheckedUpdateManyWithoutSkillNestedInput
    userProficiencies?: UserSkillProficiencyUncheckedUpdateManyWithoutSkillNestedInput
    prerequisiteFor?: SkillPrerequisiteUncheckedUpdateManyWithoutPrerequisiteSkillNestedInput
    prerequisites?: SkillPrerequisiteUncheckedUpdateManyWithoutSkillNestedInput
    reviewRatings?: ReviewSkillRatingUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type SkillCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseSkillCreateInput = {
    id?: string
    level?: $Enums.SkillLevel
    isCore?: boolean
    percentage?: number | null
    createdAt?: Date | string
    course: CourseCreateNestedOneWithoutSkillsInput
    skill: SkillCreateNestedOneWithoutCoursesInput
  }

  export type CourseSkillUncheckedCreateInput = {
    id?: string
    courseId: string
    skillId: string
    level?: $Enums.SkillLevel
    isCore?: boolean
    percentage?: number | null
    createdAt?: Date | string
  }

  export type CourseSkillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    isCore?: BoolFieldUpdateOperationsInput | boolean
    percentage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutSkillsNestedInput
    skill?: SkillUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseSkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    isCore?: BoolFieldUpdateOperationsInput | boolean
    percentage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseSkillCreateManyInput = {
    id?: string
    courseId: string
    skillId: string
    level?: $Enums.SkillLevel
    isCore?: boolean
    percentage?: number | null
    createdAt?: Date | string
  }

  export type CourseSkillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    isCore?: BoolFieldUpdateOperationsInput | boolean
    percentage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseSkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    isCore?: BoolFieldUpdateOperationsInput | boolean
    percentage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateInput = {
    id?: string
    overallRating: number
    difficultyRating?: number | null
    contentQuality?: number | null
    instructorRating?: number | null
    valueForMoney?: number | null
    wouldRecommend?: boolean | null
    title: string
    content: string
    pros?: ReviewCreateprosInput | string[]
    cons?: ReviewCreateconsInput | string[]
    isAnonymous?: boolean
    isVerified?: boolean
    helpfulCount?: number
    flagCount?: number
    isHidden?: boolean
    moderatorNotes?: string | null
    completionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
    course: CourseCreateNestedOneWithoutReviewsInput
    votes?: ReviewVoteCreateNestedManyWithoutReviewInput
    helpfulVotes?: ReviewHelpfulVoteCreateNestedManyWithoutReviewInput
    skillRatings?: ReviewSkillRatingCreateNestedManyWithoutReviewInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    userId: string
    courseId: string
    overallRating: number
    difficultyRating?: number | null
    contentQuality?: number | null
    instructorRating?: number | null
    valueForMoney?: number | null
    wouldRecommend?: boolean | null
    title: string
    content: string
    pros?: ReviewCreateprosInput | string[]
    cons?: ReviewCreateconsInput | string[]
    isAnonymous?: boolean
    isVerified?: boolean
    helpfulCount?: number
    flagCount?: number
    isHidden?: boolean
    moderatorNotes?: string | null
    completionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: ReviewVoteUncheckedCreateNestedManyWithoutReviewInput
    helpfulVotes?: ReviewHelpfulVoteUncheckedCreateNestedManyWithoutReviewInput
    skillRatings?: ReviewSkillRatingUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    difficultyRating?: NullableIntFieldUpdateOperationsInput | number | null
    contentQuality?: NullableIntFieldUpdateOperationsInput | number | null
    instructorRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueForMoney?: NullableIntFieldUpdateOperationsInput | number | null
    wouldRecommend?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    pros?: ReviewUpdateprosInput | string[]
    cons?: ReviewUpdateconsInput | string[]
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    flagCount?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    moderatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    course?: CourseUpdateOneRequiredWithoutReviewsNestedInput
    votes?: ReviewVoteUpdateManyWithoutReviewNestedInput
    helpfulVotes?: ReviewHelpfulVoteUpdateManyWithoutReviewNestedInput
    skillRatings?: ReviewSkillRatingUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    difficultyRating?: NullableIntFieldUpdateOperationsInput | number | null
    contentQuality?: NullableIntFieldUpdateOperationsInput | number | null
    instructorRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueForMoney?: NullableIntFieldUpdateOperationsInput | number | null
    wouldRecommend?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    pros?: ReviewUpdateprosInput | string[]
    cons?: ReviewUpdateconsInput | string[]
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    flagCount?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    moderatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: ReviewVoteUncheckedUpdateManyWithoutReviewNestedInput
    helpfulVotes?: ReviewHelpfulVoteUncheckedUpdateManyWithoutReviewNestedInput
    skillRatings?: ReviewSkillRatingUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewCreateManyInput = {
    id?: string
    userId: string
    courseId: string
    overallRating: number
    difficultyRating?: number | null
    contentQuality?: number | null
    instructorRating?: number | null
    valueForMoney?: number | null
    wouldRecommend?: boolean | null
    title: string
    content: string
    pros?: ReviewCreateprosInput | string[]
    cons?: ReviewCreateconsInput | string[]
    isAnonymous?: boolean
    isVerified?: boolean
    helpfulCount?: number
    flagCount?: number
    isHidden?: boolean
    moderatorNotes?: string | null
    completionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    difficultyRating?: NullableIntFieldUpdateOperationsInput | number | null
    contentQuality?: NullableIntFieldUpdateOperationsInput | number | null
    instructorRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueForMoney?: NullableIntFieldUpdateOperationsInput | number | null
    wouldRecommend?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    pros?: ReviewUpdateprosInput | string[]
    cons?: ReviewUpdateconsInput | string[]
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    flagCount?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    moderatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    difficultyRating?: NullableIntFieldUpdateOperationsInput | number | null
    contentQuality?: NullableIntFieldUpdateOperationsInput | number | null
    instructorRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueForMoney?: NullableIntFieldUpdateOperationsInput | number | null
    wouldRecommend?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    pros?: ReviewUpdateprosInput | string[]
    cons?: ReviewUpdateconsInput | string[]
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    flagCount?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    moderatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewVoteCreateInput = {
    id?: string
    isUpvote: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutReviewVotesInput
    review: ReviewCreateNestedOneWithoutVotesInput
  }

  export type ReviewVoteUncheckedCreateInput = {
    id?: string
    userId: string
    reviewId: string
    isUpvote: boolean
    createdAt?: Date | string
  }

  export type ReviewVoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUpvote?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewVotesNestedInput
    review?: ReviewUpdateOneRequiredWithoutVotesNestedInput
  }

  export type ReviewVoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    isUpvote?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewVoteCreateManyInput = {
    id?: string
    userId: string
    reviewId: string
    isUpvote: boolean
    createdAt?: Date | string
  }

  export type ReviewVoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUpvote?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewVoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    isUpvote?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewHelpfulVoteCreateInput = {
    id?: string
    isHelpful: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutReviewHelpfulVotesInput
    review: ReviewCreateNestedOneWithoutHelpfulVotesInput
  }

  export type ReviewHelpfulVoteUncheckedCreateInput = {
    id?: string
    userId: string
    reviewId: string
    isHelpful: boolean
    createdAt?: Date | string
  }

  export type ReviewHelpfulVoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isHelpful?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewHelpfulVotesNestedInput
    review?: ReviewUpdateOneRequiredWithoutHelpfulVotesNestedInput
  }

  export type ReviewHelpfulVoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    isHelpful?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewHelpfulVoteCreateManyInput = {
    id?: string
    userId: string
    reviewId: string
    isHelpful: boolean
    createdAt?: Date | string
  }

  export type ReviewHelpfulVoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isHelpful?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewHelpfulVoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    isHelpful?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewSkillRatingCreateInput = {
    id?: string
    rating: number
    createdAt?: Date | string
    review: ReviewCreateNestedOneWithoutSkillRatingsInput
    skill: SkillCreateNestedOneWithoutReviewRatingsInput
  }

  export type ReviewSkillRatingUncheckedCreateInput = {
    id?: string
    reviewId: string
    skillId: string
    rating: number
    createdAt?: Date | string
  }

  export type ReviewSkillRatingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ReviewUpdateOneRequiredWithoutSkillRatingsNestedInput
    skill?: SkillUpdateOneRequiredWithoutReviewRatingsNestedInput
  }

  export type ReviewSkillRatingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewSkillRatingCreateManyInput = {
    id?: string
    reviewId: string
    skillId: string
    rating: number
    createdAt?: Date | string
  }

  export type ReviewSkillRatingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewSkillRatingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseEnrollmentCreateInput = {
    id?: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    progress?: number
    lastAccessed?: Date | string
    status?: string
    certificateUrl?: string | null
    user: UserCreateNestedOneWithoutEnrollmentsInput
    course: CourseCreateNestedOneWithoutEnrollmentsInput
  }

  export type CourseEnrollmentUncheckedCreateInput = {
    id?: string
    userId: string
    courseId: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    progress?: number
    lastAccessed?: Date | string
    status?: string
    certificateUrl?: string | null
  }

  export type CourseEnrollmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutEnrollmentsNestedInput
    course?: CourseUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type CourseEnrollmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourseEnrollmentCreateManyInput = {
    id?: string
    userId: string
    courseId: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    progress?: number
    lastAccessed?: Date | string
    status?: string
    certificateUrl?: string | null
  }

  export type CourseEnrollmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourseEnrollmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSkillProficiencyCreateInput = {
    id?: string
    level: $Enums.SkillLevel
    yearsExperience?: number | null
    lastUsed?: Date | string | null
    isVerified?: boolean
    verificationSource?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSkillProficienciesInput
    skill: SkillCreateNestedOneWithoutUserProficienciesInput
  }

  export type UserSkillProficiencyUncheckedCreateInput = {
    id?: string
    userId: string
    skillId: string
    level: $Enums.SkillLevel
    yearsExperience?: number | null
    lastUsed?: Date | string | null
    isVerified?: boolean
    verificationSource?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSkillProficiencyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    yearsExperience?: NullableIntFieldUpdateOperationsInput | number | null
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSkillProficienciesNestedInput
    skill?: SkillUpdateOneRequiredWithoutUserProficienciesNestedInput
  }

  export type UserSkillProficiencyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    yearsExperience?: NullableIntFieldUpdateOperationsInput | number | null
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSkillProficiencyCreateManyInput = {
    id?: string
    userId: string
    skillId: string
    level: $Enums.SkillLevel
    yearsExperience?: number | null
    lastUsed?: Date | string | null
    isVerified?: boolean
    verificationSource?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSkillProficiencyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    yearsExperience?: NullableIntFieldUpdateOperationsInput | number | null
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSkillProficiencyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    yearsExperience?: NullableIntFieldUpdateOperationsInput | number | null
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillPrerequisiteCreateInput = {
    id?: string
    isRequired?: boolean
    minimumLevel?: $Enums.SkillLevel
    skill: SkillCreateNestedOneWithoutPrerequisitesInput
    prerequisiteSkill: SkillCreateNestedOneWithoutPrerequisiteForInput
  }

  export type SkillPrerequisiteUncheckedCreateInput = {
    id?: string
    skillId: string
    prerequisiteSkillId: string
    isRequired?: boolean
    minimumLevel?: $Enums.SkillLevel
  }

  export type SkillPrerequisiteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    minimumLevel?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    skill?: SkillUpdateOneRequiredWithoutPrerequisitesNestedInput
    prerequisiteSkill?: SkillUpdateOneRequiredWithoutPrerequisiteForNestedInput
  }

  export type SkillPrerequisiteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    prerequisiteSkillId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    minimumLevel?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
  }

  export type SkillPrerequisiteCreateManyInput = {
    id?: string
    skillId: string
    prerequisiteSkillId: string
    isRequired?: boolean
    minimumLevel?: $Enums.SkillLevel
  }

  export type SkillPrerequisiteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    minimumLevel?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
  }

  export type SkillPrerequisiteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    prerequisiteSkillId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    minimumLevel?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    color?: string | null
    sortOrder?: number
    isActive?: boolean
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    courses?: CourseCategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    color?: string | null
    parentId?: string | null
    sortOrder?: number
    isActive?: boolean
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    courses?: CourseCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    courses?: CourseCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    courses?: CourseCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    color?: string | null
    parentId?: string | null
    sortOrder?: number
    isActive?: boolean
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseCategoryCreateInput = {
    id?: string
    isPrimary?: boolean
    course: CourseCreateNestedOneWithoutCategoriesInput
    category: CategoryCreateNestedOneWithoutCoursesInput
  }

  export type CourseCategoryUncheckedCreateInput = {
    id?: string
    courseId: string
    categoryId: string
    isPrimary?: boolean
  }

  export type CourseCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    course?: CourseUpdateOneRequiredWithoutCategoriesNestedInput
    category?: CategoryUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseCategoryCreateManyInput = {
    id?: string
    courseId: string
    categoryId: string
    isPrimary?: boolean
  }

  export type CourseCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TagCreateInput = {
    id?: string
    name: string
    color?: string | null
    createdAt?: Date | string
    courses?: CourseTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    color?: string | null
    createdAt?: Date | string
    courses?: CourseTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
    color?: string | null
    createdAt?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseTagCreateInput = {
    id?: string
    course: CourseCreateNestedOneWithoutTagsInput
    tag: TagCreateNestedOneWithoutCoursesInput
  }

  export type CourseTagUncheckedCreateInput = {
    id?: string
    courseId: string
    tagId: string
  }

  export type CourseTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    course?: CourseUpdateOneRequiredWithoutTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseTagCreateManyInput = {
    id?: string
    courseId: string
    tagId: string
  }

  export type CourseTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type CourseTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseModuleCreateInput = {
    id?: string
    title: string
    description?: string | null
    sortOrder: number
    duration?: string | null
    isOptional?: boolean
    course: CourseCreateNestedOneWithoutModulesInput
  }

  export type CourseModuleUncheckedCreateInput = {
    id?: string
    courseId: string
    title: string
    description?: string | null
    sortOrder: number
    duration?: string | null
    isOptional?: boolean
  }

  export type CourseModuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    isOptional?: BoolFieldUpdateOperationsInput | boolean
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
  }

  export type CourseModuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    isOptional?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseModuleCreateManyInput = {
    id?: string
    courseId: string
    title: string
    description?: string | null
    sortOrder: number
    duration?: string | null
    isOptional?: boolean
  }

  export type CourseModuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    isOptional?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseModuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    isOptional?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AchievementCreateInput = {
    id?: string
    name: string
    description: string
    icon?: string | null
    type: $Enums.AchievementType
    criteria: JsonNullValueInput | InputJsonValue
    points?: number
    isActive?: boolean
    createdAt?: Date | string
    users?: UserAchievementCreateNestedManyWithoutAchievementInput
  }

  export type AchievementUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    icon?: string | null
    type: $Enums.AchievementType
    criteria: JsonNullValueInput | InputJsonValue
    points?: number
    isActive?: boolean
    createdAt?: Date | string
    users?: UserAchievementUncheckedCreateNestedManyWithoutAchievementInput
  }

  export type AchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAchievementTypeFieldUpdateOperationsInput | $Enums.AchievementType
    criteria?: JsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserAchievementUpdateManyWithoutAchievementNestedInput
  }

  export type AchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAchievementTypeFieldUpdateOperationsInput | $Enums.AchievementType
    criteria?: JsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserAchievementUncheckedUpdateManyWithoutAchievementNestedInput
  }

  export type AchievementCreateManyInput = {
    id?: string
    name: string
    description: string
    icon?: string | null
    type: $Enums.AchievementType
    criteria: JsonNullValueInput | InputJsonValue
    points?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type AchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAchievementTypeFieldUpdateOperationsInput | $Enums.AchievementType
    criteria?: JsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAchievementTypeFieldUpdateOperationsInput | $Enums.AchievementType
    criteria?: JsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementCreateInput = {
    id?: string
    earnedAt?: Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutAchievementsInput
    achievement: AchievementCreateNestedOneWithoutUsersInput
  }

  export type UserAchievementUncheckedCreateInput = {
    id?: string
    userId: string
    achievementId: string
    earnedAt?: Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserAchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutAchievementsNestedInput
    achievement?: AchievementUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserAchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserAchievementCreateManyInput = {
    id?: string
    userId: string
    achievementId: string
    earnedAt?: Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserAchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserAchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message: string
    type: string
    isRead?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    message: string
    type: string
    isRead?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    title: string
    message: string
    type: string
    isRead?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProgressReportCreateInput = {
    id?: string
    reportDate?: Date | string
    coursesCompleted?: number
    reviewsWritten?: number
    pointsEarned?: number
    skillsLearned?: ProgressReportCreateskillsLearnedInput | string[]
    weeklyGoalMet?: boolean
    monthlyGoalMet?: boolean
    user: UserCreateNestedOneWithoutProgressReportsInput
  }

  export type ProgressReportUncheckedCreateInput = {
    id?: string
    userId: string
    reportDate?: Date | string
    coursesCompleted?: number
    reviewsWritten?: number
    pointsEarned?: number
    skillsLearned?: ProgressReportCreateskillsLearnedInput | string[]
    weeklyGoalMet?: boolean
    monthlyGoalMet?: boolean
  }

  export type ProgressReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coursesCompleted?: IntFieldUpdateOperationsInput | number
    reviewsWritten?: IntFieldUpdateOperationsInput | number
    pointsEarned?: IntFieldUpdateOperationsInput | number
    skillsLearned?: ProgressReportUpdateskillsLearnedInput | string[]
    weeklyGoalMet?: BoolFieldUpdateOperationsInput | boolean
    monthlyGoalMet?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutProgressReportsNestedInput
  }

  export type ProgressReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coursesCompleted?: IntFieldUpdateOperationsInput | number
    reviewsWritten?: IntFieldUpdateOperationsInput | number
    pointsEarned?: IntFieldUpdateOperationsInput | number
    skillsLearned?: ProgressReportUpdateskillsLearnedInput | string[]
    weeklyGoalMet?: BoolFieldUpdateOperationsInput | boolean
    monthlyGoalMet?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProgressReportCreateManyInput = {
    id?: string
    userId: string
    reportDate?: Date | string
    coursesCompleted?: number
    reviewsWritten?: number
    pointsEarned?: number
    skillsLearned?: ProgressReportCreateskillsLearnedInput | string[]
    weeklyGoalMet?: boolean
    monthlyGoalMet?: boolean
  }

  export type ProgressReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coursesCompleted?: IntFieldUpdateOperationsInput | number
    reviewsWritten?: IntFieldUpdateOperationsInput | number
    pointsEarned?: IntFieldUpdateOperationsInput | number
    skillsLearned?: ProgressReportUpdateskillsLearnedInput | string[]
    weeklyGoalMet?: BoolFieldUpdateOperationsInput | boolean
    monthlyGoalMet?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProgressReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coursesCompleted?: IntFieldUpdateOperationsInput | number
    reviewsWritten?: IntFieldUpdateOperationsInput | number
    pointsEarned?: IntFieldUpdateOperationsInput | number
    skillsLearned?: ProgressReportUpdateskillsLearnedInput | string[]
    weeklyGoalMet?: BoolFieldUpdateOperationsInput | boolean
    monthlyGoalMet?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type ReviewVoteListRelationFilter = {
    every?: ReviewVoteWhereInput
    some?: ReviewVoteWhereInput
    none?: ReviewVoteWhereInput
  }

  export type CourseEnrollmentListRelationFilter = {
    every?: CourseEnrollmentWhereInput
    some?: CourseEnrollmentWhereInput
    none?: CourseEnrollmentWhereInput
  }

  export type UserAchievementListRelationFilter = {
    every?: UserAchievementWhereInput
    some?: UserAchievementWhereInput
    none?: UserAchievementWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type CourseListRelationFilter = {
    every?: CourseWhereInput
    some?: CourseWhereInput
    none?: CourseWhereInput
  }

  export type UserSkillProficiencyListRelationFilter = {
    every?: UserSkillProficiencyWhereInput
    some?: UserSkillProficiencyWhereInput
    none?: UserSkillProficiencyWhereInput
  }

  export type ReviewHelpfulVoteListRelationFilter = {
    every?: ReviewHelpfulVoteWhereInput
    some?: ReviewHelpfulVoteWhereInput
    none?: ReviewHelpfulVoteWhereInput
  }

  export type ProgressReportListRelationFilter = {
    every?: ProgressReportWhereInput
    some?: ProgressReportWhereInput
    none?: ProgressReportWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewVoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseEnrollmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSkillProficiencyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewHelpfulVoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgressReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profileImage?: SortOrder
    bio?: SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    verificationToken?: SortOrder
    passwordHash?: SortOrder
    totalPoints?: SortOrder
    reviewStreak?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    totalPoints?: SortOrder
    reviewStreak?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profileImage?: SortOrder
    bio?: SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    verificationToken?: SortOrder
    passwordHash?: SortOrder
    totalPoints?: SortOrder
    reviewStreak?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profileImage?: SortOrder
    bio?: SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    verificationToken?: SortOrder
    passwordHash?: SortOrder
    totalPoints?: SortOrder
    reviewStreak?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    totalPoints?: SortOrder
    reviewStreak?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumDifficultyFilter<$PrismaModel = never> = {
    equals?: $Enums.Difficulty | EnumDifficultyFieldRefInput<$PrismaModel>
    in?: $Enums.Difficulty[] | ListEnumDifficultyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Difficulty[] | ListEnumDifficultyFieldRefInput<$PrismaModel>
    not?: NestedEnumDifficultyFilter<$PrismaModel> | $Enums.Difficulty
  }

  export type EnumCourseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseStatus | EnumCourseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseStatusFilter<$PrismaModel> | $Enums.CourseStatus
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CourseSkillListRelationFilter = {
    every?: CourseSkillWhereInput
    some?: CourseSkillWhereInput
    none?: CourseSkillWhereInput
  }

  export type CourseCategoryListRelationFilter = {
    every?: CourseCategoryWhereInput
    some?: CourseCategoryWhereInput
    none?: CourseCategoryWhereInput
  }

  export type CourseTagListRelationFilter = {
    every?: CourseTagWhereInput
    some?: CourseTagWhereInput
    none?: CourseTagWhereInput
  }

  export type CourseModuleListRelationFilter = {
    every?: CourseModuleWhereInput
    some?: CourseModuleWhereInput
    none?: CourseModuleWhereInput
  }

  export type CourseSkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseModuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    imageUrl?: SortOrder
    thumbnailUrl?: SortOrder
    courseUrl?: SortOrder
    instructor?: SortOrder
    institution?: SortOrder
    duration?: SortOrder
    difficulty?: SortOrder
    status?: SortOrder
    price?: SortOrder
    isFree?: SortOrder
    language?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    enrollmentCount?: SortOrder
    isActive?: SortOrder
    prerequisites?: SortOrder
    learningOutcomes?: SortOrder
    syllabus?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type CourseAvgOrderByAggregateInput = {
    price?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    enrollmentCount?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    imageUrl?: SortOrder
    thumbnailUrl?: SortOrder
    courseUrl?: SortOrder
    instructor?: SortOrder
    institution?: SortOrder
    duration?: SortOrder
    difficulty?: SortOrder
    status?: SortOrder
    price?: SortOrder
    isFree?: SortOrder
    language?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    enrollmentCount?: SortOrder
    isActive?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    imageUrl?: SortOrder
    thumbnailUrl?: SortOrder
    courseUrl?: SortOrder
    instructor?: SortOrder
    institution?: SortOrder
    duration?: SortOrder
    difficulty?: SortOrder
    status?: SortOrder
    price?: SortOrder
    isFree?: SortOrder
    language?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    enrollmentCount?: SortOrder
    isActive?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type CourseSumOrderByAggregateInput = {
    price?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    enrollmentCount?: SortOrder
  }

  export type EnumDifficultyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Difficulty | EnumDifficultyFieldRefInput<$PrismaModel>
    in?: $Enums.Difficulty[] | ListEnumDifficultyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Difficulty[] | ListEnumDifficultyFieldRefInput<$PrismaModel>
    not?: NestedEnumDifficultyWithAggregatesFilter<$PrismaModel> | $Enums.Difficulty
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDifficultyFilter<$PrismaModel>
    _max?: NestedEnumDifficultyFilter<$PrismaModel>
  }

  export type EnumCourseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseStatus | EnumCourseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseStatusWithAggregatesFilter<$PrismaModel> | $Enums.CourseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseStatusFilter<$PrismaModel>
    _max?: NestedEnumCourseStatusFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type SkillPrerequisiteListRelationFilter = {
    every?: SkillPrerequisiteWhereInput
    some?: SkillPrerequisiteWhereInput
    none?: SkillPrerequisiteWhereInput
  }

  export type ReviewSkillRatingListRelationFilter = {
    every?: ReviewSkillRatingWhereInput
    some?: ReviewSkillRatingWhereInput
    none?: ReviewSkillRatingWhereInput
  }

  export type SkillPrerequisiteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewSkillRatingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SkillCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkillMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkillMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSkillLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.SkillLevel | EnumSkillLevelFieldRefInput<$PrismaModel>
    in?: $Enums.SkillLevel[] | ListEnumSkillLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.SkillLevel[] | ListEnumSkillLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillLevelFilter<$PrismaModel> | $Enums.SkillLevel
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CourseScalarRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type SkillScalarRelationFilter = {
    is?: SkillWhereInput
    isNot?: SkillWhereInput
  }

  export type CourseSkillCourseIdSkillIdCompoundUniqueInput = {
    courseId: string
    skillId: string
  }

  export type CourseSkillCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    isCore?: SortOrder
    percentage?: SortOrder
    createdAt?: SortOrder
  }

  export type CourseSkillAvgOrderByAggregateInput = {
    percentage?: SortOrder
  }

  export type CourseSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    isCore?: SortOrder
    percentage?: SortOrder
    createdAt?: SortOrder
  }

  export type CourseSkillMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    isCore?: SortOrder
    percentage?: SortOrder
    createdAt?: SortOrder
  }

  export type CourseSkillSumOrderByAggregateInput = {
    percentage?: SortOrder
  }

  export type EnumSkillLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SkillLevel | EnumSkillLevelFieldRefInput<$PrismaModel>
    in?: $Enums.SkillLevel[] | ListEnumSkillLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.SkillLevel[] | ListEnumSkillLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillLevelWithAggregatesFilter<$PrismaModel> | $Enums.SkillLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSkillLevelFilter<$PrismaModel>
    _max?: NestedEnumSkillLevelFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type ReviewUserIdCourseIdCompoundUniqueInput = {
    userId: string
    courseId: string
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    overallRating?: SortOrder
    difficultyRating?: SortOrder
    contentQuality?: SortOrder
    instructorRating?: SortOrder
    valueForMoney?: SortOrder
    wouldRecommend?: SortOrder
    title?: SortOrder
    content?: SortOrder
    pros?: SortOrder
    cons?: SortOrder
    isAnonymous?: SortOrder
    isVerified?: SortOrder
    helpfulCount?: SortOrder
    flagCount?: SortOrder
    isHidden?: SortOrder
    moderatorNotes?: SortOrder
    completionDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    overallRating?: SortOrder
    difficultyRating?: SortOrder
    contentQuality?: SortOrder
    instructorRating?: SortOrder
    valueForMoney?: SortOrder
    helpfulCount?: SortOrder
    flagCount?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    overallRating?: SortOrder
    difficultyRating?: SortOrder
    contentQuality?: SortOrder
    instructorRating?: SortOrder
    valueForMoney?: SortOrder
    wouldRecommend?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isAnonymous?: SortOrder
    isVerified?: SortOrder
    helpfulCount?: SortOrder
    flagCount?: SortOrder
    isHidden?: SortOrder
    moderatorNotes?: SortOrder
    completionDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    overallRating?: SortOrder
    difficultyRating?: SortOrder
    contentQuality?: SortOrder
    instructorRating?: SortOrder
    valueForMoney?: SortOrder
    wouldRecommend?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isAnonymous?: SortOrder
    isVerified?: SortOrder
    helpfulCount?: SortOrder
    flagCount?: SortOrder
    isHidden?: SortOrder
    moderatorNotes?: SortOrder
    completionDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    overallRating?: SortOrder
    difficultyRating?: SortOrder
    contentQuality?: SortOrder
    instructorRating?: SortOrder
    valueForMoney?: SortOrder
    helpfulCount?: SortOrder
    flagCount?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type ReviewScalarRelationFilter = {
    is?: ReviewWhereInput
    isNot?: ReviewWhereInput
  }

  export type ReviewVoteUserIdReviewIdCompoundUniqueInput = {
    userId: string
    reviewId: string
  }

  export type ReviewVoteCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    reviewId?: SortOrder
    isUpvote?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewVoteMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    reviewId?: SortOrder
    isUpvote?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewVoteMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    reviewId?: SortOrder
    isUpvote?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewHelpfulVoteUserIdReviewIdCompoundUniqueInput = {
    userId: string
    reviewId: string
  }

  export type ReviewHelpfulVoteCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    reviewId?: SortOrder
    isHelpful?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewHelpfulVoteMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    reviewId?: SortOrder
    isHelpful?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewHelpfulVoteMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    reviewId?: SortOrder
    isHelpful?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewSkillRatingReviewIdSkillIdCompoundUniqueInput = {
    reviewId: string
    skillId: string
  }

  export type ReviewSkillRatingCountOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    skillId?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewSkillRatingAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ReviewSkillRatingMaxOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    skillId?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewSkillRatingMinOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    skillId?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewSkillRatingSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type CourseEnrollmentUserIdCourseIdCompoundUniqueInput = {
    userId: string
    courseId: string
  }

  export type CourseEnrollmentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrder
    progress?: SortOrder
    lastAccessed?: SortOrder
    status?: SortOrder
    certificateUrl?: SortOrder
  }

  export type CourseEnrollmentAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type CourseEnrollmentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrder
    progress?: SortOrder
    lastAccessed?: SortOrder
    status?: SortOrder
    certificateUrl?: SortOrder
  }

  export type CourseEnrollmentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrder
    progress?: SortOrder
    lastAccessed?: SortOrder
    status?: SortOrder
    certificateUrl?: SortOrder
  }

  export type CourseEnrollmentSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type UserSkillProficiencyUserIdSkillIdCompoundUniqueInput = {
    userId: string
    skillId: string
  }

  export type UserSkillProficiencyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    yearsExperience?: SortOrder
    lastUsed?: SortOrder
    isVerified?: SortOrder
    verificationSource?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSkillProficiencyAvgOrderByAggregateInput = {
    yearsExperience?: SortOrder
  }

  export type UserSkillProficiencyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    yearsExperience?: SortOrder
    lastUsed?: SortOrder
    isVerified?: SortOrder
    verificationSource?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSkillProficiencyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    yearsExperience?: SortOrder
    lastUsed?: SortOrder
    isVerified?: SortOrder
    verificationSource?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSkillProficiencySumOrderByAggregateInput = {
    yearsExperience?: SortOrder
  }

  export type SkillPrerequisiteSkillIdPrerequisiteSkillIdCompoundUniqueInput = {
    skillId: string
    prerequisiteSkillId: string
  }

  export type SkillPrerequisiteCountOrderByAggregateInput = {
    id?: SortOrder
    skillId?: SortOrder
    prerequisiteSkillId?: SortOrder
    isRequired?: SortOrder
    minimumLevel?: SortOrder
  }

  export type SkillPrerequisiteMaxOrderByAggregateInput = {
    id?: SortOrder
    skillId?: SortOrder
    prerequisiteSkillId?: SortOrder
    isRequired?: SortOrder
    minimumLevel?: SortOrder
  }

  export type SkillPrerequisiteMinOrderByAggregateInput = {
    id?: SortOrder
    skillId?: SortOrder
    prerequisiteSkillId?: SortOrder
    isRequired?: SortOrder
    minimumLevel?: SortOrder
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    parentId?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    parentId?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    parentId?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type CourseCategoryCourseIdCategoryIdCompoundUniqueInput = {
    courseId: string
    categoryId: string
  }

  export type CourseCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    categoryId?: SortOrder
    isPrimary?: SortOrder
  }

  export type CourseCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    categoryId?: SortOrder
    isPrimary?: SortOrder
  }

  export type CourseCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    categoryId?: SortOrder
    isPrimary?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type CourseTagCourseIdTagIdCompoundUniqueInput = {
    courseId: string
    tagId: string
  }

  export type CourseTagCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    tagId?: SortOrder
  }

  export type CourseTagMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    tagId?: SortOrder
  }

  export type CourseTagMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    tagId?: SortOrder
  }

  export type CourseModuleCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    sortOrder?: SortOrder
    duration?: SortOrder
    isOptional?: SortOrder
  }

  export type CourseModuleAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type CourseModuleMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    sortOrder?: SortOrder
    duration?: SortOrder
    isOptional?: SortOrder
  }

  export type CourseModuleMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    sortOrder?: SortOrder
    duration?: SortOrder
    isOptional?: SortOrder
  }

  export type CourseModuleSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type EnumAchievementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementType | EnumAchievementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementType[] | ListEnumAchievementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementType[] | ListEnumAchievementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementTypeFilter<$PrismaModel> | $Enums.AchievementType
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AchievementCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    type?: SortOrder
    criteria?: SortOrder
    points?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type AchievementAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type AchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    type?: SortOrder
    points?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type AchievementMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    type?: SortOrder
    points?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type AchievementSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type EnumAchievementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementType | EnumAchievementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementType[] | ListEnumAchievementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementType[] | ListEnumAchievementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementTypeWithAggregatesFilter<$PrismaModel> | $Enums.AchievementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAchievementTypeFilter<$PrismaModel>
    _max?: NestedEnumAchievementTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type AchievementScalarRelationFilter = {
    is?: AchievementWhereInput
    isNot?: AchievementWhereInput
  }

  export type UserAchievementUserIdAchievementIdCompoundUniqueInput = {
    userId: string
    achievementId: string
  }

  export type UserAchievementCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    earnedAt?: SortOrder
    progress?: SortOrder
  }

  export type UserAchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    earnedAt?: SortOrder
  }

  export type UserAchievementMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    earnedAt?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type ProgressReportCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    reportDate?: SortOrder
    coursesCompleted?: SortOrder
    reviewsWritten?: SortOrder
    pointsEarned?: SortOrder
    skillsLearned?: SortOrder
    weeklyGoalMet?: SortOrder
    monthlyGoalMet?: SortOrder
  }

  export type ProgressReportAvgOrderByAggregateInput = {
    coursesCompleted?: SortOrder
    reviewsWritten?: SortOrder
    pointsEarned?: SortOrder
  }

  export type ProgressReportMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    reportDate?: SortOrder
    coursesCompleted?: SortOrder
    reviewsWritten?: SortOrder
    pointsEarned?: SortOrder
    weeklyGoalMet?: SortOrder
    monthlyGoalMet?: SortOrder
  }

  export type ProgressReportMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    reportDate?: SortOrder
    coursesCompleted?: SortOrder
    reviewsWritten?: SortOrder
    pointsEarned?: SortOrder
    weeklyGoalMet?: SortOrder
    monthlyGoalMet?: SortOrder
  }

  export type ProgressReportSumOrderByAggregateInput = {
    coursesCompleted?: SortOrder
    reviewsWritten?: SortOrder
    pointsEarned?: SortOrder
  }

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ReviewVoteCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewVoteCreateWithoutUserInput, ReviewVoteUncheckedCreateWithoutUserInput> | ReviewVoteCreateWithoutUserInput[] | ReviewVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewVoteCreateOrConnectWithoutUserInput | ReviewVoteCreateOrConnectWithoutUserInput[]
    createMany?: ReviewVoteCreateManyUserInputEnvelope
    connect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
  }

  export type CourseEnrollmentCreateNestedManyWithoutUserInput = {
    create?: XOR<CourseEnrollmentCreateWithoutUserInput, CourseEnrollmentUncheckedCreateWithoutUserInput> | CourseEnrollmentCreateWithoutUserInput[] | CourseEnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseEnrollmentCreateOrConnectWithoutUserInput | CourseEnrollmentCreateOrConnectWithoutUserInput[]
    createMany?: CourseEnrollmentCreateManyUserInputEnvelope
    connect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
  }

  export type UserAchievementCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CourseCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CourseCreateWithoutCreatedByInput, CourseUncheckedCreateWithoutCreatedByInput> | CourseCreateWithoutCreatedByInput[] | CourseUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCreatedByInput | CourseCreateOrConnectWithoutCreatedByInput[]
    createMany?: CourseCreateManyCreatedByInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type UserSkillProficiencyCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSkillProficiencyCreateWithoutUserInput, UserSkillProficiencyUncheckedCreateWithoutUserInput> | UserSkillProficiencyCreateWithoutUserInput[] | UserSkillProficiencyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSkillProficiencyCreateOrConnectWithoutUserInput | UserSkillProficiencyCreateOrConnectWithoutUserInput[]
    createMany?: UserSkillProficiencyCreateManyUserInputEnvelope
    connect?: UserSkillProficiencyWhereUniqueInput | UserSkillProficiencyWhereUniqueInput[]
  }

  export type ReviewHelpfulVoteCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewHelpfulVoteCreateWithoutUserInput, ReviewHelpfulVoteUncheckedCreateWithoutUserInput> | ReviewHelpfulVoteCreateWithoutUserInput[] | ReviewHelpfulVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewHelpfulVoteCreateOrConnectWithoutUserInput | ReviewHelpfulVoteCreateOrConnectWithoutUserInput[]
    createMany?: ReviewHelpfulVoteCreateManyUserInputEnvelope
    connect?: ReviewHelpfulVoteWhereUniqueInput | ReviewHelpfulVoteWhereUniqueInput[]
  }

  export type ProgressReportCreateNestedManyWithoutUserInput = {
    create?: XOR<ProgressReportCreateWithoutUserInput, ProgressReportUncheckedCreateWithoutUserInput> | ProgressReportCreateWithoutUserInput[] | ProgressReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProgressReportCreateOrConnectWithoutUserInput | ProgressReportCreateOrConnectWithoutUserInput[]
    createMany?: ProgressReportCreateManyUserInputEnvelope
    connect?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ReviewVoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewVoteCreateWithoutUserInput, ReviewVoteUncheckedCreateWithoutUserInput> | ReviewVoteCreateWithoutUserInput[] | ReviewVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewVoteCreateOrConnectWithoutUserInput | ReviewVoteCreateOrConnectWithoutUserInput[]
    createMany?: ReviewVoteCreateManyUserInputEnvelope
    connect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
  }

  export type CourseEnrollmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CourseEnrollmentCreateWithoutUserInput, CourseEnrollmentUncheckedCreateWithoutUserInput> | CourseEnrollmentCreateWithoutUserInput[] | CourseEnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseEnrollmentCreateOrConnectWithoutUserInput | CourseEnrollmentCreateOrConnectWithoutUserInput[]
    createMany?: CourseEnrollmentCreateManyUserInputEnvelope
    connect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
  }

  export type UserAchievementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CourseCreateWithoutCreatedByInput, CourseUncheckedCreateWithoutCreatedByInput> | CourseCreateWithoutCreatedByInput[] | CourseUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCreatedByInput | CourseCreateOrConnectWithoutCreatedByInput[]
    createMany?: CourseCreateManyCreatedByInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type UserSkillProficiencyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSkillProficiencyCreateWithoutUserInput, UserSkillProficiencyUncheckedCreateWithoutUserInput> | UserSkillProficiencyCreateWithoutUserInput[] | UserSkillProficiencyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSkillProficiencyCreateOrConnectWithoutUserInput | UserSkillProficiencyCreateOrConnectWithoutUserInput[]
    createMany?: UserSkillProficiencyCreateManyUserInputEnvelope
    connect?: UserSkillProficiencyWhereUniqueInput | UserSkillProficiencyWhereUniqueInput[]
  }

  export type ReviewHelpfulVoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewHelpfulVoteCreateWithoutUserInput, ReviewHelpfulVoteUncheckedCreateWithoutUserInput> | ReviewHelpfulVoteCreateWithoutUserInput[] | ReviewHelpfulVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewHelpfulVoteCreateOrConnectWithoutUserInput | ReviewHelpfulVoteCreateOrConnectWithoutUserInput[]
    createMany?: ReviewHelpfulVoteCreateManyUserInputEnvelope
    connect?: ReviewHelpfulVoteWhereUniqueInput | ReviewHelpfulVoteWhereUniqueInput[]
  }

  export type ProgressReportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProgressReportCreateWithoutUserInput, ProgressReportUncheckedCreateWithoutUserInput> | ProgressReportCreateWithoutUserInput[] | ProgressReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProgressReportCreateOrConnectWithoutUserInput | ProgressReportCreateOrConnectWithoutUserInput[]
    createMany?: ProgressReportCreateManyUserInputEnvelope
    connect?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ReviewVoteUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewVoteCreateWithoutUserInput, ReviewVoteUncheckedCreateWithoutUserInput> | ReviewVoteCreateWithoutUserInput[] | ReviewVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewVoteCreateOrConnectWithoutUserInput | ReviewVoteCreateOrConnectWithoutUserInput[]
    upsert?: ReviewVoteUpsertWithWhereUniqueWithoutUserInput | ReviewVoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewVoteCreateManyUserInputEnvelope
    set?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    disconnect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    delete?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    connect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    update?: ReviewVoteUpdateWithWhereUniqueWithoutUserInput | ReviewVoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewVoteUpdateManyWithWhereWithoutUserInput | ReviewVoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewVoteScalarWhereInput | ReviewVoteScalarWhereInput[]
  }

  export type CourseEnrollmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CourseEnrollmentCreateWithoutUserInput, CourseEnrollmentUncheckedCreateWithoutUserInput> | CourseEnrollmentCreateWithoutUserInput[] | CourseEnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseEnrollmentCreateOrConnectWithoutUserInput | CourseEnrollmentCreateOrConnectWithoutUserInput[]
    upsert?: CourseEnrollmentUpsertWithWhereUniqueWithoutUserInput | CourseEnrollmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CourseEnrollmentCreateManyUserInputEnvelope
    set?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    disconnect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    delete?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    connect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    update?: CourseEnrollmentUpdateWithWhereUniqueWithoutUserInput | CourseEnrollmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CourseEnrollmentUpdateManyWithWhereWithoutUserInput | CourseEnrollmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CourseEnrollmentScalarWhereInput | CourseEnrollmentScalarWhereInput[]
  }

  export type UserAchievementUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutUserInput | UserAchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutUserInput | UserAchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutUserInput | UserAchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CourseUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CourseCreateWithoutCreatedByInput, CourseUncheckedCreateWithoutCreatedByInput> | CourseCreateWithoutCreatedByInput[] | CourseUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCreatedByInput | CourseCreateOrConnectWithoutCreatedByInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutCreatedByInput | CourseUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CourseCreateManyCreatedByInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutCreatedByInput | CourseUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutCreatedByInput | CourseUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type UserSkillProficiencyUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSkillProficiencyCreateWithoutUserInput, UserSkillProficiencyUncheckedCreateWithoutUserInput> | UserSkillProficiencyCreateWithoutUserInput[] | UserSkillProficiencyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSkillProficiencyCreateOrConnectWithoutUserInput | UserSkillProficiencyCreateOrConnectWithoutUserInput[]
    upsert?: UserSkillProficiencyUpsertWithWhereUniqueWithoutUserInput | UserSkillProficiencyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSkillProficiencyCreateManyUserInputEnvelope
    set?: UserSkillProficiencyWhereUniqueInput | UserSkillProficiencyWhereUniqueInput[]
    disconnect?: UserSkillProficiencyWhereUniqueInput | UserSkillProficiencyWhereUniqueInput[]
    delete?: UserSkillProficiencyWhereUniqueInput | UserSkillProficiencyWhereUniqueInput[]
    connect?: UserSkillProficiencyWhereUniqueInput | UserSkillProficiencyWhereUniqueInput[]
    update?: UserSkillProficiencyUpdateWithWhereUniqueWithoutUserInput | UserSkillProficiencyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSkillProficiencyUpdateManyWithWhereWithoutUserInput | UserSkillProficiencyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSkillProficiencyScalarWhereInput | UserSkillProficiencyScalarWhereInput[]
  }

  export type ReviewHelpfulVoteUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewHelpfulVoteCreateWithoutUserInput, ReviewHelpfulVoteUncheckedCreateWithoutUserInput> | ReviewHelpfulVoteCreateWithoutUserInput[] | ReviewHelpfulVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewHelpfulVoteCreateOrConnectWithoutUserInput | ReviewHelpfulVoteCreateOrConnectWithoutUserInput[]
    upsert?: ReviewHelpfulVoteUpsertWithWhereUniqueWithoutUserInput | ReviewHelpfulVoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewHelpfulVoteCreateManyUserInputEnvelope
    set?: ReviewHelpfulVoteWhereUniqueInput | ReviewHelpfulVoteWhereUniqueInput[]
    disconnect?: ReviewHelpfulVoteWhereUniqueInput | ReviewHelpfulVoteWhereUniqueInput[]
    delete?: ReviewHelpfulVoteWhereUniqueInput | ReviewHelpfulVoteWhereUniqueInput[]
    connect?: ReviewHelpfulVoteWhereUniqueInput | ReviewHelpfulVoteWhereUniqueInput[]
    update?: ReviewHelpfulVoteUpdateWithWhereUniqueWithoutUserInput | ReviewHelpfulVoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewHelpfulVoteUpdateManyWithWhereWithoutUserInput | ReviewHelpfulVoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewHelpfulVoteScalarWhereInput | ReviewHelpfulVoteScalarWhereInput[]
  }

  export type ProgressReportUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProgressReportCreateWithoutUserInput, ProgressReportUncheckedCreateWithoutUserInput> | ProgressReportCreateWithoutUserInput[] | ProgressReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProgressReportCreateOrConnectWithoutUserInput | ProgressReportCreateOrConnectWithoutUserInput[]
    upsert?: ProgressReportUpsertWithWhereUniqueWithoutUserInput | ProgressReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProgressReportCreateManyUserInputEnvelope
    set?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    disconnect?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    delete?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    connect?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    update?: ProgressReportUpdateWithWhereUniqueWithoutUserInput | ProgressReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProgressReportUpdateManyWithWhereWithoutUserInput | ProgressReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProgressReportScalarWhereInput | ProgressReportScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ReviewVoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewVoteCreateWithoutUserInput, ReviewVoteUncheckedCreateWithoutUserInput> | ReviewVoteCreateWithoutUserInput[] | ReviewVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewVoteCreateOrConnectWithoutUserInput | ReviewVoteCreateOrConnectWithoutUserInput[]
    upsert?: ReviewVoteUpsertWithWhereUniqueWithoutUserInput | ReviewVoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewVoteCreateManyUserInputEnvelope
    set?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    disconnect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    delete?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    connect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    update?: ReviewVoteUpdateWithWhereUniqueWithoutUserInput | ReviewVoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewVoteUpdateManyWithWhereWithoutUserInput | ReviewVoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewVoteScalarWhereInput | ReviewVoteScalarWhereInput[]
  }

  export type CourseEnrollmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CourseEnrollmentCreateWithoutUserInput, CourseEnrollmentUncheckedCreateWithoutUserInput> | CourseEnrollmentCreateWithoutUserInput[] | CourseEnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseEnrollmentCreateOrConnectWithoutUserInput | CourseEnrollmentCreateOrConnectWithoutUserInput[]
    upsert?: CourseEnrollmentUpsertWithWhereUniqueWithoutUserInput | CourseEnrollmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CourseEnrollmentCreateManyUserInputEnvelope
    set?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    disconnect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    delete?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    connect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    update?: CourseEnrollmentUpdateWithWhereUniqueWithoutUserInput | CourseEnrollmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CourseEnrollmentUpdateManyWithWhereWithoutUserInput | CourseEnrollmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CourseEnrollmentScalarWhereInput | CourseEnrollmentScalarWhereInput[]
  }

  export type UserAchievementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutUserInput | UserAchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutUserInput | UserAchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutUserInput | UserAchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CourseCreateWithoutCreatedByInput, CourseUncheckedCreateWithoutCreatedByInput> | CourseCreateWithoutCreatedByInput[] | CourseUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCreatedByInput | CourseCreateOrConnectWithoutCreatedByInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutCreatedByInput | CourseUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CourseCreateManyCreatedByInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutCreatedByInput | CourseUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutCreatedByInput | CourseUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type UserSkillProficiencyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSkillProficiencyCreateWithoutUserInput, UserSkillProficiencyUncheckedCreateWithoutUserInput> | UserSkillProficiencyCreateWithoutUserInput[] | UserSkillProficiencyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSkillProficiencyCreateOrConnectWithoutUserInput | UserSkillProficiencyCreateOrConnectWithoutUserInput[]
    upsert?: UserSkillProficiencyUpsertWithWhereUniqueWithoutUserInput | UserSkillProficiencyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSkillProficiencyCreateManyUserInputEnvelope
    set?: UserSkillProficiencyWhereUniqueInput | UserSkillProficiencyWhereUniqueInput[]
    disconnect?: UserSkillProficiencyWhereUniqueInput | UserSkillProficiencyWhereUniqueInput[]
    delete?: UserSkillProficiencyWhereUniqueInput | UserSkillProficiencyWhereUniqueInput[]
    connect?: UserSkillProficiencyWhereUniqueInput | UserSkillProficiencyWhereUniqueInput[]
    update?: UserSkillProficiencyUpdateWithWhereUniqueWithoutUserInput | UserSkillProficiencyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSkillProficiencyUpdateManyWithWhereWithoutUserInput | UserSkillProficiencyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSkillProficiencyScalarWhereInput | UserSkillProficiencyScalarWhereInput[]
  }

  export type ReviewHelpfulVoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewHelpfulVoteCreateWithoutUserInput, ReviewHelpfulVoteUncheckedCreateWithoutUserInput> | ReviewHelpfulVoteCreateWithoutUserInput[] | ReviewHelpfulVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewHelpfulVoteCreateOrConnectWithoutUserInput | ReviewHelpfulVoteCreateOrConnectWithoutUserInput[]
    upsert?: ReviewHelpfulVoteUpsertWithWhereUniqueWithoutUserInput | ReviewHelpfulVoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewHelpfulVoteCreateManyUserInputEnvelope
    set?: ReviewHelpfulVoteWhereUniqueInput | ReviewHelpfulVoteWhereUniqueInput[]
    disconnect?: ReviewHelpfulVoteWhereUniqueInput | ReviewHelpfulVoteWhereUniqueInput[]
    delete?: ReviewHelpfulVoteWhereUniqueInput | ReviewHelpfulVoteWhereUniqueInput[]
    connect?: ReviewHelpfulVoteWhereUniqueInput | ReviewHelpfulVoteWhereUniqueInput[]
    update?: ReviewHelpfulVoteUpdateWithWhereUniqueWithoutUserInput | ReviewHelpfulVoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewHelpfulVoteUpdateManyWithWhereWithoutUserInput | ReviewHelpfulVoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewHelpfulVoteScalarWhereInput | ReviewHelpfulVoteScalarWhereInput[]
  }

  export type ProgressReportUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProgressReportCreateWithoutUserInput, ProgressReportUncheckedCreateWithoutUserInput> | ProgressReportCreateWithoutUserInput[] | ProgressReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProgressReportCreateOrConnectWithoutUserInput | ProgressReportCreateOrConnectWithoutUserInput[]
    upsert?: ProgressReportUpsertWithWhereUniqueWithoutUserInput | ProgressReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProgressReportCreateManyUserInputEnvelope
    set?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    disconnect?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    delete?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    connect?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    update?: ProgressReportUpdateWithWhereUniqueWithoutUserInput | ProgressReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProgressReportUpdateManyWithWhereWithoutUserInput | ProgressReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProgressReportScalarWhereInput | ProgressReportScalarWhereInput[]
  }

  export type CourseCreateprerequisitesInput = {
    set: string[]
  }

  export type CourseCreatelearningOutcomesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutCoursesInput = {
    create?: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoursesInput
    connect?: UserWhereUniqueInput
  }

  export type ReviewCreateNestedManyWithoutCourseInput = {
    create?: XOR<ReviewCreateWithoutCourseInput, ReviewUncheckedCreateWithoutCourseInput> | ReviewCreateWithoutCourseInput[] | ReviewUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutCourseInput | ReviewCreateOrConnectWithoutCourseInput[]
    createMany?: ReviewCreateManyCourseInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type CourseSkillCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseSkillCreateWithoutCourseInput, CourseSkillUncheckedCreateWithoutCourseInput> | CourseSkillCreateWithoutCourseInput[] | CourseSkillUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseSkillCreateOrConnectWithoutCourseInput | CourseSkillCreateOrConnectWithoutCourseInput[]
    createMany?: CourseSkillCreateManyCourseInputEnvelope
    connect?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
  }

  export type CourseEnrollmentCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseEnrollmentCreateWithoutCourseInput, CourseEnrollmentUncheckedCreateWithoutCourseInput> | CourseEnrollmentCreateWithoutCourseInput[] | CourseEnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseEnrollmentCreateOrConnectWithoutCourseInput | CourseEnrollmentCreateOrConnectWithoutCourseInput[]
    createMany?: CourseEnrollmentCreateManyCourseInputEnvelope
    connect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
  }

  export type CourseCategoryCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseCategoryCreateWithoutCourseInput, CourseCategoryUncheckedCreateWithoutCourseInput> | CourseCategoryCreateWithoutCourseInput[] | CourseCategoryUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseCategoryCreateOrConnectWithoutCourseInput | CourseCategoryCreateOrConnectWithoutCourseInput[]
    createMany?: CourseCategoryCreateManyCourseInputEnvelope
    connect?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[]
  }

  export type CourseTagCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseTagCreateWithoutCourseInput, CourseTagUncheckedCreateWithoutCourseInput> | CourseTagCreateWithoutCourseInput[] | CourseTagUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseTagCreateOrConnectWithoutCourseInput | CourseTagCreateOrConnectWithoutCourseInput[]
    createMany?: CourseTagCreateManyCourseInputEnvelope
    connect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
  }

  export type CourseModuleCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseModuleCreateWithoutCourseInput, CourseModuleUncheckedCreateWithoutCourseInput> | CourseModuleCreateWithoutCourseInput[] | CourseModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseModuleCreateOrConnectWithoutCourseInput | CourseModuleCreateOrConnectWithoutCourseInput[]
    createMany?: CourseModuleCreateManyCourseInputEnvelope
    connect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<ReviewCreateWithoutCourseInput, ReviewUncheckedCreateWithoutCourseInput> | ReviewCreateWithoutCourseInput[] | ReviewUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutCourseInput | ReviewCreateOrConnectWithoutCourseInput[]
    createMany?: ReviewCreateManyCourseInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type CourseSkillUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseSkillCreateWithoutCourseInput, CourseSkillUncheckedCreateWithoutCourseInput> | CourseSkillCreateWithoutCourseInput[] | CourseSkillUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseSkillCreateOrConnectWithoutCourseInput | CourseSkillCreateOrConnectWithoutCourseInput[]
    createMany?: CourseSkillCreateManyCourseInputEnvelope
    connect?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
  }

  export type CourseEnrollmentUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseEnrollmentCreateWithoutCourseInput, CourseEnrollmentUncheckedCreateWithoutCourseInput> | CourseEnrollmentCreateWithoutCourseInput[] | CourseEnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseEnrollmentCreateOrConnectWithoutCourseInput | CourseEnrollmentCreateOrConnectWithoutCourseInput[]
    createMany?: CourseEnrollmentCreateManyCourseInputEnvelope
    connect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
  }

  export type CourseCategoryUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseCategoryCreateWithoutCourseInput, CourseCategoryUncheckedCreateWithoutCourseInput> | CourseCategoryCreateWithoutCourseInput[] | CourseCategoryUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseCategoryCreateOrConnectWithoutCourseInput | CourseCategoryCreateOrConnectWithoutCourseInput[]
    createMany?: CourseCategoryCreateManyCourseInputEnvelope
    connect?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[]
  }

  export type CourseTagUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseTagCreateWithoutCourseInput, CourseTagUncheckedCreateWithoutCourseInput> | CourseTagCreateWithoutCourseInput[] | CourseTagUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseTagCreateOrConnectWithoutCourseInput | CourseTagCreateOrConnectWithoutCourseInput[]
    createMany?: CourseTagCreateManyCourseInputEnvelope
    connect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
  }

  export type CourseModuleUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseModuleCreateWithoutCourseInput, CourseModuleUncheckedCreateWithoutCourseInput> | CourseModuleCreateWithoutCourseInput[] | CourseModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseModuleCreateOrConnectWithoutCourseInput | CourseModuleCreateOrConnectWithoutCourseInput[]
    createMany?: CourseModuleCreateManyCourseInputEnvelope
    connect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
  }

  export type EnumDifficultyFieldUpdateOperationsInput = {
    set?: $Enums.Difficulty
  }

  export type EnumCourseStatusFieldUpdateOperationsInput = {
    set?: $Enums.CourseStatus
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type CourseUpdateprerequisitesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CourseUpdatelearningOutcomesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutCoursesNestedInput = {
    create?: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoursesInput
    upsert?: UserUpsertWithoutCoursesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCoursesInput, UserUpdateWithoutCoursesInput>, UserUncheckedUpdateWithoutCoursesInput>
  }

  export type ReviewUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ReviewCreateWithoutCourseInput, ReviewUncheckedCreateWithoutCourseInput> | ReviewCreateWithoutCourseInput[] | ReviewUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutCourseInput | ReviewCreateOrConnectWithoutCourseInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutCourseInput | ReviewUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ReviewCreateManyCourseInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutCourseInput | ReviewUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutCourseInput | ReviewUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type CourseSkillUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseSkillCreateWithoutCourseInput, CourseSkillUncheckedCreateWithoutCourseInput> | CourseSkillCreateWithoutCourseInput[] | CourseSkillUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseSkillCreateOrConnectWithoutCourseInput | CourseSkillCreateOrConnectWithoutCourseInput[]
    upsert?: CourseSkillUpsertWithWhereUniqueWithoutCourseInput | CourseSkillUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseSkillCreateManyCourseInputEnvelope
    set?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
    disconnect?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
    delete?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
    connect?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
    update?: CourseSkillUpdateWithWhereUniqueWithoutCourseInput | CourseSkillUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseSkillUpdateManyWithWhereWithoutCourseInput | CourseSkillUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseSkillScalarWhereInput | CourseSkillScalarWhereInput[]
  }

  export type CourseEnrollmentUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseEnrollmentCreateWithoutCourseInput, CourseEnrollmentUncheckedCreateWithoutCourseInput> | CourseEnrollmentCreateWithoutCourseInput[] | CourseEnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseEnrollmentCreateOrConnectWithoutCourseInput | CourseEnrollmentCreateOrConnectWithoutCourseInput[]
    upsert?: CourseEnrollmentUpsertWithWhereUniqueWithoutCourseInput | CourseEnrollmentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseEnrollmentCreateManyCourseInputEnvelope
    set?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    disconnect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    delete?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    connect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    update?: CourseEnrollmentUpdateWithWhereUniqueWithoutCourseInput | CourseEnrollmentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseEnrollmentUpdateManyWithWhereWithoutCourseInput | CourseEnrollmentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseEnrollmentScalarWhereInput | CourseEnrollmentScalarWhereInput[]
  }

  export type CourseCategoryUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseCategoryCreateWithoutCourseInput, CourseCategoryUncheckedCreateWithoutCourseInput> | CourseCategoryCreateWithoutCourseInput[] | CourseCategoryUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseCategoryCreateOrConnectWithoutCourseInput | CourseCategoryCreateOrConnectWithoutCourseInput[]
    upsert?: CourseCategoryUpsertWithWhereUniqueWithoutCourseInput | CourseCategoryUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseCategoryCreateManyCourseInputEnvelope
    set?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[]
    disconnect?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[]
    delete?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[]
    connect?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[]
    update?: CourseCategoryUpdateWithWhereUniqueWithoutCourseInput | CourseCategoryUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseCategoryUpdateManyWithWhereWithoutCourseInput | CourseCategoryUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseCategoryScalarWhereInput | CourseCategoryScalarWhereInput[]
  }

  export type CourseTagUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseTagCreateWithoutCourseInput, CourseTagUncheckedCreateWithoutCourseInput> | CourseTagCreateWithoutCourseInput[] | CourseTagUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseTagCreateOrConnectWithoutCourseInput | CourseTagCreateOrConnectWithoutCourseInput[]
    upsert?: CourseTagUpsertWithWhereUniqueWithoutCourseInput | CourseTagUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseTagCreateManyCourseInputEnvelope
    set?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    disconnect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    delete?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    connect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    update?: CourseTagUpdateWithWhereUniqueWithoutCourseInput | CourseTagUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseTagUpdateManyWithWhereWithoutCourseInput | CourseTagUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseTagScalarWhereInput | CourseTagScalarWhereInput[]
  }

  export type CourseModuleUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseModuleCreateWithoutCourseInput, CourseModuleUncheckedCreateWithoutCourseInput> | CourseModuleCreateWithoutCourseInput[] | CourseModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseModuleCreateOrConnectWithoutCourseInput | CourseModuleCreateOrConnectWithoutCourseInput[]
    upsert?: CourseModuleUpsertWithWhereUniqueWithoutCourseInput | CourseModuleUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseModuleCreateManyCourseInputEnvelope
    set?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    disconnect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    delete?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    connect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    update?: CourseModuleUpdateWithWhereUniqueWithoutCourseInput | CourseModuleUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseModuleUpdateManyWithWhereWithoutCourseInput | CourseModuleUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseModuleScalarWhereInput | CourseModuleScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ReviewCreateWithoutCourseInput, ReviewUncheckedCreateWithoutCourseInput> | ReviewCreateWithoutCourseInput[] | ReviewUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutCourseInput | ReviewCreateOrConnectWithoutCourseInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutCourseInput | ReviewUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ReviewCreateManyCourseInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutCourseInput | ReviewUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutCourseInput | ReviewUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type CourseSkillUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseSkillCreateWithoutCourseInput, CourseSkillUncheckedCreateWithoutCourseInput> | CourseSkillCreateWithoutCourseInput[] | CourseSkillUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseSkillCreateOrConnectWithoutCourseInput | CourseSkillCreateOrConnectWithoutCourseInput[]
    upsert?: CourseSkillUpsertWithWhereUniqueWithoutCourseInput | CourseSkillUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseSkillCreateManyCourseInputEnvelope
    set?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
    disconnect?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
    delete?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
    connect?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
    update?: CourseSkillUpdateWithWhereUniqueWithoutCourseInput | CourseSkillUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseSkillUpdateManyWithWhereWithoutCourseInput | CourseSkillUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseSkillScalarWhereInput | CourseSkillScalarWhereInput[]
  }

  export type CourseEnrollmentUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseEnrollmentCreateWithoutCourseInput, CourseEnrollmentUncheckedCreateWithoutCourseInput> | CourseEnrollmentCreateWithoutCourseInput[] | CourseEnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseEnrollmentCreateOrConnectWithoutCourseInput | CourseEnrollmentCreateOrConnectWithoutCourseInput[]
    upsert?: CourseEnrollmentUpsertWithWhereUniqueWithoutCourseInput | CourseEnrollmentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseEnrollmentCreateManyCourseInputEnvelope
    set?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    disconnect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    delete?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    connect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    update?: CourseEnrollmentUpdateWithWhereUniqueWithoutCourseInput | CourseEnrollmentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseEnrollmentUpdateManyWithWhereWithoutCourseInput | CourseEnrollmentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseEnrollmentScalarWhereInput | CourseEnrollmentScalarWhereInput[]
  }

  export type CourseCategoryUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseCategoryCreateWithoutCourseInput, CourseCategoryUncheckedCreateWithoutCourseInput> | CourseCategoryCreateWithoutCourseInput[] | CourseCategoryUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseCategoryCreateOrConnectWithoutCourseInput | CourseCategoryCreateOrConnectWithoutCourseInput[]
    upsert?: CourseCategoryUpsertWithWhereUniqueWithoutCourseInput | CourseCategoryUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseCategoryCreateManyCourseInputEnvelope
    set?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[]
    disconnect?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[]
    delete?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[]
    connect?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[]
    update?: CourseCategoryUpdateWithWhereUniqueWithoutCourseInput | CourseCategoryUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseCategoryUpdateManyWithWhereWithoutCourseInput | CourseCategoryUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseCategoryScalarWhereInput | CourseCategoryScalarWhereInput[]
  }

  export type CourseTagUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseTagCreateWithoutCourseInput, CourseTagUncheckedCreateWithoutCourseInput> | CourseTagCreateWithoutCourseInput[] | CourseTagUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseTagCreateOrConnectWithoutCourseInput | CourseTagCreateOrConnectWithoutCourseInput[]
    upsert?: CourseTagUpsertWithWhereUniqueWithoutCourseInput | CourseTagUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseTagCreateManyCourseInputEnvelope
    set?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    disconnect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    delete?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    connect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    update?: CourseTagUpdateWithWhereUniqueWithoutCourseInput | CourseTagUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseTagUpdateManyWithWhereWithoutCourseInput | CourseTagUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseTagScalarWhereInput | CourseTagScalarWhereInput[]
  }

  export type CourseModuleUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseModuleCreateWithoutCourseInput, CourseModuleUncheckedCreateWithoutCourseInput> | CourseModuleCreateWithoutCourseInput[] | CourseModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseModuleCreateOrConnectWithoutCourseInput | CourseModuleCreateOrConnectWithoutCourseInput[]
    upsert?: CourseModuleUpsertWithWhereUniqueWithoutCourseInput | CourseModuleUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseModuleCreateManyCourseInputEnvelope
    set?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    disconnect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    delete?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    connect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    update?: CourseModuleUpdateWithWhereUniqueWithoutCourseInput | CourseModuleUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseModuleUpdateManyWithWhereWithoutCourseInput | CourseModuleUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseModuleScalarWhereInput | CourseModuleScalarWhereInput[]
  }

  export type CourseSkillCreateNestedManyWithoutSkillInput = {
    create?: XOR<CourseSkillCreateWithoutSkillInput, CourseSkillUncheckedCreateWithoutSkillInput> | CourseSkillCreateWithoutSkillInput[] | CourseSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: CourseSkillCreateOrConnectWithoutSkillInput | CourseSkillCreateOrConnectWithoutSkillInput[]
    createMany?: CourseSkillCreateManySkillInputEnvelope
    connect?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
  }

  export type UserSkillProficiencyCreateNestedManyWithoutSkillInput = {
    create?: XOR<UserSkillProficiencyCreateWithoutSkillInput, UserSkillProficiencyUncheckedCreateWithoutSkillInput> | UserSkillProficiencyCreateWithoutSkillInput[] | UserSkillProficiencyUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: UserSkillProficiencyCreateOrConnectWithoutSkillInput | UserSkillProficiencyCreateOrConnectWithoutSkillInput[]
    createMany?: UserSkillProficiencyCreateManySkillInputEnvelope
    connect?: UserSkillProficiencyWhereUniqueInput | UserSkillProficiencyWhereUniqueInput[]
  }

  export type SkillPrerequisiteCreateNestedManyWithoutPrerequisiteSkillInput = {
    create?: XOR<SkillPrerequisiteCreateWithoutPrerequisiteSkillInput, SkillPrerequisiteUncheckedCreateWithoutPrerequisiteSkillInput> | SkillPrerequisiteCreateWithoutPrerequisiteSkillInput[] | SkillPrerequisiteUncheckedCreateWithoutPrerequisiteSkillInput[]
    connectOrCreate?: SkillPrerequisiteCreateOrConnectWithoutPrerequisiteSkillInput | SkillPrerequisiteCreateOrConnectWithoutPrerequisiteSkillInput[]
    createMany?: SkillPrerequisiteCreateManyPrerequisiteSkillInputEnvelope
    connect?: SkillPrerequisiteWhereUniqueInput | SkillPrerequisiteWhereUniqueInput[]
  }

  export type SkillPrerequisiteCreateNestedManyWithoutSkillInput = {
    create?: XOR<SkillPrerequisiteCreateWithoutSkillInput, SkillPrerequisiteUncheckedCreateWithoutSkillInput> | SkillPrerequisiteCreateWithoutSkillInput[] | SkillPrerequisiteUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: SkillPrerequisiteCreateOrConnectWithoutSkillInput | SkillPrerequisiteCreateOrConnectWithoutSkillInput[]
    createMany?: SkillPrerequisiteCreateManySkillInputEnvelope
    connect?: SkillPrerequisiteWhereUniqueInput | SkillPrerequisiteWhereUniqueInput[]
  }

  export type ReviewSkillRatingCreateNestedManyWithoutSkillInput = {
    create?: XOR<ReviewSkillRatingCreateWithoutSkillInput, ReviewSkillRatingUncheckedCreateWithoutSkillInput> | ReviewSkillRatingCreateWithoutSkillInput[] | ReviewSkillRatingUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: ReviewSkillRatingCreateOrConnectWithoutSkillInput | ReviewSkillRatingCreateOrConnectWithoutSkillInput[]
    createMany?: ReviewSkillRatingCreateManySkillInputEnvelope
    connect?: ReviewSkillRatingWhereUniqueInput | ReviewSkillRatingWhereUniqueInput[]
  }

  export type CourseSkillUncheckedCreateNestedManyWithoutSkillInput = {
    create?: XOR<CourseSkillCreateWithoutSkillInput, CourseSkillUncheckedCreateWithoutSkillInput> | CourseSkillCreateWithoutSkillInput[] | CourseSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: CourseSkillCreateOrConnectWithoutSkillInput | CourseSkillCreateOrConnectWithoutSkillInput[]
    createMany?: CourseSkillCreateManySkillInputEnvelope
    connect?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
  }

  export type UserSkillProficiencyUncheckedCreateNestedManyWithoutSkillInput = {
    create?: XOR<UserSkillProficiencyCreateWithoutSkillInput, UserSkillProficiencyUncheckedCreateWithoutSkillInput> | UserSkillProficiencyCreateWithoutSkillInput[] | UserSkillProficiencyUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: UserSkillProficiencyCreateOrConnectWithoutSkillInput | UserSkillProficiencyCreateOrConnectWithoutSkillInput[]
    createMany?: UserSkillProficiencyCreateManySkillInputEnvelope
    connect?: UserSkillProficiencyWhereUniqueInput | UserSkillProficiencyWhereUniqueInput[]
  }

  export type SkillPrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteSkillInput = {
    create?: XOR<SkillPrerequisiteCreateWithoutPrerequisiteSkillInput, SkillPrerequisiteUncheckedCreateWithoutPrerequisiteSkillInput> | SkillPrerequisiteCreateWithoutPrerequisiteSkillInput[] | SkillPrerequisiteUncheckedCreateWithoutPrerequisiteSkillInput[]
    connectOrCreate?: SkillPrerequisiteCreateOrConnectWithoutPrerequisiteSkillInput | SkillPrerequisiteCreateOrConnectWithoutPrerequisiteSkillInput[]
    createMany?: SkillPrerequisiteCreateManyPrerequisiteSkillInputEnvelope
    connect?: SkillPrerequisiteWhereUniqueInput | SkillPrerequisiteWhereUniqueInput[]
  }

  export type SkillPrerequisiteUncheckedCreateNestedManyWithoutSkillInput = {
    create?: XOR<SkillPrerequisiteCreateWithoutSkillInput, SkillPrerequisiteUncheckedCreateWithoutSkillInput> | SkillPrerequisiteCreateWithoutSkillInput[] | SkillPrerequisiteUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: SkillPrerequisiteCreateOrConnectWithoutSkillInput | SkillPrerequisiteCreateOrConnectWithoutSkillInput[]
    createMany?: SkillPrerequisiteCreateManySkillInputEnvelope
    connect?: SkillPrerequisiteWhereUniqueInput | SkillPrerequisiteWhereUniqueInput[]
  }

  export type ReviewSkillRatingUncheckedCreateNestedManyWithoutSkillInput = {
    create?: XOR<ReviewSkillRatingCreateWithoutSkillInput, ReviewSkillRatingUncheckedCreateWithoutSkillInput> | ReviewSkillRatingCreateWithoutSkillInput[] | ReviewSkillRatingUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: ReviewSkillRatingCreateOrConnectWithoutSkillInput | ReviewSkillRatingCreateOrConnectWithoutSkillInput[]
    createMany?: ReviewSkillRatingCreateManySkillInputEnvelope
    connect?: ReviewSkillRatingWhereUniqueInput | ReviewSkillRatingWhereUniqueInput[]
  }

  export type CourseSkillUpdateManyWithoutSkillNestedInput = {
    create?: XOR<CourseSkillCreateWithoutSkillInput, CourseSkillUncheckedCreateWithoutSkillInput> | CourseSkillCreateWithoutSkillInput[] | CourseSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: CourseSkillCreateOrConnectWithoutSkillInput | CourseSkillCreateOrConnectWithoutSkillInput[]
    upsert?: CourseSkillUpsertWithWhereUniqueWithoutSkillInput | CourseSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: CourseSkillCreateManySkillInputEnvelope
    set?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
    disconnect?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
    delete?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
    connect?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
    update?: CourseSkillUpdateWithWhereUniqueWithoutSkillInput | CourseSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: CourseSkillUpdateManyWithWhereWithoutSkillInput | CourseSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: CourseSkillScalarWhereInput | CourseSkillScalarWhereInput[]
  }

  export type UserSkillProficiencyUpdateManyWithoutSkillNestedInput = {
    create?: XOR<UserSkillProficiencyCreateWithoutSkillInput, UserSkillProficiencyUncheckedCreateWithoutSkillInput> | UserSkillProficiencyCreateWithoutSkillInput[] | UserSkillProficiencyUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: UserSkillProficiencyCreateOrConnectWithoutSkillInput | UserSkillProficiencyCreateOrConnectWithoutSkillInput[]
    upsert?: UserSkillProficiencyUpsertWithWhereUniqueWithoutSkillInput | UserSkillProficiencyUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: UserSkillProficiencyCreateManySkillInputEnvelope
    set?: UserSkillProficiencyWhereUniqueInput | UserSkillProficiencyWhereUniqueInput[]
    disconnect?: UserSkillProficiencyWhereUniqueInput | UserSkillProficiencyWhereUniqueInput[]
    delete?: UserSkillProficiencyWhereUniqueInput | UserSkillProficiencyWhereUniqueInput[]
    connect?: UserSkillProficiencyWhereUniqueInput | UserSkillProficiencyWhereUniqueInput[]
    update?: UserSkillProficiencyUpdateWithWhereUniqueWithoutSkillInput | UserSkillProficiencyUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: UserSkillProficiencyUpdateManyWithWhereWithoutSkillInput | UserSkillProficiencyUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: UserSkillProficiencyScalarWhereInput | UserSkillProficiencyScalarWhereInput[]
  }

  export type SkillPrerequisiteUpdateManyWithoutPrerequisiteSkillNestedInput = {
    create?: XOR<SkillPrerequisiteCreateWithoutPrerequisiteSkillInput, SkillPrerequisiteUncheckedCreateWithoutPrerequisiteSkillInput> | SkillPrerequisiteCreateWithoutPrerequisiteSkillInput[] | SkillPrerequisiteUncheckedCreateWithoutPrerequisiteSkillInput[]
    connectOrCreate?: SkillPrerequisiteCreateOrConnectWithoutPrerequisiteSkillInput | SkillPrerequisiteCreateOrConnectWithoutPrerequisiteSkillInput[]
    upsert?: SkillPrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteSkillInput | SkillPrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteSkillInput[]
    createMany?: SkillPrerequisiteCreateManyPrerequisiteSkillInputEnvelope
    set?: SkillPrerequisiteWhereUniqueInput | SkillPrerequisiteWhereUniqueInput[]
    disconnect?: SkillPrerequisiteWhereUniqueInput | SkillPrerequisiteWhereUniqueInput[]
    delete?: SkillPrerequisiteWhereUniqueInput | SkillPrerequisiteWhereUniqueInput[]
    connect?: SkillPrerequisiteWhereUniqueInput | SkillPrerequisiteWhereUniqueInput[]
    update?: SkillPrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteSkillInput | SkillPrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteSkillInput[]
    updateMany?: SkillPrerequisiteUpdateManyWithWhereWithoutPrerequisiteSkillInput | SkillPrerequisiteUpdateManyWithWhereWithoutPrerequisiteSkillInput[]
    deleteMany?: SkillPrerequisiteScalarWhereInput | SkillPrerequisiteScalarWhereInput[]
  }

  export type SkillPrerequisiteUpdateManyWithoutSkillNestedInput = {
    create?: XOR<SkillPrerequisiteCreateWithoutSkillInput, SkillPrerequisiteUncheckedCreateWithoutSkillInput> | SkillPrerequisiteCreateWithoutSkillInput[] | SkillPrerequisiteUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: SkillPrerequisiteCreateOrConnectWithoutSkillInput | SkillPrerequisiteCreateOrConnectWithoutSkillInput[]
    upsert?: SkillPrerequisiteUpsertWithWhereUniqueWithoutSkillInput | SkillPrerequisiteUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: SkillPrerequisiteCreateManySkillInputEnvelope
    set?: SkillPrerequisiteWhereUniqueInput | SkillPrerequisiteWhereUniqueInput[]
    disconnect?: SkillPrerequisiteWhereUniqueInput | SkillPrerequisiteWhereUniqueInput[]
    delete?: SkillPrerequisiteWhereUniqueInput | SkillPrerequisiteWhereUniqueInput[]
    connect?: SkillPrerequisiteWhereUniqueInput | SkillPrerequisiteWhereUniqueInput[]
    update?: SkillPrerequisiteUpdateWithWhereUniqueWithoutSkillInput | SkillPrerequisiteUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: SkillPrerequisiteUpdateManyWithWhereWithoutSkillInput | SkillPrerequisiteUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: SkillPrerequisiteScalarWhereInput | SkillPrerequisiteScalarWhereInput[]
  }

  export type ReviewSkillRatingUpdateManyWithoutSkillNestedInput = {
    create?: XOR<ReviewSkillRatingCreateWithoutSkillInput, ReviewSkillRatingUncheckedCreateWithoutSkillInput> | ReviewSkillRatingCreateWithoutSkillInput[] | ReviewSkillRatingUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: ReviewSkillRatingCreateOrConnectWithoutSkillInput | ReviewSkillRatingCreateOrConnectWithoutSkillInput[]
    upsert?: ReviewSkillRatingUpsertWithWhereUniqueWithoutSkillInput | ReviewSkillRatingUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: ReviewSkillRatingCreateManySkillInputEnvelope
    set?: ReviewSkillRatingWhereUniqueInput | ReviewSkillRatingWhereUniqueInput[]
    disconnect?: ReviewSkillRatingWhereUniqueInput | ReviewSkillRatingWhereUniqueInput[]
    delete?: ReviewSkillRatingWhereUniqueInput | ReviewSkillRatingWhereUniqueInput[]
    connect?: ReviewSkillRatingWhereUniqueInput | ReviewSkillRatingWhereUniqueInput[]
    update?: ReviewSkillRatingUpdateWithWhereUniqueWithoutSkillInput | ReviewSkillRatingUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: ReviewSkillRatingUpdateManyWithWhereWithoutSkillInput | ReviewSkillRatingUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: ReviewSkillRatingScalarWhereInput | ReviewSkillRatingScalarWhereInput[]
  }

  export type CourseSkillUncheckedUpdateManyWithoutSkillNestedInput = {
    create?: XOR<CourseSkillCreateWithoutSkillInput, CourseSkillUncheckedCreateWithoutSkillInput> | CourseSkillCreateWithoutSkillInput[] | CourseSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: CourseSkillCreateOrConnectWithoutSkillInput | CourseSkillCreateOrConnectWithoutSkillInput[]
    upsert?: CourseSkillUpsertWithWhereUniqueWithoutSkillInput | CourseSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: CourseSkillCreateManySkillInputEnvelope
    set?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
    disconnect?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
    delete?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
    connect?: CourseSkillWhereUniqueInput | CourseSkillWhereUniqueInput[]
    update?: CourseSkillUpdateWithWhereUniqueWithoutSkillInput | CourseSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: CourseSkillUpdateManyWithWhereWithoutSkillInput | CourseSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: CourseSkillScalarWhereInput | CourseSkillScalarWhereInput[]
  }

  export type UserSkillProficiencyUncheckedUpdateManyWithoutSkillNestedInput = {
    create?: XOR<UserSkillProficiencyCreateWithoutSkillInput, UserSkillProficiencyUncheckedCreateWithoutSkillInput> | UserSkillProficiencyCreateWithoutSkillInput[] | UserSkillProficiencyUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: UserSkillProficiencyCreateOrConnectWithoutSkillInput | UserSkillProficiencyCreateOrConnectWithoutSkillInput[]
    upsert?: UserSkillProficiencyUpsertWithWhereUniqueWithoutSkillInput | UserSkillProficiencyUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: UserSkillProficiencyCreateManySkillInputEnvelope
    set?: UserSkillProficiencyWhereUniqueInput | UserSkillProficiencyWhereUniqueInput[]
    disconnect?: UserSkillProficiencyWhereUniqueInput | UserSkillProficiencyWhereUniqueInput[]
    delete?: UserSkillProficiencyWhereUniqueInput | UserSkillProficiencyWhereUniqueInput[]
    connect?: UserSkillProficiencyWhereUniqueInput | UserSkillProficiencyWhereUniqueInput[]
    update?: UserSkillProficiencyUpdateWithWhereUniqueWithoutSkillInput | UserSkillProficiencyUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: UserSkillProficiencyUpdateManyWithWhereWithoutSkillInput | UserSkillProficiencyUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: UserSkillProficiencyScalarWhereInput | UserSkillProficiencyScalarWhereInput[]
  }

  export type SkillPrerequisiteUncheckedUpdateManyWithoutPrerequisiteSkillNestedInput = {
    create?: XOR<SkillPrerequisiteCreateWithoutPrerequisiteSkillInput, SkillPrerequisiteUncheckedCreateWithoutPrerequisiteSkillInput> | SkillPrerequisiteCreateWithoutPrerequisiteSkillInput[] | SkillPrerequisiteUncheckedCreateWithoutPrerequisiteSkillInput[]
    connectOrCreate?: SkillPrerequisiteCreateOrConnectWithoutPrerequisiteSkillInput | SkillPrerequisiteCreateOrConnectWithoutPrerequisiteSkillInput[]
    upsert?: SkillPrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteSkillInput | SkillPrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteSkillInput[]
    createMany?: SkillPrerequisiteCreateManyPrerequisiteSkillInputEnvelope
    set?: SkillPrerequisiteWhereUniqueInput | SkillPrerequisiteWhereUniqueInput[]
    disconnect?: SkillPrerequisiteWhereUniqueInput | SkillPrerequisiteWhereUniqueInput[]
    delete?: SkillPrerequisiteWhereUniqueInput | SkillPrerequisiteWhereUniqueInput[]
    connect?: SkillPrerequisiteWhereUniqueInput | SkillPrerequisiteWhereUniqueInput[]
    update?: SkillPrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteSkillInput | SkillPrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteSkillInput[]
    updateMany?: SkillPrerequisiteUpdateManyWithWhereWithoutPrerequisiteSkillInput | SkillPrerequisiteUpdateManyWithWhereWithoutPrerequisiteSkillInput[]
    deleteMany?: SkillPrerequisiteScalarWhereInput | SkillPrerequisiteScalarWhereInput[]
  }

  export type SkillPrerequisiteUncheckedUpdateManyWithoutSkillNestedInput = {
    create?: XOR<SkillPrerequisiteCreateWithoutSkillInput, SkillPrerequisiteUncheckedCreateWithoutSkillInput> | SkillPrerequisiteCreateWithoutSkillInput[] | SkillPrerequisiteUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: SkillPrerequisiteCreateOrConnectWithoutSkillInput | SkillPrerequisiteCreateOrConnectWithoutSkillInput[]
    upsert?: SkillPrerequisiteUpsertWithWhereUniqueWithoutSkillInput | SkillPrerequisiteUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: SkillPrerequisiteCreateManySkillInputEnvelope
    set?: SkillPrerequisiteWhereUniqueInput | SkillPrerequisiteWhereUniqueInput[]
    disconnect?: SkillPrerequisiteWhereUniqueInput | SkillPrerequisiteWhereUniqueInput[]
    delete?: SkillPrerequisiteWhereUniqueInput | SkillPrerequisiteWhereUniqueInput[]
    connect?: SkillPrerequisiteWhereUniqueInput | SkillPrerequisiteWhereUniqueInput[]
    update?: SkillPrerequisiteUpdateWithWhereUniqueWithoutSkillInput | SkillPrerequisiteUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: SkillPrerequisiteUpdateManyWithWhereWithoutSkillInput | SkillPrerequisiteUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: SkillPrerequisiteScalarWhereInput | SkillPrerequisiteScalarWhereInput[]
  }

  export type ReviewSkillRatingUncheckedUpdateManyWithoutSkillNestedInput = {
    create?: XOR<ReviewSkillRatingCreateWithoutSkillInput, ReviewSkillRatingUncheckedCreateWithoutSkillInput> | ReviewSkillRatingCreateWithoutSkillInput[] | ReviewSkillRatingUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: ReviewSkillRatingCreateOrConnectWithoutSkillInput | ReviewSkillRatingCreateOrConnectWithoutSkillInput[]
    upsert?: ReviewSkillRatingUpsertWithWhereUniqueWithoutSkillInput | ReviewSkillRatingUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: ReviewSkillRatingCreateManySkillInputEnvelope
    set?: ReviewSkillRatingWhereUniqueInput | ReviewSkillRatingWhereUniqueInput[]
    disconnect?: ReviewSkillRatingWhereUniqueInput | ReviewSkillRatingWhereUniqueInput[]
    delete?: ReviewSkillRatingWhereUniqueInput | ReviewSkillRatingWhereUniqueInput[]
    connect?: ReviewSkillRatingWhereUniqueInput | ReviewSkillRatingWhereUniqueInput[]
    update?: ReviewSkillRatingUpdateWithWhereUniqueWithoutSkillInput | ReviewSkillRatingUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: ReviewSkillRatingUpdateManyWithWhereWithoutSkillInput | ReviewSkillRatingUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: ReviewSkillRatingScalarWhereInput | ReviewSkillRatingScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutSkillsInput = {
    create?: XOR<CourseCreateWithoutSkillsInput, CourseUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutSkillsInput
    connect?: CourseWhereUniqueInput
  }

  export type SkillCreateNestedOneWithoutCoursesInput = {
    create?: XOR<SkillCreateWithoutCoursesInput, SkillUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: SkillCreateOrConnectWithoutCoursesInput
    connect?: SkillWhereUniqueInput
  }

  export type EnumSkillLevelFieldUpdateOperationsInput = {
    set?: $Enums.SkillLevel
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CourseUpdateOneRequiredWithoutSkillsNestedInput = {
    create?: XOR<CourseCreateWithoutSkillsInput, CourseUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutSkillsInput
    upsert?: CourseUpsertWithoutSkillsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutSkillsInput, CourseUpdateWithoutSkillsInput>, CourseUncheckedUpdateWithoutSkillsInput>
  }

  export type SkillUpdateOneRequiredWithoutCoursesNestedInput = {
    create?: XOR<SkillCreateWithoutCoursesInput, SkillUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: SkillCreateOrConnectWithoutCoursesInput
    upsert?: SkillUpsertWithoutCoursesInput
    connect?: SkillWhereUniqueInput
    update?: XOR<XOR<SkillUpdateToOneWithWhereWithoutCoursesInput, SkillUpdateWithoutCoursesInput>, SkillUncheckedUpdateWithoutCoursesInput>
  }

  export type ReviewCreateprosInput = {
    set: string[]
  }

  export type ReviewCreateconsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutReviewsInput = {
    create?: XOR<CourseCreateWithoutReviewsInput, CourseUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutReviewsInput
    connect?: CourseWhereUniqueInput
  }

  export type ReviewVoteCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewVoteCreateWithoutReviewInput, ReviewVoteUncheckedCreateWithoutReviewInput> | ReviewVoteCreateWithoutReviewInput[] | ReviewVoteUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewVoteCreateOrConnectWithoutReviewInput | ReviewVoteCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewVoteCreateManyReviewInputEnvelope
    connect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
  }

  export type ReviewHelpfulVoteCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewHelpfulVoteCreateWithoutReviewInput, ReviewHelpfulVoteUncheckedCreateWithoutReviewInput> | ReviewHelpfulVoteCreateWithoutReviewInput[] | ReviewHelpfulVoteUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewHelpfulVoteCreateOrConnectWithoutReviewInput | ReviewHelpfulVoteCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewHelpfulVoteCreateManyReviewInputEnvelope
    connect?: ReviewHelpfulVoteWhereUniqueInput | ReviewHelpfulVoteWhereUniqueInput[]
  }

  export type ReviewSkillRatingCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewSkillRatingCreateWithoutReviewInput, ReviewSkillRatingUncheckedCreateWithoutReviewInput> | ReviewSkillRatingCreateWithoutReviewInput[] | ReviewSkillRatingUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewSkillRatingCreateOrConnectWithoutReviewInput | ReviewSkillRatingCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewSkillRatingCreateManyReviewInputEnvelope
    connect?: ReviewSkillRatingWhereUniqueInput | ReviewSkillRatingWhereUniqueInput[]
  }

  export type ReviewVoteUncheckedCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewVoteCreateWithoutReviewInput, ReviewVoteUncheckedCreateWithoutReviewInput> | ReviewVoteCreateWithoutReviewInput[] | ReviewVoteUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewVoteCreateOrConnectWithoutReviewInput | ReviewVoteCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewVoteCreateManyReviewInputEnvelope
    connect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
  }

  export type ReviewHelpfulVoteUncheckedCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewHelpfulVoteCreateWithoutReviewInput, ReviewHelpfulVoteUncheckedCreateWithoutReviewInput> | ReviewHelpfulVoteCreateWithoutReviewInput[] | ReviewHelpfulVoteUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewHelpfulVoteCreateOrConnectWithoutReviewInput | ReviewHelpfulVoteCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewHelpfulVoteCreateManyReviewInputEnvelope
    connect?: ReviewHelpfulVoteWhereUniqueInput | ReviewHelpfulVoteWhereUniqueInput[]
  }

  export type ReviewSkillRatingUncheckedCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewSkillRatingCreateWithoutReviewInput, ReviewSkillRatingUncheckedCreateWithoutReviewInput> | ReviewSkillRatingCreateWithoutReviewInput[] | ReviewSkillRatingUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewSkillRatingCreateOrConnectWithoutReviewInput | ReviewSkillRatingCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewSkillRatingCreateManyReviewInputEnvelope
    connect?: ReviewSkillRatingWhereUniqueInput | ReviewSkillRatingWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type ReviewUpdateprosInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ReviewUpdateconsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsInput, UserUpdateWithoutReviewsInput>, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type CourseUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<CourseCreateWithoutReviewsInput, CourseUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutReviewsInput
    upsert?: CourseUpsertWithoutReviewsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutReviewsInput, CourseUpdateWithoutReviewsInput>, CourseUncheckedUpdateWithoutReviewsInput>
  }

  export type ReviewVoteUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewVoteCreateWithoutReviewInput, ReviewVoteUncheckedCreateWithoutReviewInput> | ReviewVoteCreateWithoutReviewInput[] | ReviewVoteUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewVoteCreateOrConnectWithoutReviewInput | ReviewVoteCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewVoteUpsertWithWhereUniqueWithoutReviewInput | ReviewVoteUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewVoteCreateManyReviewInputEnvelope
    set?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    disconnect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    delete?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    connect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    update?: ReviewVoteUpdateWithWhereUniqueWithoutReviewInput | ReviewVoteUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewVoteUpdateManyWithWhereWithoutReviewInput | ReviewVoteUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewVoteScalarWhereInput | ReviewVoteScalarWhereInput[]
  }

  export type ReviewHelpfulVoteUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewHelpfulVoteCreateWithoutReviewInput, ReviewHelpfulVoteUncheckedCreateWithoutReviewInput> | ReviewHelpfulVoteCreateWithoutReviewInput[] | ReviewHelpfulVoteUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewHelpfulVoteCreateOrConnectWithoutReviewInput | ReviewHelpfulVoteCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewHelpfulVoteUpsertWithWhereUniqueWithoutReviewInput | ReviewHelpfulVoteUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewHelpfulVoteCreateManyReviewInputEnvelope
    set?: ReviewHelpfulVoteWhereUniqueInput | ReviewHelpfulVoteWhereUniqueInput[]
    disconnect?: ReviewHelpfulVoteWhereUniqueInput | ReviewHelpfulVoteWhereUniqueInput[]
    delete?: ReviewHelpfulVoteWhereUniqueInput | ReviewHelpfulVoteWhereUniqueInput[]
    connect?: ReviewHelpfulVoteWhereUniqueInput | ReviewHelpfulVoteWhereUniqueInput[]
    update?: ReviewHelpfulVoteUpdateWithWhereUniqueWithoutReviewInput | ReviewHelpfulVoteUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewHelpfulVoteUpdateManyWithWhereWithoutReviewInput | ReviewHelpfulVoteUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewHelpfulVoteScalarWhereInput | ReviewHelpfulVoteScalarWhereInput[]
  }

  export type ReviewSkillRatingUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewSkillRatingCreateWithoutReviewInput, ReviewSkillRatingUncheckedCreateWithoutReviewInput> | ReviewSkillRatingCreateWithoutReviewInput[] | ReviewSkillRatingUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewSkillRatingCreateOrConnectWithoutReviewInput | ReviewSkillRatingCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewSkillRatingUpsertWithWhereUniqueWithoutReviewInput | ReviewSkillRatingUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewSkillRatingCreateManyReviewInputEnvelope
    set?: ReviewSkillRatingWhereUniqueInput | ReviewSkillRatingWhereUniqueInput[]
    disconnect?: ReviewSkillRatingWhereUniqueInput | ReviewSkillRatingWhereUniqueInput[]
    delete?: ReviewSkillRatingWhereUniqueInput | ReviewSkillRatingWhereUniqueInput[]
    connect?: ReviewSkillRatingWhereUniqueInput | ReviewSkillRatingWhereUniqueInput[]
    update?: ReviewSkillRatingUpdateWithWhereUniqueWithoutReviewInput | ReviewSkillRatingUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewSkillRatingUpdateManyWithWhereWithoutReviewInput | ReviewSkillRatingUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewSkillRatingScalarWhereInput | ReviewSkillRatingScalarWhereInput[]
  }

  export type ReviewVoteUncheckedUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewVoteCreateWithoutReviewInput, ReviewVoteUncheckedCreateWithoutReviewInput> | ReviewVoteCreateWithoutReviewInput[] | ReviewVoteUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewVoteCreateOrConnectWithoutReviewInput | ReviewVoteCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewVoteUpsertWithWhereUniqueWithoutReviewInput | ReviewVoteUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewVoteCreateManyReviewInputEnvelope
    set?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    disconnect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    delete?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    connect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    update?: ReviewVoteUpdateWithWhereUniqueWithoutReviewInput | ReviewVoteUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewVoteUpdateManyWithWhereWithoutReviewInput | ReviewVoteUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewVoteScalarWhereInput | ReviewVoteScalarWhereInput[]
  }

  export type ReviewHelpfulVoteUncheckedUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewHelpfulVoteCreateWithoutReviewInput, ReviewHelpfulVoteUncheckedCreateWithoutReviewInput> | ReviewHelpfulVoteCreateWithoutReviewInput[] | ReviewHelpfulVoteUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewHelpfulVoteCreateOrConnectWithoutReviewInput | ReviewHelpfulVoteCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewHelpfulVoteUpsertWithWhereUniqueWithoutReviewInput | ReviewHelpfulVoteUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewHelpfulVoteCreateManyReviewInputEnvelope
    set?: ReviewHelpfulVoteWhereUniqueInput | ReviewHelpfulVoteWhereUniqueInput[]
    disconnect?: ReviewHelpfulVoteWhereUniqueInput | ReviewHelpfulVoteWhereUniqueInput[]
    delete?: ReviewHelpfulVoteWhereUniqueInput | ReviewHelpfulVoteWhereUniqueInput[]
    connect?: ReviewHelpfulVoteWhereUniqueInput | ReviewHelpfulVoteWhereUniqueInput[]
    update?: ReviewHelpfulVoteUpdateWithWhereUniqueWithoutReviewInput | ReviewHelpfulVoteUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewHelpfulVoteUpdateManyWithWhereWithoutReviewInput | ReviewHelpfulVoteUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewHelpfulVoteScalarWhereInput | ReviewHelpfulVoteScalarWhereInput[]
  }

  export type ReviewSkillRatingUncheckedUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewSkillRatingCreateWithoutReviewInput, ReviewSkillRatingUncheckedCreateWithoutReviewInput> | ReviewSkillRatingCreateWithoutReviewInput[] | ReviewSkillRatingUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewSkillRatingCreateOrConnectWithoutReviewInput | ReviewSkillRatingCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewSkillRatingUpsertWithWhereUniqueWithoutReviewInput | ReviewSkillRatingUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewSkillRatingCreateManyReviewInputEnvelope
    set?: ReviewSkillRatingWhereUniqueInput | ReviewSkillRatingWhereUniqueInput[]
    disconnect?: ReviewSkillRatingWhereUniqueInput | ReviewSkillRatingWhereUniqueInput[]
    delete?: ReviewSkillRatingWhereUniqueInput | ReviewSkillRatingWhereUniqueInput[]
    connect?: ReviewSkillRatingWhereUniqueInput | ReviewSkillRatingWhereUniqueInput[]
    update?: ReviewSkillRatingUpdateWithWhereUniqueWithoutReviewInput | ReviewSkillRatingUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewSkillRatingUpdateManyWithWhereWithoutReviewInput | ReviewSkillRatingUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewSkillRatingScalarWhereInput | ReviewSkillRatingScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutReviewVotesInput = {
    create?: XOR<UserCreateWithoutReviewVotesInput, UserUncheckedCreateWithoutReviewVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewVotesInput
    connect?: UserWhereUniqueInput
  }

  export type ReviewCreateNestedOneWithoutVotesInput = {
    create?: XOR<ReviewCreateWithoutVotesInput, ReviewUncheckedCreateWithoutVotesInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutVotesInput
    connect?: ReviewWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReviewVotesNestedInput = {
    create?: XOR<UserCreateWithoutReviewVotesInput, UserUncheckedCreateWithoutReviewVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewVotesInput
    upsert?: UserUpsertWithoutReviewVotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewVotesInput, UserUpdateWithoutReviewVotesInput>, UserUncheckedUpdateWithoutReviewVotesInput>
  }

  export type ReviewUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<ReviewCreateWithoutVotesInput, ReviewUncheckedCreateWithoutVotesInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutVotesInput
    upsert?: ReviewUpsertWithoutVotesInput
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutVotesInput, ReviewUpdateWithoutVotesInput>, ReviewUncheckedUpdateWithoutVotesInput>
  }

  export type UserCreateNestedOneWithoutReviewHelpfulVotesInput = {
    create?: XOR<UserCreateWithoutReviewHelpfulVotesInput, UserUncheckedCreateWithoutReviewHelpfulVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewHelpfulVotesInput
    connect?: UserWhereUniqueInput
  }

  export type ReviewCreateNestedOneWithoutHelpfulVotesInput = {
    create?: XOR<ReviewCreateWithoutHelpfulVotesInput, ReviewUncheckedCreateWithoutHelpfulVotesInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutHelpfulVotesInput
    connect?: ReviewWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReviewHelpfulVotesNestedInput = {
    create?: XOR<UserCreateWithoutReviewHelpfulVotesInput, UserUncheckedCreateWithoutReviewHelpfulVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewHelpfulVotesInput
    upsert?: UserUpsertWithoutReviewHelpfulVotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewHelpfulVotesInput, UserUpdateWithoutReviewHelpfulVotesInput>, UserUncheckedUpdateWithoutReviewHelpfulVotesInput>
  }

  export type ReviewUpdateOneRequiredWithoutHelpfulVotesNestedInput = {
    create?: XOR<ReviewCreateWithoutHelpfulVotesInput, ReviewUncheckedCreateWithoutHelpfulVotesInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutHelpfulVotesInput
    upsert?: ReviewUpsertWithoutHelpfulVotesInput
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutHelpfulVotesInput, ReviewUpdateWithoutHelpfulVotesInput>, ReviewUncheckedUpdateWithoutHelpfulVotesInput>
  }

  export type ReviewCreateNestedOneWithoutSkillRatingsInput = {
    create?: XOR<ReviewCreateWithoutSkillRatingsInput, ReviewUncheckedCreateWithoutSkillRatingsInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutSkillRatingsInput
    connect?: ReviewWhereUniqueInput
  }

  export type SkillCreateNestedOneWithoutReviewRatingsInput = {
    create?: XOR<SkillCreateWithoutReviewRatingsInput, SkillUncheckedCreateWithoutReviewRatingsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutReviewRatingsInput
    connect?: SkillWhereUniqueInput
  }

  export type ReviewUpdateOneRequiredWithoutSkillRatingsNestedInput = {
    create?: XOR<ReviewCreateWithoutSkillRatingsInput, ReviewUncheckedCreateWithoutSkillRatingsInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutSkillRatingsInput
    upsert?: ReviewUpsertWithoutSkillRatingsInput
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutSkillRatingsInput, ReviewUpdateWithoutSkillRatingsInput>, ReviewUncheckedUpdateWithoutSkillRatingsInput>
  }

  export type SkillUpdateOneRequiredWithoutReviewRatingsNestedInput = {
    create?: XOR<SkillCreateWithoutReviewRatingsInput, SkillUncheckedCreateWithoutReviewRatingsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutReviewRatingsInput
    upsert?: SkillUpsertWithoutReviewRatingsInput
    connect?: SkillWhereUniqueInput
    update?: XOR<XOR<SkillUpdateToOneWithWhereWithoutReviewRatingsInput, SkillUpdateWithoutReviewRatingsInput>, SkillUncheckedUpdateWithoutReviewRatingsInput>
  }

  export type UserCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<UserCreateWithoutEnrollmentsInput, UserUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEnrollmentsInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutEnrollmentsInput
    connect?: CourseWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<UserCreateWithoutEnrollmentsInput, UserUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEnrollmentsInput
    upsert?: UserUpsertWithoutEnrollmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEnrollmentsInput, UserUpdateWithoutEnrollmentsInput>, UserUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type CourseUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutEnrollmentsInput
    upsert?: CourseUpsertWithoutEnrollmentsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutEnrollmentsInput, CourseUpdateWithoutEnrollmentsInput>, CourseUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type UserCreateNestedOneWithoutSkillProficienciesInput = {
    create?: XOR<UserCreateWithoutSkillProficienciesInput, UserUncheckedCreateWithoutSkillProficienciesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSkillProficienciesInput
    connect?: UserWhereUniqueInput
  }

  export type SkillCreateNestedOneWithoutUserProficienciesInput = {
    create?: XOR<SkillCreateWithoutUserProficienciesInput, SkillUncheckedCreateWithoutUserProficienciesInput>
    connectOrCreate?: SkillCreateOrConnectWithoutUserProficienciesInput
    connect?: SkillWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSkillProficienciesNestedInput = {
    create?: XOR<UserCreateWithoutSkillProficienciesInput, UserUncheckedCreateWithoutSkillProficienciesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSkillProficienciesInput
    upsert?: UserUpsertWithoutSkillProficienciesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSkillProficienciesInput, UserUpdateWithoutSkillProficienciesInput>, UserUncheckedUpdateWithoutSkillProficienciesInput>
  }

  export type SkillUpdateOneRequiredWithoutUserProficienciesNestedInput = {
    create?: XOR<SkillCreateWithoutUserProficienciesInput, SkillUncheckedCreateWithoutUserProficienciesInput>
    connectOrCreate?: SkillCreateOrConnectWithoutUserProficienciesInput
    upsert?: SkillUpsertWithoutUserProficienciesInput
    connect?: SkillWhereUniqueInput
    update?: XOR<XOR<SkillUpdateToOneWithWhereWithoutUserProficienciesInput, SkillUpdateWithoutUserProficienciesInput>, SkillUncheckedUpdateWithoutUserProficienciesInput>
  }

  export type SkillCreateNestedOneWithoutPrerequisitesInput = {
    create?: XOR<SkillCreateWithoutPrerequisitesInput, SkillUncheckedCreateWithoutPrerequisitesInput>
    connectOrCreate?: SkillCreateOrConnectWithoutPrerequisitesInput
    connect?: SkillWhereUniqueInput
  }

  export type SkillCreateNestedOneWithoutPrerequisiteForInput = {
    create?: XOR<SkillCreateWithoutPrerequisiteForInput, SkillUncheckedCreateWithoutPrerequisiteForInput>
    connectOrCreate?: SkillCreateOrConnectWithoutPrerequisiteForInput
    connect?: SkillWhereUniqueInput
  }

  export type SkillUpdateOneRequiredWithoutPrerequisitesNestedInput = {
    create?: XOR<SkillCreateWithoutPrerequisitesInput, SkillUncheckedCreateWithoutPrerequisitesInput>
    connectOrCreate?: SkillCreateOrConnectWithoutPrerequisitesInput
    upsert?: SkillUpsertWithoutPrerequisitesInput
    connect?: SkillWhereUniqueInput
    update?: XOR<XOR<SkillUpdateToOneWithWhereWithoutPrerequisitesInput, SkillUpdateWithoutPrerequisitesInput>, SkillUncheckedUpdateWithoutPrerequisitesInput>
  }

  export type SkillUpdateOneRequiredWithoutPrerequisiteForNestedInput = {
    create?: XOR<SkillCreateWithoutPrerequisiteForInput, SkillUncheckedCreateWithoutPrerequisiteForInput>
    connectOrCreate?: SkillCreateOrConnectWithoutPrerequisiteForInput
    upsert?: SkillUpsertWithoutPrerequisiteForInput
    connect?: SkillWhereUniqueInput
    update?: XOR<XOR<SkillUpdateToOneWithWhereWithoutPrerequisiteForInput, SkillUpdateWithoutPrerequisiteForInput>, SkillUncheckedUpdateWithoutPrerequisiteForInput>
  }

  export type CategoryCreateNestedOneWithoutChildrenInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    connect?: CategoryWhereUniqueInput
  }

  export type CategoryCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type CourseCategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<CourseCategoryCreateWithoutCategoryInput, CourseCategoryUncheckedCreateWithoutCategoryInput> | CourseCategoryCreateWithoutCategoryInput[] | CourseCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CourseCategoryCreateOrConnectWithoutCategoryInput | CourseCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: CourseCategoryCreateManyCategoryInputEnvelope
    connect?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type CourseCategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<CourseCategoryCreateWithoutCategoryInput, CourseCategoryUncheckedCreateWithoutCategoryInput> | CourseCategoryCreateWithoutCategoryInput[] | CourseCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CourseCategoryCreateOrConnectWithoutCategoryInput | CourseCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: CourseCategoryCreateManyCategoryInputEnvelope
    connect?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[]
  }

  export type CategoryUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    upsert?: CategoryUpsertWithoutChildrenInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutChildrenInput, CategoryUpdateWithoutChildrenInput>, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type CategoryUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type CourseCategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<CourseCategoryCreateWithoutCategoryInput, CourseCategoryUncheckedCreateWithoutCategoryInput> | CourseCategoryCreateWithoutCategoryInput[] | CourseCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CourseCategoryCreateOrConnectWithoutCategoryInput | CourseCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: CourseCategoryUpsertWithWhereUniqueWithoutCategoryInput | CourseCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: CourseCategoryCreateManyCategoryInputEnvelope
    set?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[]
    disconnect?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[]
    delete?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[]
    connect?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[]
    update?: CourseCategoryUpdateWithWhereUniqueWithoutCategoryInput | CourseCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: CourseCategoryUpdateManyWithWhereWithoutCategoryInput | CourseCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: CourseCategoryScalarWhereInput | CourseCategoryScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type CourseCategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<CourseCategoryCreateWithoutCategoryInput, CourseCategoryUncheckedCreateWithoutCategoryInput> | CourseCategoryCreateWithoutCategoryInput[] | CourseCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CourseCategoryCreateOrConnectWithoutCategoryInput | CourseCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: CourseCategoryUpsertWithWhereUniqueWithoutCategoryInput | CourseCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: CourseCategoryCreateManyCategoryInputEnvelope
    set?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[]
    disconnect?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[]
    delete?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[]
    connect?: CourseCategoryWhereUniqueInput | CourseCategoryWhereUniqueInput[]
    update?: CourseCategoryUpdateWithWhereUniqueWithoutCategoryInput | CourseCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: CourseCategoryUpdateManyWithWhereWithoutCategoryInput | CourseCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: CourseCategoryScalarWhereInput | CourseCategoryScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<CourseCreateWithoutCategoriesInput, CourseUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCategoriesInput
    connect?: CourseWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutCoursesInput = {
    create?: XOR<CategoryCreateWithoutCoursesInput, CategoryUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutCoursesInput
    connect?: CategoryWhereUniqueInput
  }

  export type CourseUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<CourseCreateWithoutCategoriesInput, CourseUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCategoriesInput
    upsert?: CourseUpsertWithoutCategoriesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutCategoriesInput, CourseUpdateWithoutCategoriesInput>, CourseUncheckedUpdateWithoutCategoriesInput>
  }

  export type CategoryUpdateOneRequiredWithoutCoursesNestedInput = {
    create?: XOR<CategoryCreateWithoutCoursesInput, CategoryUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutCoursesInput
    upsert?: CategoryUpsertWithoutCoursesInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutCoursesInput, CategoryUpdateWithoutCoursesInput>, CategoryUncheckedUpdateWithoutCoursesInput>
  }

  export type CourseTagCreateNestedManyWithoutTagInput = {
    create?: XOR<CourseTagCreateWithoutTagInput, CourseTagUncheckedCreateWithoutTagInput> | CourseTagCreateWithoutTagInput[] | CourseTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: CourseTagCreateOrConnectWithoutTagInput | CourseTagCreateOrConnectWithoutTagInput[]
    createMany?: CourseTagCreateManyTagInputEnvelope
    connect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
  }

  export type CourseTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<CourseTagCreateWithoutTagInput, CourseTagUncheckedCreateWithoutTagInput> | CourseTagCreateWithoutTagInput[] | CourseTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: CourseTagCreateOrConnectWithoutTagInput | CourseTagCreateOrConnectWithoutTagInput[]
    createMany?: CourseTagCreateManyTagInputEnvelope
    connect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
  }

  export type CourseTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<CourseTagCreateWithoutTagInput, CourseTagUncheckedCreateWithoutTagInput> | CourseTagCreateWithoutTagInput[] | CourseTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: CourseTagCreateOrConnectWithoutTagInput | CourseTagCreateOrConnectWithoutTagInput[]
    upsert?: CourseTagUpsertWithWhereUniqueWithoutTagInput | CourseTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: CourseTagCreateManyTagInputEnvelope
    set?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    disconnect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    delete?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    connect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    update?: CourseTagUpdateWithWhereUniqueWithoutTagInput | CourseTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: CourseTagUpdateManyWithWhereWithoutTagInput | CourseTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: CourseTagScalarWhereInput | CourseTagScalarWhereInput[]
  }

  export type CourseTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<CourseTagCreateWithoutTagInput, CourseTagUncheckedCreateWithoutTagInput> | CourseTagCreateWithoutTagInput[] | CourseTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: CourseTagCreateOrConnectWithoutTagInput | CourseTagCreateOrConnectWithoutTagInput[]
    upsert?: CourseTagUpsertWithWhereUniqueWithoutTagInput | CourseTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: CourseTagCreateManyTagInputEnvelope
    set?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    disconnect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    delete?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    connect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    update?: CourseTagUpdateWithWhereUniqueWithoutTagInput | CourseTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: CourseTagUpdateManyWithWhereWithoutTagInput | CourseTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: CourseTagScalarWhereInput | CourseTagScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutTagsInput = {
    create?: XOR<CourseCreateWithoutTagsInput, CourseUncheckedCreateWithoutTagsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutTagsInput
    connect?: CourseWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutCoursesInput = {
    create?: XOR<TagCreateWithoutCoursesInput, TagUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: TagCreateOrConnectWithoutCoursesInput
    connect?: TagWhereUniqueInput
  }

  export type CourseUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<CourseCreateWithoutTagsInput, CourseUncheckedCreateWithoutTagsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutTagsInput
    upsert?: CourseUpsertWithoutTagsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutTagsInput, CourseUpdateWithoutTagsInput>, CourseUncheckedUpdateWithoutTagsInput>
  }

  export type TagUpdateOneRequiredWithoutCoursesNestedInput = {
    create?: XOR<TagCreateWithoutCoursesInput, TagUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: TagCreateOrConnectWithoutCoursesInput
    upsert?: TagUpsertWithoutCoursesInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutCoursesInput, TagUpdateWithoutCoursesInput>, TagUncheckedUpdateWithoutCoursesInput>
  }

  export type CourseCreateNestedOneWithoutModulesInput = {
    create?: XOR<CourseCreateWithoutModulesInput, CourseUncheckedCreateWithoutModulesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutModulesInput
    connect?: CourseWhereUniqueInput
  }

  export type CourseUpdateOneRequiredWithoutModulesNestedInput = {
    create?: XOR<CourseCreateWithoutModulesInput, CourseUncheckedCreateWithoutModulesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutModulesInput
    upsert?: CourseUpsertWithoutModulesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutModulesInput, CourseUpdateWithoutModulesInput>, CourseUncheckedUpdateWithoutModulesInput>
  }

  export type UserAchievementCreateNestedManyWithoutAchievementInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type UserAchievementUncheckedCreateNestedManyWithoutAchievementInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type EnumAchievementTypeFieldUpdateOperationsInput = {
    set?: $Enums.AchievementType
  }

  export type UserAchievementUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutAchievementInput | UserAchievementUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutAchievementInput | UserAchievementUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutAchievementInput | UserAchievementUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type UserAchievementUncheckedUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutAchievementInput | UserAchievementUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutAchievementInput | UserAchievementUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutAchievementInput | UserAchievementUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    connect?: UserWhereUniqueInput
  }

  export type AchievementCreateNestedOneWithoutUsersInput = {
    create?: XOR<AchievementCreateWithoutUsersInput, AchievementUncheckedCreateWithoutUsersInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutUsersInput
    connect?: AchievementWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAchievementsNestedInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    upsert?: UserUpsertWithoutAchievementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAchievementsInput, UserUpdateWithoutAchievementsInput>, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type AchievementUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<AchievementCreateWithoutUsersInput, AchievementUncheckedCreateWithoutUsersInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutUsersInput
    upsert?: AchievementUpsertWithoutUsersInput
    connect?: AchievementWhereUniqueInput
    update?: XOR<XOR<AchievementUpdateToOneWithWhereWithoutUsersInput, AchievementUpdateWithoutUsersInput>, AchievementUncheckedUpdateWithoutUsersInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type ProgressReportCreateskillsLearnedInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutProgressReportsInput = {
    create?: XOR<UserCreateWithoutProgressReportsInput, UserUncheckedCreateWithoutProgressReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProgressReportsInput
    connect?: UserWhereUniqueInput
  }

  export type ProgressReportUpdateskillsLearnedInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutProgressReportsNestedInput = {
    create?: XOR<UserCreateWithoutProgressReportsInput, UserUncheckedCreateWithoutProgressReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProgressReportsInput
    upsert?: UserUpsertWithoutProgressReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProgressReportsInput, UserUpdateWithoutProgressReportsInput>, UserUncheckedUpdateWithoutProgressReportsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumDifficultyFilter<$PrismaModel = never> = {
    equals?: $Enums.Difficulty | EnumDifficultyFieldRefInput<$PrismaModel>
    in?: $Enums.Difficulty[] | ListEnumDifficultyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Difficulty[] | ListEnumDifficultyFieldRefInput<$PrismaModel>
    not?: NestedEnumDifficultyFilter<$PrismaModel> | $Enums.Difficulty
  }

  export type NestedEnumCourseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseStatus | EnumCourseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseStatusFilter<$PrismaModel> | $Enums.CourseStatus
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumDifficultyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Difficulty | EnumDifficultyFieldRefInput<$PrismaModel>
    in?: $Enums.Difficulty[] | ListEnumDifficultyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Difficulty[] | ListEnumDifficultyFieldRefInput<$PrismaModel>
    not?: NestedEnumDifficultyWithAggregatesFilter<$PrismaModel> | $Enums.Difficulty
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDifficultyFilter<$PrismaModel>
    _max?: NestedEnumDifficultyFilter<$PrismaModel>
  }

  export type NestedEnumCourseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseStatus | EnumCourseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseStatusWithAggregatesFilter<$PrismaModel> | $Enums.CourseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseStatusFilter<$PrismaModel>
    _max?: NestedEnumCourseStatusFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumSkillLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.SkillLevel | EnumSkillLevelFieldRefInput<$PrismaModel>
    in?: $Enums.SkillLevel[] | ListEnumSkillLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.SkillLevel[] | ListEnumSkillLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillLevelFilter<$PrismaModel> | $Enums.SkillLevel
  }

  export type NestedEnumSkillLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SkillLevel | EnumSkillLevelFieldRefInput<$PrismaModel>
    in?: $Enums.SkillLevel[] | ListEnumSkillLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.SkillLevel[] | ListEnumSkillLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillLevelWithAggregatesFilter<$PrismaModel> | $Enums.SkillLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSkillLevelFilter<$PrismaModel>
    _max?: NestedEnumSkillLevelFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumAchievementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementType | EnumAchievementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementType[] | ListEnumAchievementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementType[] | ListEnumAchievementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementTypeFilter<$PrismaModel> | $Enums.AchievementType
  }

  export type NestedEnumAchievementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementType | EnumAchievementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementType[] | ListEnumAchievementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementType[] | ListEnumAchievementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementTypeWithAggregatesFilter<$PrismaModel> | $Enums.AchievementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAchievementTypeFilter<$PrismaModel>
    _max?: NestedEnumAchievementTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ReviewCreateWithoutUserInput = {
    id?: string
    overallRating: number
    difficultyRating?: number | null
    contentQuality?: number | null
    instructorRating?: number | null
    valueForMoney?: number | null
    wouldRecommend?: boolean | null
    title: string
    content: string
    pros?: ReviewCreateprosInput | string[]
    cons?: ReviewCreateconsInput | string[]
    isAnonymous?: boolean
    isVerified?: boolean
    helpfulCount?: number
    flagCount?: number
    isHidden?: boolean
    moderatorNotes?: string | null
    completionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutReviewsInput
    votes?: ReviewVoteCreateNestedManyWithoutReviewInput
    helpfulVotes?: ReviewHelpfulVoteCreateNestedManyWithoutReviewInput
    skillRatings?: ReviewSkillRatingCreateNestedManyWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutUserInput = {
    id?: string
    courseId: string
    overallRating: number
    difficultyRating?: number | null
    contentQuality?: number | null
    instructorRating?: number | null
    valueForMoney?: number | null
    wouldRecommend?: boolean | null
    title: string
    content: string
    pros?: ReviewCreateprosInput | string[]
    cons?: ReviewCreateconsInput | string[]
    isAnonymous?: boolean
    isVerified?: boolean
    helpfulCount?: number
    flagCount?: number
    isHidden?: boolean
    moderatorNotes?: string | null
    completionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: ReviewVoteUncheckedCreateNestedManyWithoutReviewInput
    helpfulVotes?: ReviewHelpfulVoteUncheckedCreateNestedManyWithoutReviewInput
    skillRatings?: ReviewSkillRatingUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewVoteCreateWithoutUserInput = {
    id?: string
    isUpvote: boolean
    createdAt?: Date | string
    review: ReviewCreateNestedOneWithoutVotesInput
  }

  export type ReviewVoteUncheckedCreateWithoutUserInput = {
    id?: string
    reviewId: string
    isUpvote: boolean
    createdAt?: Date | string
  }

  export type ReviewVoteCreateOrConnectWithoutUserInput = {
    where: ReviewVoteWhereUniqueInput
    create: XOR<ReviewVoteCreateWithoutUserInput, ReviewVoteUncheckedCreateWithoutUserInput>
  }

  export type ReviewVoteCreateManyUserInputEnvelope = {
    data: ReviewVoteCreateManyUserInput | ReviewVoteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CourseEnrollmentCreateWithoutUserInput = {
    id?: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    progress?: number
    lastAccessed?: Date | string
    status?: string
    certificateUrl?: string | null
    course: CourseCreateNestedOneWithoutEnrollmentsInput
  }

  export type CourseEnrollmentUncheckedCreateWithoutUserInput = {
    id?: string
    courseId: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    progress?: number
    lastAccessed?: Date | string
    status?: string
    certificateUrl?: string | null
  }

  export type CourseEnrollmentCreateOrConnectWithoutUserInput = {
    where: CourseEnrollmentWhereUniqueInput
    create: XOR<CourseEnrollmentCreateWithoutUserInput, CourseEnrollmentUncheckedCreateWithoutUserInput>
  }

  export type CourseEnrollmentCreateManyUserInputEnvelope = {
    data: CourseEnrollmentCreateManyUserInput | CourseEnrollmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserAchievementCreateWithoutUserInput = {
    id?: string
    earnedAt?: Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
    achievement: AchievementCreateNestedOneWithoutUsersInput
  }

  export type UserAchievementUncheckedCreateWithoutUserInput = {
    id?: string
    achievementId: string
    earnedAt?: Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserAchievementCreateOrConnectWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    create: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput>
  }

  export type UserAchievementCreateManyUserInputEnvelope = {
    data: UserAchievementCreateManyUserInput | UserAchievementCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type: string
    isRead?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type: string
    isRead?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CourseCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description: string
    shortDescription?: string | null
    imageUrl?: string | null
    thumbnailUrl?: string | null
    courseUrl: string
    instructor: string
    institution?: string | null
    duration?: string | null
    difficulty: $Enums.Difficulty
    status?: $Enums.CourseStatus
    price?: Decimal | DecimalJsLike | number | string | null
    isFree?: boolean
    language?: string
    rating?: Decimal | DecimalJsLike | number | string | null
    reviewCount?: number
    enrollmentCount?: number
    isActive?: boolean
    prerequisites?: CourseCreateprerequisitesInput | string[]
    learningOutcomes?: CourseCreatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewCreateNestedManyWithoutCourseInput
    skills?: CourseSkillCreateNestedManyWithoutCourseInput
    enrollments?: CourseEnrollmentCreateNestedManyWithoutCourseInput
    categories?: CourseCategoryCreateNestedManyWithoutCourseInput
    tags?: CourseTagCreateNestedManyWithoutCourseInput
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description: string
    shortDescription?: string | null
    imageUrl?: string | null
    thumbnailUrl?: string | null
    courseUrl: string
    instructor: string
    institution?: string | null
    duration?: string | null
    difficulty: $Enums.Difficulty
    status?: $Enums.CourseStatus
    price?: Decimal | DecimalJsLike | number | string | null
    isFree?: boolean
    language?: string
    rating?: Decimal | DecimalJsLike | number | string | null
    reviewCount?: number
    enrollmentCount?: number
    isActive?: boolean
    prerequisites?: CourseCreateprerequisitesInput | string[]
    learningOutcomes?: CourseCreatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewUncheckedCreateNestedManyWithoutCourseInput
    skills?: CourseSkillUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutCourseInput
    categories?: CourseCategoryUncheckedCreateNestedManyWithoutCourseInput
    tags?: CourseTagUncheckedCreateNestedManyWithoutCourseInput
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCreatedByInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCreatedByInput, CourseUncheckedCreateWithoutCreatedByInput>
  }

  export type CourseCreateManyCreatedByInputEnvelope = {
    data: CourseCreateManyCreatedByInput | CourseCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type UserSkillProficiencyCreateWithoutUserInput = {
    id?: string
    level: $Enums.SkillLevel
    yearsExperience?: number | null
    lastUsed?: Date | string | null
    isVerified?: boolean
    verificationSource?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skill: SkillCreateNestedOneWithoutUserProficienciesInput
  }

  export type UserSkillProficiencyUncheckedCreateWithoutUserInput = {
    id?: string
    skillId: string
    level: $Enums.SkillLevel
    yearsExperience?: number | null
    lastUsed?: Date | string | null
    isVerified?: boolean
    verificationSource?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSkillProficiencyCreateOrConnectWithoutUserInput = {
    where: UserSkillProficiencyWhereUniqueInput
    create: XOR<UserSkillProficiencyCreateWithoutUserInput, UserSkillProficiencyUncheckedCreateWithoutUserInput>
  }

  export type UserSkillProficiencyCreateManyUserInputEnvelope = {
    data: UserSkillProficiencyCreateManyUserInput | UserSkillProficiencyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewHelpfulVoteCreateWithoutUserInput = {
    id?: string
    isHelpful: boolean
    createdAt?: Date | string
    review: ReviewCreateNestedOneWithoutHelpfulVotesInput
  }

  export type ReviewHelpfulVoteUncheckedCreateWithoutUserInput = {
    id?: string
    reviewId: string
    isHelpful: boolean
    createdAt?: Date | string
  }

  export type ReviewHelpfulVoteCreateOrConnectWithoutUserInput = {
    where: ReviewHelpfulVoteWhereUniqueInput
    create: XOR<ReviewHelpfulVoteCreateWithoutUserInput, ReviewHelpfulVoteUncheckedCreateWithoutUserInput>
  }

  export type ReviewHelpfulVoteCreateManyUserInputEnvelope = {
    data: ReviewHelpfulVoteCreateManyUserInput | ReviewHelpfulVoteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProgressReportCreateWithoutUserInput = {
    id?: string
    reportDate?: Date | string
    coursesCompleted?: number
    reviewsWritten?: number
    pointsEarned?: number
    skillsLearned?: ProgressReportCreateskillsLearnedInput | string[]
    weeklyGoalMet?: boolean
    monthlyGoalMet?: boolean
  }

  export type ProgressReportUncheckedCreateWithoutUserInput = {
    id?: string
    reportDate?: Date | string
    coursesCompleted?: number
    reviewsWritten?: number
    pointsEarned?: number
    skillsLearned?: ProgressReportCreateskillsLearnedInput | string[]
    weeklyGoalMet?: boolean
    monthlyGoalMet?: boolean
  }

  export type ProgressReportCreateOrConnectWithoutUserInput = {
    where: ProgressReportWhereUniqueInput
    create: XOR<ProgressReportCreateWithoutUserInput, ProgressReportUncheckedCreateWithoutUserInput>
  }

  export type ProgressReportCreateManyUserInputEnvelope = {
    data: ProgressReportCreateManyUserInput | ProgressReportCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: StringFilter<"Review"> | string
    userId?: StringFilter<"Review"> | string
    courseId?: StringFilter<"Review"> | string
    overallRating?: IntFilter<"Review"> | number
    difficultyRating?: IntNullableFilter<"Review"> | number | null
    contentQuality?: IntNullableFilter<"Review"> | number | null
    instructorRating?: IntNullableFilter<"Review"> | number | null
    valueForMoney?: IntNullableFilter<"Review"> | number | null
    wouldRecommend?: BoolNullableFilter<"Review"> | boolean | null
    title?: StringFilter<"Review"> | string
    content?: StringFilter<"Review"> | string
    pros?: StringNullableListFilter<"Review">
    cons?: StringNullableListFilter<"Review">
    isAnonymous?: BoolFilter<"Review"> | boolean
    isVerified?: BoolFilter<"Review"> | boolean
    helpfulCount?: IntFilter<"Review"> | number
    flagCount?: IntFilter<"Review"> | number
    isHidden?: BoolFilter<"Review"> | boolean
    moderatorNotes?: StringNullableFilter<"Review"> | string | null
    completionDate?: DateTimeNullableFilter<"Review"> | Date | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
  }

  export type ReviewVoteUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewVoteWhereUniqueInput
    update: XOR<ReviewVoteUpdateWithoutUserInput, ReviewVoteUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewVoteCreateWithoutUserInput, ReviewVoteUncheckedCreateWithoutUserInput>
  }

  export type ReviewVoteUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewVoteWhereUniqueInput
    data: XOR<ReviewVoteUpdateWithoutUserInput, ReviewVoteUncheckedUpdateWithoutUserInput>
  }

  export type ReviewVoteUpdateManyWithWhereWithoutUserInput = {
    where: ReviewVoteScalarWhereInput
    data: XOR<ReviewVoteUpdateManyMutationInput, ReviewVoteUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewVoteScalarWhereInput = {
    AND?: ReviewVoteScalarWhereInput | ReviewVoteScalarWhereInput[]
    OR?: ReviewVoteScalarWhereInput[]
    NOT?: ReviewVoteScalarWhereInput | ReviewVoteScalarWhereInput[]
    id?: StringFilter<"ReviewVote"> | string
    userId?: StringFilter<"ReviewVote"> | string
    reviewId?: StringFilter<"ReviewVote"> | string
    isUpvote?: BoolFilter<"ReviewVote"> | boolean
    createdAt?: DateTimeFilter<"ReviewVote"> | Date | string
  }

  export type CourseEnrollmentUpsertWithWhereUniqueWithoutUserInput = {
    where: CourseEnrollmentWhereUniqueInput
    update: XOR<CourseEnrollmentUpdateWithoutUserInput, CourseEnrollmentUncheckedUpdateWithoutUserInput>
    create: XOR<CourseEnrollmentCreateWithoutUserInput, CourseEnrollmentUncheckedCreateWithoutUserInput>
  }

  export type CourseEnrollmentUpdateWithWhereUniqueWithoutUserInput = {
    where: CourseEnrollmentWhereUniqueInput
    data: XOR<CourseEnrollmentUpdateWithoutUserInput, CourseEnrollmentUncheckedUpdateWithoutUserInput>
  }

  export type CourseEnrollmentUpdateManyWithWhereWithoutUserInput = {
    where: CourseEnrollmentScalarWhereInput
    data: XOR<CourseEnrollmentUpdateManyMutationInput, CourseEnrollmentUncheckedUpdateManyWithoutUserInput>
  }

  export type CourseEnrollmentScalarWhereInput = {
    AND?: CourseEnrollmentScalarWhereInput | CourseEnrollmentScalarWhereInput[]
    OR?: CourseEnrollmentScalarWhereInput[]
    NOT?: CourseEnrollmentScalarWhereInput | CourseEnrollmentScalarWhereInput[]
    id?: StringFilter<"CourseEnrollment"> | string
    userId?: StringFilter<"CourseEnrollment"> | string
    courseId?: StringFilter<"CourseEnrollment"> | string
    enrolledAt?: DateTimeFilter<"CourseEnrollment"> | Date | string
    completedAt?: DateTimeNullableFilter<"CourseEnrollment"> | Date | string | null
    progress?: IntFilter<"CourseEnrollment"> | number
    lastAccessed?: DateTimeFilter<"CourseEnrollment"> | Date | string
    status?: StringFilter<"CourseEnrollment"> | string
    certificateUrl?: StringNullableFilter<"CourseEnrollment"> | string | null
  }

  export type UserAchievementUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    update: XOR<UserAchievementUpdateWithoutUserInput, UserAchievementUncheckedUpdateWithoutUserInput>
    create: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput>
  }

  export type UserAchievementUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    data: XOR<UserAchievementUpdateWithoutUserInput, UserAchievementUncheckedUpdateWithoutUserInput>
  }

  export type UserAchievementUpdateManyWithWhereWithoutUserInput = {
    where: UserAchievementScalarWhereInput
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAchievementScalarWhereInput = {
    AND?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
    OR?: UserAchievementScalarWhereInput[]
    NOT?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
    id?: StringFilter<"UserAchievement"> | string
    userId?: StringFilter<"UserAchievement"> | string
    achievementId?: StringFilter<"UserAchievement"> | string
    earnedAt?: DateTimeFilter<"UserAchievement"> | Date | string
    progress?: JsonNullableFilter<"UserAchievement">
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    data?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
  }

  export type CourseUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutCreatedByInput, CourseUncheckedUpdateWithoutCreatedByInput>
    create: XOR<CourseCreateWithoutCreatedByInput, CourseUncheckedCreateWithoutCreatedByInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutCreatedByInput, CourseUncheckedUpdateWithoutCreatedByInput>
  }

  export type CourseUpdateManyWithWhereWithoutCreatedByInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type CourseScalarWhereInput = {
    AND?: CourseScalarWhereInput | CourseScalarWhereInput[]
    OR?: CourseScalarWhereInput[]
    NOT?: CourseScalarWhereInput | CourseScalarWhereInput[]
    id?: StringFilter<"Course"> | string
    title?: StringFilter<"Course"> | string
    description?: StringFilter<"Course"> | string
    shortDescription?: StringNullableFilter<"Course"> | string | null
    imageUrl?: StringNullableFilter<"Course"> | string | null
    thumbnailUrl?: StringNullableFilter<"Course"> | string | null
    courseUrl?: StringFilter<"Course"> | string
    instructor?: StringFilter<"Course"> | string
    institution?: StringNullableFilter<"Course"> | string | null
    duration?: StringNullableFilter<"Course"> | string | null
    difficulty?: EnumDifficultyFilter<"Course"> | $Enums.Difficulty
    status?: EnumCourseStatusFilter<"Course"> | $Enums.CourseStatus
    price?: DecimalNullableFilter<"Course"> | Decimal | DecimalJsLike | number | string | null
    isFree?: BoolFilter<"Course"> | boolean
    language?: StringFilter<"Course"> | string
    rating?: DecimalNullableFilter<"Course"> | Decimal | DecimalJsLike | number | string | null
    reviewCount?: IntFilter<"Course"> | number
    enrollmentCount?: IntFilter<"Course"> | number
    isActive?: BoolFilter<"Course"> | boolean
    prerequisites?: StringNullableListFilter<"Course">
    learningOutcomes?: StringNullableListFilter<"Course">
    syllabus?: JsonNullableFilter<"Course">
    lastUpdated?: DateTimeNullableFilter<"Course"> | Date | string | null
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    createdById?: StringFilter<"Course"> | string
  }

  export type UserSkillProficiencyUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSkillProficiencyWhereUniqueInput
    update: XOR<UserSkillProficiencyUpdateWithoutUserInput, UserSkillProficiencyUncheckedUpdateWithoutUserInput>
    create: XOR<UserSkillProficiencyCreateWithoutUserInput, UserSkillProficiencyUncheckedCreateWithoutUserInput>
  }

  export type UserSkillProficiencyUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSkillProficiencyWhereUniqueInput
    data: XOR<UserSkillProficiencyUpdateWithoutUserInput, UserSkillProficiencyUncheckedUpdateWithoutUserInput>
  }

  export type UserSkillProficiencyUpdateManyWithWhereWithoutUserInput = {
    where: UserSkillProficiencyScalarWhereInput
    data: XOR<UserSkillProficiencyUpdateManyMutationInput, UserSkillProficiencyUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSkillProficiencyScalarWhereInput = {
    AND?: UserSkillProficiencyScalarWhereInput | UserSkillProficiencyScalarWhereInput[]
    OR?: UserSkillProficiencyScalarWhereInput[]
    NOT?: UserSkillProficiencyScalarWhereInput | UserSkillProficiencyScalarWhereInput[]
    id?: StringFilter<"UserSkillProficiency"> | string
    userId?: StringFilter<"UserSkillProficiency"> | string
    skillId?: StringFilter<"UserSkillProficiency"> | string
    level?: EnumSkillLevelFilter<"UserSkillProficiency"> | $Enums.SkillLevel
    yearsExperience?: IntNullableFilter<"UserSkillProficiency"> | number | null
    lastUsed?: DateTimeNullableFilter<"UserSkillProficiency"> | Date | string | null
    isVerified?: BoolFilter<"UserSkillProficiency"> | boolean
    verificationSource?: StringNullableFilter<"UserSkillProficiency"> | string | null
    createdAt?: DateTimeFilter<"UserSkillProficiency"> | Date | string
    updatedAt?: DateTimeFilter<"UserSkillProficiency"> | Date | string
  }

  export type ReviewHelpfulVoteUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewHelpfulVoteWhereUniqueInput
    update: XOR<ReviewHelpfulVoteUpdateWithoutUserInput, ReviewHelpfulVoteUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewHelpfulVoteCreateWithoutUserInput, ReviewHelpfulVoteUncheckedCreateWithoutUserInput>
  }

  export type ReviewHelpfulVoteUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewHelpfulVoteWhereUniqueInput
    data: XOR<ReviewHelpfulVoteUpdateWithoutUserInput, ReviewHelpfulVoteUncheckedUpdateWithoutUserInput>
  }

  export type ReviewHelpfulVoteUpdateManyWithWhereWithoutUserInput = {
    where: ReviewHelpfulVoteScalarWhereInput
    data: XOR<ReviewHelpfulVoteUpdateManyMutationInput, ReviewHelpfulVoteUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewHelpfulVoteScalarWhereInput = {
    AND?: ReviewHelpfulVoteScalarWhereInput | ReviewHelpfulVoteScalarWhereInput[]
    OR?: ReviewHelpfulVoteScalarWhereInput[]
    NOT?: ReviewHelpfulVoteScalarWhereInput | ReviewHelpfulVoteScalarWhereInput[]
    id?: StringFilter<"ReviewHelpfulVote"> | string
    userId?: StringFilter<"ReviewHelpfulVote"> | string
    reviewId?: StringFilter<"ReviewHelpfulVote"> | string
    isHelpful?: BoolFilter<"ReviewHelpfulVote"> | boolean
    createdAt?: DateTimeFilter<"ReviewHelpfulVote"> | Date | string
  }

  export type ProgressReportUpsertWithWhereUniqueWithoutUserInput = {
    where: ProgressReportWhereUniqueInput
    update: XOR<ProgressReportUpdateWithoutUserInput, ProgressReportUncheckedUpdateWithoutUserInput>
    create: XOR<ProgressReportCreateWithoutUserInput, ProgressReportUncheckedCreateWithoutUserInput>
  }

  export type ProgressReportUpdateWithWhereUniqueWithoutUserInput = {
    where: ProgressReportWhereUniqueInput
    data: XOR<ProgressReportUpdateWithoutUserInput, ProgressReportUncheckedUpdateWithoutUserInput>
  }

  export type ProgressReportUpdateManyWithWhereWithoutUserInput = {
    where: ProgressReportScalarWhereInput
    data: XOR<ProgressReportUpdateManyMutationInput, ProgressReportUncheckedUpdateManyWithoutUserInput>
  }

  export type ProgressReportScalarWhereInput = {
    AND?: ProgressReportScalarWhereInput | ProgressReportScalarWhereInput[]
    OR?: ProgressReportScalarWhereInput[]
    NOT?: ProgressReportScalarWhereInput | ProgressReportScalarWhereInput[]
    id?: StringFilter<"ProgressReport"> | string
    userId?: StringFilter<"ProgressReport"> | string
    reportDate?: DateTimeFilter<"ProgressReport"> | Date | string
    coursesCompleted?: IntFilter<"ProgressReport"> | number
    reviewsWritten?: IntFilter<"ProgressReport"> | number
    pointsEarned?: IntFilter<"ProgressReport"> | number
    skillsLearned?: StringNullableListFilter<"ProgressReport">
    weeklyGoalMet?: BoolFilter<"ProgressReport"> | boolean
    monthlyGoalMet?: BoolFilter<"ProgressReport"> | boolean
  }

  export type UserCreateWithoutCoursesInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    profileImage?: string | null
    bio?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationToken?: string | null
    passwordHash: string
    totalPoints?: number
    reviewStreak?: number
    lastActiveAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    enrollments?: CourseEnrollmentCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    skillProficiencies?: UserSkillProficiencyCreateNestedManyWithoutUserInput
    reviewHelpfulVotes?: ReviewHelpfulVoteCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCoursesInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    profileImage?: string | null
    bio?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationToken?: string | null
    passwordHash: string
    totalPoints?: number
    reviewStreak?: number
    lastActiveAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    skillProficiencies?: UserSkillProficiencyUncheckedCreateNestedManyWithoutUserInput
    reviewHelpfulVotes?: ReviewHelpfulVoteUncheckedCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCoursesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
  }

  export type ReviewCreateWithoutCourseInput = {
    id?: string
    overallRating: number
    difficultyRating?: number | null
    contentQuality?: number | null
    instructorRating?: number | null
    valueForMoney?: number | null
    wouldRecommend?: boolean | null
    title: string
    content: string
    pros?: ReviewCreateprosInput | string[]
    cons?: ReviewCreateconsInput | string[]
    isAnonymous?: boolean
    isVerified?: boolean
    helpfulCount?: number
    flagCount?: number
    isHidden?: boolean
    moderatorNotes?: string | null
    completionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
    votes?: ReviewVoteCreateNestedManyWithoutReviewInput
    helpfulVotes?: ReviewHelpfulVoteCreateNestedManyWithoutReviewInput
    skillRatings?: ReviewSkillRatingCreateNestedManyWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutCourseInput = {
    id?: string
    userId: string
    overallRating: number
    difficultyRating?: number | null
    contentQuality?: number | null
    instructorRating?: number | null
    valueForMoney?: number | null
    wouldRecommend?: boolean | null
    title: string
    content: string
    pros?: ReviewCreateprosInput | string[]
    cons?: ReviewCreateconsInput | string[]
    isAnonymous?: boolean
    isVerified?: boolean
    helpfulCount?: number
    flagCount?: number
    isHidden?: boolean
    moderatorNotes?: string | null
    completionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: ReviewVoteUncheckedCreateNestedManyWithoutReviewInput
    helpfulVotes?: ReviewHelpfulVoteUncheckedCreateNestedManyWithoutReviewInput
    skillRatings?: ReviewSkillRatingUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewCreateOrConnectWithoutCourseInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutCourseInput, ReviewUncheckedCreateWithoutCourseInput>
  }

  export type ReviewCreateManyCourseInputEnvelope = {
    data: ReviewCreateManyCourseInput | ReviewCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseSkillCreateWithoutCourseInput = {
    id?: string
    level?: $Enums.SkillLevel
    isCore?: boolean
    percentage?: number | null
    createdAt?: Date | string
    skill: SkillCreateNestedOneWithoutCoursesInput
  }

  export type CourseSkillUncheckedCreateWithoutCourseInput = {
    id?: string
    skillId: string
    level?: $Enums.SkillLevel
    isCore?: boolean
    percentage?: number | null
    createdAt?: Date | string
  }

  export type CourseSkillCreateOrConnectWithoutCourseInput = {
    where: CourseSkillWhereUniqueInput
    create: XOR<CourseSkillCreateWithoutCourseInput, CourseSkillUncheckedCreateWithoutCourseInput>
  }

  export type CourseSkillCreateManyCourseInputEnvelope = {
    data: CourseSkillCreateManyCourseInput | CourseSkillCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseEnrollmentCreateWithoutCourseInput = {
    id?: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    progress?: number
    lastAccessed?: Date | string
    status?: string
    certificateUrl?: string | null
    user: UserCreateNestedOneWithoutEnrollmentsInput
  }

  export type CourseEnrollmentUncheckedCreateWithoutCourseInput = {
    id?: string
    userId: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    progress?: number
    lastAccessed?: Date | string
    status?: string
    certificateUrl?: string | null
  }

  export type CourseEnrollmentCreateOrConnectWithoutCourseInput = {
    where: CourseEnrollmentWhereUniqueInput
    create: XOR<CourseEnrollmentCreateWithoutCourseInput, CourseEnrollmentUncheckedCreateWithoutCourseInput>
  }

  export type CourseEnrollmentCreateManyCourseInputEnvelope = {
    data: CourseEnrollmentCreateManyCourseInput | CourseEnrollmentCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseCategoryCreateWithoutCourseInput = {
    id?: string
    isPrimary?: boolean
    category: CategoryCreateNestedOneWithoutCoursesInput
  }

  export type CourseCategoryUncheckedCreateWithoutCourseInput = {
    id?: string
    categoryId: string
    isPrimary?: boolean
  }

  export type CourseCategoryCreateOrConnectWithoutCourseInput = {
    where: CourseCategoryWhereUniqueInput
    create: XOR<CourseCategoryCreateWithoutCourseInput, CourseCategoryUncheckedCreateWithoutCourseInput>
  }

  export type CourseCategoryCreateManyCourseInputEnvelope = {
    data: CourseCategoryCreateManyCourseInput | CourseCategoryCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseTagCreateWithoutCourseInput = {
    id?: string
    tag: TagCreateNestedOneWithoutCoursesInput
  }

  export type CourseTagUncheckedCreateWithoutCourseInput = {
    id?: string
    tagId: string
  }

  export type CourseTagCreateOrConnectWithoutCourseInput = {
    where: CourseTagWhereUniqueInput
    create: XOR<CourseTagCreateWithoutCourseInput, CourseTagUncheckedCreateWithoutCourseInput>
  }

  export type CourseTagCreateManyCourseInputEnvelope = {
    data: CourseTagCreateManyCourseInput | CourseTagCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseModuleCreateWithoutCourseInput = {
    id?: string
    title: string
    description?: string | null
    sortOrder: number
    duration?: string | null
    isOptional?: boolean
  }

  export type CourseModuleUncheckedCreateWithoutCourseInput = {
    id?: string
    title: string
    description?: string | null
    sortOrder: number
    duration?: string | null
    isOptional?: boolean
  }

  export type CourseModuleCreateOrConnectWithoutCourseInput = {
    where: CourseModuleWhereUniqueInput
    create: XOR<CourseModuleCreateWithoutCourseInput, CourseModuleUncheckedCreateWithoutCourseInput>
  }

  export type CourseModuleCreateManyCourseInputEnvelope = {
    data: CourseModuleCreateManyCourseInput | CourseModuleCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCoursesInput = {
    update: XOR<UserUpdateWithoutCoursesInput, UserUncheckedUpdateWithoutCoursesInput>
    create: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCoursesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCoursesInput, UserUncheckedUpdateWithoutCoursesInput>
  }

  export type UserUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    reviewStreak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    enrollments?: CourseEnrollmentUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    skillProficiencies?: UserSkillProficiencyUpdateManyWithoutUserNestedInput
    reviewHelpfulVotes?: ReviewHelpfulVoteUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    reviewStreak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    skillProficiencies?: UserSkillProficiencyUncheckedUpdateManyWithoutUserNestedInput
    reviewHelpfulVotes?: ReviewHelpfulVoteUncheckedUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReviewUpsertWithWhereUniqueWithoutCourseInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutCourseInput, ReviewUncheckedUpdateWithoutCourseInput>
    create: XOR<ReviewCreateWithoutCourseInput, ReviewUncheckedCreateWithoutCourseInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutCourseInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutCourseInput, ReviewUncheckedUpdateWithoutCourseInput>
  }

  export type ReviewUpdateManyWithWhereWithoutCourseInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseSkillUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseSkillWhereUniqueInput
    update: XOR<CourseSkillUpdateWithoutCourseInput, CourseSkillUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseSkillCreateWithoutCourseInput, CourseSkillUncheckedCreateWithoutCourseInput>
  }

  export type CourseSkillUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseSkillWhereUniqueInput
    data: XOR<CourseSkillUpdateWithoutCourseInput, CourseSkillUncheckedUpdateWithoutCourseInput>
  }

  export type CourseSkillUpdateManyWithWhereWithoutCourseInput = {
    where: CourseSkillScalarWhereInput
    data: XOR<CourseSkillUpdateManyMutationInput, CourseSkillUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseSkillScalarWhereInput = {
    AND?: CourseSkillScalarWhereInput | CourseSkillScalarWhereInput[]
    OR?: CourseSkillScalarWhereInput[]
    NOT?: CourseSkillScalarWhereInput | CourseSkillScalarWhereInput[]
    id?: StringFilter<"CourseSkill"> | string
    courseId?: StringFilter<"CourseSkill"> | string
    skillId?: StringFilter<"CourseSkill"> | string
    level?: EnumSkillLevelFilter<"CourseSkill"> | $Enums.SkillLevel
    isCore?: BoolFilter<"CourseSkill"> | boolean
    percentage?: IntNullableFilter<"CourseSkill"> | number | null
    createdAt?: DateTimeFilter<"CourseSkill"> | Date | string
  }

  export type CourseEnrollmentUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseEnrollmentWhereUniqueInput
    update: XOR<CourseEnrollmentUpdateWithoutCourseInput, CourseEnrollmentUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseEnrollmentCreateWithoutCourseInput, CourseEnrollmentUncheckedCreateWithoutCourseInput>
  }

  export type CourseEnrollmentUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseEnrollmentWhereUniqueInput
    data: XOR<CourseEnrollmentUpdateWithoutCourseInput, CourseEnrollmentUncheckedUpdateWithoutCourseInput>
  }

  export type CourseEnrollmentUpdateManyWithWhereWithoutCourseInput = {
    where: CourseEnrollmentScalarWhereInput
    data: XOR<CourseEnrollmentUpdateManyMutationInput, CourseEnrollmentUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseCategoryUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseCategoryWhereUniqueInput
    update: XOR<CourseCategoryUpdateWithoutCourseInput, CourseCategoryUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseCategoryCreateWithoutCourseInput, CourseCategoryUncheckedCreateWithoutCourseInput>
  }

  export type CourseCategoryUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseCategoryWhereUniqueInput
    data: XOR<CourseCategoryUpdateWithoutCourseInput, CourseCategoryUncheckedUpdateWithoutCourseInput>
  }

  export type CourseCategoryUpdateManyWithWhereWithoutCourseInput = {
    where: CourseCategoryScalarWhereInput
    data: XOR<CourseCategoryUpdateManyMutationInput, CourseCategoryUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseCategoryScalarWhereInput = {
    AND?: CourseCategoryScalarWhereInput | CourseCategoryScalarWhereInput[]
    OR?: CourseCategoryScalarWhereInput[]
    NOT?: CourseCategoryScalarWhereInput | CourseCategoryScalarWhereInput[]
    id?: StringFilter<"CourseCategory"> | string
    courseId?: StringFilter<"CourseCategory"> | string
    categoryId?: StringFilter<"CourseCategory"> | string
    isPrimary?: BoolFilter<"CourseCategory"> | boolean
  }

  export type CourseTagUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseTagWhereUniqueInput
    update: XOR<CourseTagUpdateWithoutCourseInput, CourseTagUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseTagCreateWithoutCourseInput, CourseTagUncheckedCreateWithoutCourseInput>
  }

  export type CourseTagUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseTagWhereUniqueInput
    data: XOR<CourseTagUpdateWithoutCourseInput, CourseTagUncheckedUpdateWithoutCourseInput>
  }

  export type CourseTagUpdateManyWithWhereWithoutCourseInput = {
    where: CourseTagScalarWhereInput
    data: XOR<CourseTagUpdateManyMutationInput, CourseTagUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseTagScalarWhereInput = {
    AND?: CourseTagScalarWhereInput | CourseTagScalarWhereInput[]
    OR?: CourseTagScalarWhereInput[]
    NOT?: CourseTagScalarWhereInput | CourseTagScalarWhereInput[]
    id?: StringFilter<"CourseTag"> | string
    courseId?: StringFilter<"CourseTag"> | string
    tagId?: StringFilter<"CourseTag"> | string
  }

  export type CourseModuleUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseModuleWhereUniqueInput
    update: XOR<CourseModuleUpdateWithoutCourseInput, CourseModuleUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseModuleCreateWithoutCourseInput, CourseModuleUncheckedCreateWithoutCourseInput>
  }

  export type CourseModuleUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseModuleWhereUniqueInput
    data: XOR<CourseModuleUpdateWithoutCourseInput, CourseModuleUncheckedUpdateWithoutCourseInput>
  }

  export type CourseModuleUpdateManyWithWhereWithoutCourseInput = {
    where: CourseModuleScalarWhereInput
    data: XOR<CourseModuleUpdateManyMutationInput, CourseModuleUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseModuleScalarWhereInput = {
    AND?: CourseModuleScalarWhereInput | CourseModuleScalarWhereInput[]
    OR?: CourseModuleScalarWhereInput[]
    NOT?: CourseModuleScalarWhereInput | CourseModuleScalarWhereInput[]
    id?: StringFilter<"CourseModule"> | string
    courseId?: StringFilter<"CourseModule"> | string
    title?: StringFilter<"CourseModule"> | string
    description?: StringNullableFilter<"CourseModule"> | string | null
    sortOrder?: IntFilter<"CourseModule"> | number
    duration?: StringNullableFilter<"CourseModule"> | string | null
    isOptional?: BoolFilter<"CourseModule"> | boolean
  }

  export type CourseSkillCreateWithoutSkillInput = {
    id?: string
    level?: $Enums.SkillLevel
    isCore?: boolean
    percentage?: number | null
    createdAt?: Date | string
    course: CourseCreateNestedOneWithoutSkillsInput
  }

  export type CourseSkillUncheckedCreateWithoutSkillInput = {
    id?: string
    courseId: string
    level?: $Enums.SkillLevel
    isCore?: boolean
    percentage?: number | null
    createdAt?: Date | string
  }

  export type CourseSkillCreateOrConnectWithoutSkillInput = {
    where: CourseSkillWhereUniqueInput
    create: XOR<CourseSkillCreateWithoutSkillInput, CourseSkillUncheckedCreateWithoutSkillInput>
  }

  export type CourseSkillCreateManySkillInputEnvelope = {
    data: CourseSkillCreateManySkillInput | CourseSkillCreateManySkillInput[]
    skipDuplicates?: boolean
  }

  export type UserSkillProficiencyCreateWithoutSkillInput = {
    id?: string
    level: $Enums.SkillLevel
    yearsExperience?: number | null
    lastUsed?: Date | string | null
    isVerified?: boolean
    verificationSource?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSkillProficienciesInput
  }

  export type UserSkillProficiencyUncheckedCreateWithoutSkillInput = {
    id?: string
    userId: string
    level: $Enums.SkillLevel
    yearsExperience?: number | null
    lastUsed?: Date | string | null
    isVerified?: boolean
    verificationSource?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSkillProficiencyCreateOrConnectWithoutSkillInput = {
    where: UserSkillProficiencyWhereUniqueInput
    create: XOR<UserSkillProficiencyCreateWithoutSkillInput, UserSkillProficiencyUncheckedCreateWithoutSkillInput>
  }

  export type UserSkillProficiencyCreateManySkillInputEnvelope = {
    data: UserSkillProficiencyCreateManySkillInput | UserSkillProficiencyCreateManySkillInput[]
    skipDuplicates?: boolean
  }

  export type SkillPrerequisiteCreateWithoutPrerequisiteSkillInput = {
    id?: string
    isRequired?: boolean
    minimumLevel?: $Enums.SkillLevel
    skill: SkillCreateNestedOneWithoutPrerequisitesInput
  }

  export type SkillPrerequisiteUncheckedCreateWithoutPrerequisiteSkillInput = {
    id?: string
    skillId: string
    isRequired?: boolean
    minimumLevel?: $Enums.SkillLevel
  }

  export type SkillPrerequisiteCreateOrConnectWithoutPrerequisiteSkillInput = {
    where: SkillPrerequisiteWhereUniqueInput
    create: XOR<SkillPrerequisiteCreateWithoutPrerequisiteSkillInput, SkillPrerequisiteUncheckedCreateWithoutPrerequisiteSkillInput>
  }

  export type SkillPrerequisiteCreateManyPrerequisiteSkillInputEnvelope = {
    data: SkillPrerequisiteCreateManyPrerequisiteSkillInput | SkillPrerequisiteCreateManyPrerequisiteSkillInput[]
    skipDuplicates?: boolean
  }

  export type SkillPrerequisiteCreateWithoutSkillInput = {
    id?: string
    isRequired?: boolean
    minimumLevel?: $Enums.SkillLevel
    prerequisiteSkill: SkillCreateNestedOneWithoutPrerequisiteForInput
  }

  export type SkillPrerequisiteUncheckedCreateWithoutSkillInput = {
    id?: string
    prerequisiteSkillId: string
    isRequired?: boolean
    minimumLevel?: $Enums.SkillLevel
  }

  export type SkillPrerequisiteCreateOrConnectWithoutSkillInput = {
    where: SkillPrerequisiteWhereUniqueInput
    create: XOR<SkillPrerequisiteCreateWithoutSkillInput, SkillPrerequisiteUncheckedCreateWithoutSkillInput>
  }

  export type SkillPrerequisiteCreateManySkillInputEnvelope = {
    data: SkillPrerequisiteCreateManySkillInput | SkillPrerequisiteCreateManySkillInput[]
    skipDuplicates?: boolean
  }

  export type ReviewSkillRatingCreateWithoutSkillInput = {
    id?: string
    rating: number
    createdAt?: Date | string
    review: ReviewCreateNestedOneWithoutSkillRatingsInput
  }

  export type ReviewSkillRatingUncheckedCreateWithoutSkillInput = {
    id?: string
    reviewId: string
    rating: number
    createdAt?: Date | string
  }

  export type ReviewSkillRatingCreateOrConnectWithoutSkillInput = {
    where: ReviewSkillRatingWhereUniqueInput
    create: XOR<ReviewSkillRatingCreateWithoutSkillInput, ReviewSkillRatingUncheckedCreateWithoutSkillInput>
  }

  export type ReviewSkillRatingCreateManySkillInputEnvelope = {
    data: ReviewSkillRatingCreateManySkillInput | ReviewSkillRatingCreateManySkillInput[]
    skipDuplicates?: boolean
  }

  export type CourseSkillUpsertWithWhereUniqueWithoutSkillInput = {
    where: CourseSkillWhereUniqueInput
    update: XOR<CourseSkillUpdateWithoutSkillInput, CourseSkillUncheckedUpdateWithoutSkillInput>
    create: XOR<CourseSkillCreateWithoutSkillInput, CourseSkillUncheckedCreateWithoutSkillInput>
  }

  export type CourseSkillUpdateWithWhereUniqueWithoutSkillInput = {
    where: CourseSkillWhereUniqueInput
    data: XOR<CourseSkillUpdateWithoutSkillInput, CourseSkillUncheckedUpdateWithoutSkillInput>
  }

  export type CourseSkillUpdateManyWithWhereWithoutSkillInput = {
    where: CourseSkillScalarWhereInput
    data: XOR<CourseSkillUpdateManyMutationInput, CourseSkillUncheckedUpdateManyWithoutSkillInput>
  }

  export type UserSkillProficiencyUpsertWithWhereUniqueWithoutSkillInput = {
    where: UserSkillProficiencyWhereUniqueInput
    update: XOR<UserSkillProficiencyUpdateWithoutSkillInput, UserSkillProficiencyUncheckedUpdateWithoutSkillInput>
    create: XOR<UserSkillProficiencyCreateWithoutSkillInput, UserSkillProficiencyUncheckedCreateWithoutSkillInput>
  }

  export type UserSkillProficiencyUpdateWithWhereUniqueWithoutSkillInput = {
    where: UserSkillProficiencyWhereUniqueInput
    data: XOR<UserSkillProficiencyUpdateWithoutSkillInput, UserSkillProficiencyUncheckedUpdateWithoutSkillInput>
  }

  export type UserSkillProficiencyUpdateManyWithWhereWithoutSkillInput = {
    where: UserSkillProficiencyScalarWhereInput
    data: XOR<UserSkillProficiencyUpdateManyMutationInput, UserSkillProficiencyUncheckedUpdateManyWithoutSkillInput>
  }

  export type SkillPrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteSkillInput = {
    where: SkillPrerequisiteWhereUniqueInput
    update: XOR<SkillPrerequisiteUpdateWithoutPrerequisiteSkillInput, SkillPrerequisiteUncheckedUpdateWithoutPrerequisiteSkillInput>
    create: XOR<SkillPrerequisiteCreateWithoutPrerequisiteSkillInput, SkillPrerequisiteUncheckedCreateWithoutPrerequisiteSkillInput>
  }

  export type SkillPrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteSkillInput = {
    where: SkillPrerequisiteWhereUniqueInput
    data: XOR<SkillPrerequisiteUpdateWithoutPrerequisiteSkillInput, SkillPrerequisiteUncheckedUpdateWithoutPrerequisiteSkillInput>
  }

  export type SkillPrerequisiteUpdateManyWithWhereWithoutPrerequisiteSkillInput = {
    where: SkillPrerequisiteScalarWhereInput
    data: XOR<SkillPrerequisiteUpdateManyMutationInput, SkillPrerequisiteUncheckedUpdateManyWithoutPrerequisiteSkillInput>
  }

  export type SkillPrerequisiteScalarWhereInput = {
    AND?: SkillPrerequisiteScalarWhereInput | SkillPrerequisiteScalarWhereInput[]
    OR?: SkillPrerequisiteScalarWhereInput[]
    NOT?: SkillPrerequisiteScalarWhereInput | SkillPrerequisiteScalarWhereInput[]
    id?: StringFilter<"SkillPrerequisite"> | string
    skillId?: StringFilter<"SkillPrerequisite"> | string
    prerequisiteSkillId?: StringFilter<"SkillPrerequisite"> | string
    isRequired?: BoolFilter<"SkillPrerequisite"> | boolean
    minimumLevel?: EnumSkillLevelFilter<"SkillPrerequisite"> | $Enums.SkillLevel
  }

  export type SkillPrerequisiteUpsertWithWhereUniqueWithoutSkillInput = {
    where: SkillPrerequisiteWhereUniqueInput
    update: XOR<SkillPrerequisiteUpdateWithoutSkillInput, SkillPrerequisiteUncheckedUpdateWithoutSkillInput>
    create: XOR<SkillPrerequisiteCreateWithoutSkillInput, SkillPrerequisiteUncheckedCreateWithoutSkillInput>
  }

  export type SkillPrerequisiteUpdateWithWhereUniqueWithoutSkillInput = {
    where: SkillPrerequisiteWhereUniqueInput
    data: XOR<SkillPrerequisiteUpdateWithoutSkillInput, SkillPrerequisiteUncheckedUpdateWithoutSkillInput>
  }

  export type SkillPrerequisiteUpdateManyWithWhereWithoutSkillInput = {
    where: SkillPrerequisiteScalarWhereInput
    data: XOR<SkillPrerequisiteUpdateManyMutationInput, SkillPrerequisiteUncheckedUpdateManyWithoutSkillInput>
  }

  export type ReviewSkillRatingUpsertWithWhereUniqueWithoutSkillInput = {
    where: ReviewSkillRatingWhereUniqueInput
    update: XOR<ReviewSkillRatingUpdateWithoutSkillInput, ReviewSkillRatingUncheckedUpdateWithoutSkillInput>
    create: XOR<ReviewSkillRatingCreateWithoutSkillInput, ReviewSkillRatingUncheckedCreateWithoutSkillInput>
  }

  export type ReviewSkillRatingUpdateWithWhereUniqueWithoutSkillInput = {
    where: ReviewSkillRatingWhereUniqueInput
    data: XOR<ReviewSkillRatingUpdateWithoutSkillInput, ReviewSkillRatingUncheckedUpdateWithoutSkillInput>
  }

  export type ReviewSkillRatingUpdateManyWithWhereWithoutSkillInput = {
    where: ReviewSkillRatingScalarWhereInput
    data: XOR<ReviewSkillRatingUpdateManyMutationInput, ReviewSkillRatingUncheckedUpdateManyWithoutSkillInput>
  }

  export type ReviewSkillRatingScalarWhereInput = {
    AND?: ReviewSkillRatingScalarWhereInput | ReviewSkillRatingScalarWhereInput[]
    OR?: ReviewSkillRatingScalarWhereInput[]
    NOT?: ReviewSkillRatingScalarWhereInput | ReviewSkillRatingScalarWhereInput[]
    id?: StringFilter<"ReviewSkillRating"> | string
    reviewId?: StringFilter<"ReviewSkillRating"> | string
    skillId?: StringFilter<"ReviewSkillRating"> | string
    rating?: IntFilter<"ReviewSkillRating"> | number
    createdAt?: DateTimeFilter<"ReviewSkillRating"> | Date | string
  }

  export type CourseCreateWithoutSkillsInput = {
    id?: string
    title: string
    description: string
    shortDescription?: string | null
    imageUrl?: string | null
    thumbnailUrl?: string | null
    courseUrl: string
    instructor: string
    institution?: string | null
    duration?: string | null
    difficulty: $Enums.Difficulty
    status?: $Enums.CourseStatus
    price?: Decimal | DecimalJsLike | number | string | null
    isFree?: boolean
    language?: string
    rating?: Decimal | DecimalJsLike | number | string | null
    reviewCount?: number
    enrollmentCount?: number
    isActive?: boolean
    prerequisites?: CourseCreateprerequisitesInput | string[]
    learningOutcomes?: CourseCreatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCoursesInput
    reviews?: ReviewCreateNestedManyWithoutCourseInput
    enrollments?: CourseEnrollmentCreateNestedManyWithoutCourseInput
    categories?: CourseCategoryCreateNestedManyWithoutCourseInput
    tags?: CourseTagCreateNestedManyWithoutCourseInput
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutSkillsInput = {
    id?: string
    title: string
    description: string
    shortDescription?: string | null
    imageUrl?: string | null
    thumbnailUrl?: string | null
    courseUrl: string
    instructor: string
    institution?: string | null
    duration?: string | null
    difficulty: $Enums.Difficulty
    status?: $Enums.CourseStatus
    price?: Decimal | DecimalJsLike | number | string | null
    isFree?: boolean
    language?: string
    rating?: Decimal | DecimalJsLike | number | string | null
    reviewCount?: number
    enrollmentCount?: number
    isActive?: boolean
    prerequisites?: CourseCreateprerequisitesInput | string[]
    learningOutcomes?: CourseCreatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    reviews?: ReviewUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutCourseInput
    categories?: CourseCategoryUncheckedCreateNestedManyWithoutCourseInput
    tags?: CourseTagUncheckedCreateNestedManyWithoutCourseInput
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutSkillsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutSkillsInput, CourseUncheckedCreateWithoutSkillsInput>
  }

  export type SkillCreateWithoutCoursesInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userProficiencies?: UserSkillProficiencyCreateNestedManyWithoutSkillInput
    prerequisiteFor?: SkillPrerequisiteCreateNestedManyWithoutPrerequisiteSkillInput
    prerequisites?: SkillPrerequisiteCreateNestedManyWithoutSkillInput
    reviewRatings?: ReviewSkillRatingCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateWithoutCoursesInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userProficiencies?: UserSkillProficiencyUncheckedCreateNestedManyWithoutSkillInput
    prerequisiteFor?: SkillPrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteSkillInput
    prerequisites?: SkillPrerequisiteUncheckedCreateNestedManyWithoutSkillInput
    reviewRatings?: ReviewSkillRatingUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillCreateOrConnectWithoutCoursesInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutCoursesInput, SkillUncheckedCreateWithoutCoursesInput>
  }

  export type CourseUpsertWithoutSkillsInput = {
    update: XOR<CourseUpdateWithoutSkillsInput, CourseUncheckedUpdateWithoutSkillsInput>
    create: XOR<CourseCreateWithoutSkillsInput, CourseUncheckedCreateWithoutSkillsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutSkillsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutSkillsInput, CourseUncheckedUpdateWithoutSkillsInput>
  }

  export type CourseUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    courseUrl?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    enrollmentCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    prerequisites?: CourseUpdateprerequisitesInput | string[]
    learningOutcomes?: CourseUpdatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCoursesNestedInput
    reviews?: ReviewUpdateManyWithoutCourseNestedInput
    enrollments?: CourseEnrollmentUpdateManyWithoutCourseNestedInput
    categories?: CourseCategoryUpdateManyWithoutCourseNestedInput
    tags?: CourseTagUpdateManyWithoutCourseNestedInput
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    courseUrl?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    enrollmentCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    prerequisites?: CourseUpdateprerequisitesInput | string[]
    learningOutcomes?: CourseUpdatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    reviews?: ReviewUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    categories?: CourseCategoryUncheckedUpdateManyWithoutCourseNestedInput
    tags?: CourseTagUncheckedUpdateManyWithoutCourseNestedInput
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type SkillUpsertWithoutCoursesInput = {
    update: XOR<SkillUpdateWithoutCoursesInput, SkillUncheckedUpdateWithoutCoursesInput>
    create: XOR<SkillCreateWithoutCoursesInput, SkillUncheckedCreateWithoutCoursesInput>
    where?: SkillWhereInput
  }

  export type SkillUpdateToOneWithWhereWithoutCoursesInput = {
    where?: SkillWhereInput
    data: XOR<SkillUpdateWithoutCoursesInput, SkillUncheckedUpdateWithoutCoursesInput>
  }

  export type SkillUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userProficiencies?: UserSkillProficiencyUpdateManyWithoutSkillNestedInput
    prerequisiteFor?: SkillPrerequisiteUpdateManyWithoutPrerequisiteSkillNestedInput
    prerequisites?: SkillPrerequisiteUpdateManyWithoutSkillNestedInput
    reviewRatings?: ReviewSkillRatingUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userProficiencies?: UserSkillProficiencyUncheckedUpdateManyWithoutSkillNestedInput
    prerequisiteFor?: SkillPrerequisiteUncheckedUpdateManyWithoutPrerequisiteSkillNestedInput
    prerequisites?: SkillPrerequisiteUncheckedUpdateManyWithoutSkillNestedInput
    reviewRatings?: ReviewSkillRatingUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type UserCreateWithoutReviewsInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    profileImage?: string | null
    bio?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationToken?: string | null
    passwordHash: string
    totalPoints?: number
    reviewStreak?: number
    lastActiveAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    enrollments?: CourseEnrollmentCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutCreatedByInput
    skillProficiencies?: UserSkillProficiencyCreateNestedManyWithoutUserInput
    reviewHelpfulVotes?: ReviewHelpfulVoteCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    profileImage?: string | null
    bio?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationToken?: string | null
    passwordHash: string
    totalPoints?: number
    reviewStreak?: number
    lastActiveAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatedByInput
    skillProficiencies?: UserSkillProficiencyUncheckedCreateNestedManyWithoutUserInput
    reviewHelpfulVotes?: ReviewHelpfulVoteUncheckedCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type CourseCreateWithoutReviewsInput = {
    id?: string
    title: string
    description: string
    shortDescription?: string | null
    imageUrl?: string | null
    thumbnailUrl?: string | null
    courseUrl: string
    instructor: string
    institution?: string | null
    duration?: string | null
    difficulty: $Enums.Difficulty
    status?: $Enums.CourseStatus
    price?: Decimal | DecimalJsLike | number | string | null
    isFree?: boolean
    language?: string
    rating?: Decimal | DecimalJsLike | number | string | null
    reviewCount?: number
    enrollmentCount?: number
    isActive?: boolean
    prerequisites?: CourseCreateprerequisitesInput | string[]
    learningOutcomes?: CourseCreatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCoursesInput
    skills?: CourseSkillCreateNestedManyWithoutCourseInput
    enrollments?: CourseEnrollmentCreateNestedManyWithoutCourseInput
    categories?: CourseCategoryCreateNestedManyWithoutCourseInput
    tags?: CourseTagCreateNestedManyWithoutCourseInput
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutReviewsInput = {
    id?: string
    title: string
    description: string
    shortDescription?: string | null
    imageUrl?: string | null
    thumbnailUrl?: string | null
    courseUrl: string
    instructor: string
    institution?: string | null
    duration?: string | null
    difficulty: $Enums.Difficulty
    status?: $Enums.CourseStatus
    price?: Decimal | DecimalJsLike | number | string | null
    isFree?: boolean
    language?: string
    rating?: Decimal | DecimalJsLike | number | string | null
    reviewCount?: number
    enrollmentCount?: number
    isActive?: boolean
    prerequisites?: CourseCreateprerequisitesInput | string[]
    learningOutcomes?: CourseCreatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    skills?: CourseSkillUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutCourseInput
    categories?: CourseCategoryUncheckedCreateNestedManyWithoutCourseInput
    tags?: CourseTagUncheckedCreateNestedManyWithoutCourseInput
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutReviewsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutReviewsInput, CourseUncheckedCreateWithoutReviewsInput>
  }

  export type ReviewVoteCreateWithoutReviewInput = {
    id?: string
    isUpvote: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutReviewVotesInput
  }

  export type ReviewVoteUncheckedCreateWithoutReviewInput = {
    id?: string
    userId: string
    isUpvote: boolean
    createdAt?: Date | string
  }

  export type ReviewVoteCreateOrConnectWithoutReviewInput = {
    where: ReviewVoteWhereUniqueInput
    create: XOR<ReviewVoteCreateWithoutReviewInput, ReviewVoteUncheckedCreateWithoutReviewInput>
  }

  export type ReviewVoteCreateManyReviewInputEnvelope = {
    data: ReviewVoteCreateManyReviewInput | ReviewVoteCreateManyReviewInput[]
    skipDuplicates?: boolean
  }

  export type ReviewHelpfulVoteCreateWithoutReviewInput = {
    id?: string
    isHelpful: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutReviewHelpfulVotesInput
  }

  export type ReviewHelpfulVoteUncheckedCreateWithoutReviewInput = {
    id?: string
    userId: string
    isHelpful: boolean
    createdAt?: Date | string
  }

  export type ReviewHelpfulVoteCreateOrConnectWithoutReviewInput = {
    where: ReviewHelpfulVoteWhereUniqueInput
    create: XOR<ReviewHelpfulVoteCreateWithoutReviewInput, ReviewHelpfulVoteUncheckedCreateWithoutReviewInput>
  }

  export type ReviewHelpfulVoteCreateManyReviewInputEnvelope = {
    data: ReviewHelpfulVoteCreateManyReviewInput | ReviewHelpfulVoteCreateManyReviewInput[]
    skipDuplicates?: boolean
  }

  export type ReviewSkillRatingCreateWithoutReviewInput = {
    id?: string
    rating: number
    createdAt?: Date | string
    skill: SkillCreateNestedOneWithoutReviewRatingsInput
  }

  export type ReviewSkillRatingUncheckedCreateWithoutReviewInput = {
    id?: string
    skillId: string
    rating: number
    createdAt?: Date | string
  }

  export type ReviewSkillRatingCreateOrConnectWithoutReviewInput = {
    where: ReviewSkillRatingWhereUniqueInput
    create: XOR<ReviewSkillRatingCreateWithoutReviewInput, ReviewSkillRatingUncheckedCreateWithoutReviewInput>
  }

  export type ReviewSkillRatingCreateManyReviewInputEnvelope = {
    data: ReviewSkillRatingCreateManyReviewInput | ReviewSkillRatingCreateManyReviewInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    reviewStreak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    enrollments?: CourseEnrollmentUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutCreatedByNestedInput
    skillProficiencies?: UserSkillProficiencyUpdateManyWithoutUserNestedInput
    reviewHelpfulVotes?: ReviewHelpfulVoteUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    reviewStreak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatedByNestedInput
    skillProficiencies?: UserSkillProficiencyUncheckedUpdateManyWithoutUserNestedInput
    reviewHelpfulVotes?: ReviewHelpfulVoteUncheckedUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseUpsertWithoutReviewsInput = {
    update: XOR<CourseUpdateWithoutReviewsInput, CourseUncheckedUpdateWithoutReviewsInput>
    create: XOR<CourseCreateWithoutReviewsInput, CourseUncheckedCreateWithoutReviewsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutReviewsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutReviewsInput, CourseUncheckedUpdateWithoutReviewsInput>
  }

  export type CourseUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    courseUrl?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    enrollmentCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    prerequisites?: CourseUpdateprerequisitesInput | string[]
    learningOutcomes?: CourseUpdatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCoursesNestedInput
    skills?: CourseSkillUpdateManyWithoutCourseNestedInput
    enrollments?: CourseEnrollmentUpdateManyWithoutCourseNestedInput
    categories?: CourseCategoryUpdateManyWithoutCourseNestedInput
    tags?: CourseTagUpdateManyWithoutCourseNestedInput
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    courseUrl?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    enrollmentCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    prerequisites?: CourseUpdateprerequisitesInput | string[]
    learningOutcomes?: CourseUpdatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    skills?: CourseSkillUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    categories?: CourseCategoryUncheckedUpdateManyWithoutCourseNestedInput
    tags?: CourseTagUncheckedUpdateManyWithoutCourseNestedInput
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type ReviewVoteUpsertWithWhereUniqueWithoutReviewInput = {
    where: ReviewVoteWhereUniqueInput
    update: XOR<ReviewVoteUpdateWithoutReviewInput, ReviewVoteUncheckedUpdateWithoutReviewInput>
    create: XOR<ReviewVoteCreateWithoutReviewInput, ReviewVoteUncheckedCreateWithoutReviewInput>
  }

  export type ReviewVoteUpdateWithWhereUniqueWithoutReviewInput = {
    where: ReviewVoteWhereUniqueInput
    data: XOR<ReviewVoteUpdateWithoutReviewInput, ReviewVoteUncheckedUpdateWithoutReviewInput>
  }

  export type ReviewVoteUpdateManyWithWhereWithoutReviewInput = {
    where: ReviewVoteScalarWhereInput
    data: XOR<ReviewVoteUpdateManyMutationInput, ReviewVoteUncheckedUpdateManyWithoutReviewInput>
  }

  export type ReviewHelpfulVoteUpsertWithWhereUniqueWithoutReviewInput = {
    where: ReviewHelpfulVoteWhereUniqueInput
    update: XOR<ReviewHelpfulVoteUpdateWithoutReviewInput, ReviewHelpfulVoteUncheckedUpdateWithoutReviewInput>
    create: XOR<ReviewHelpfulVoteCreateWithoutReviewInput, ReviewHelpfulVoteUncheckedCreateWithoutReviewInput>
  }

  export type ReviewHelpfulVoteUpdateWithWhereUniqueWithoutReviewInput = {
    where: ReviewHelpfulVoteWhereUniqueInput
    data: XOR<ReviewHelpfulVoteUpdateWithoutReviewInput, ReviewHelpfulVoteUncheckedUpdateWithoutReviewInput>
  }

  export type ReviewHelpfulVoteUpdateManyWithWhereWithoutReviewInput = {
    where: ReviewHelpfulVoteScalarWhereInput
    data: XOR<ReviewHelpfulVoteUpdateManyMutationInput, ReviewHelpfulVoteUncheckedUpdateManyWithoutReviewInput>
  }

  export type ReviewSkillRatingUpsertWithWhereUniqueWithoutReviewInput = {
    where: ReviewSkillRatingWhereUniqueInput
    update: XOR<ReviewSkillRatingUpdateWithoutReviewInput, ReviewSkillRatingUncheckedUpdateWithoutReviewInput>
    create: XOR<ReviewSkillRatingCreateWithoutReviewInput, ReviewSkillRatingUncheckedCreateWithoutReviewInput>
  }

  export type ReviewSkillRatingUpdateWithWhereUniqueWithoutReviewInput = {
    where: ReviewSkillRatingWhereUniqueInput
    data: XOR<ReviewSkillRatingUpdateWithoutReviewInput, ReviewSkillRatingUncheckedUpdateWithoutReviewInput>
  }

  export type ReviewSkillRatingUpdateManyWithWhereWithoutReviewInput = {
    where: ReviewSkillRatingScalarWhereInput
    data: XOR<ReviewSkillRatingUpdateManyMutationInput, ReviewSkillRatingUncheckedUpdateManyWithoutReviewInput>
  }

  export type UserCreateWithoutReviewVotesInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    profileImage?: string | null
    bio?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationToken?: string | null
    passwordHash: string
    totalPoints?: number
    reviewStreak?: number
    lastActiveAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewCreateNestedManyWithoutUserInput
    enrollments?: CourseEnrollmentCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutCreatedByInput
    skillProficiencies?: UserSkillProficiencyCreateNestedManyWithoutUserInput
    reviewHelpfulVotes?: ReviewHelpfulVoteCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewVotesInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    profileImage?: string | null
    bio?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationToken?: string | null
    passwordHash: string
    totalPoints?: number
    reviewStreak?: number
    lastActiveAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatedByInput
    skillProficiencies?: UserSkillProficiencyUncheckedCreateNestedManyWithoutUserInput
    reviewHelpfulVotes?: ReviewHelpfulVoteUncheckedCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewVotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewVotesInput, UserUncheckedCreateWithoutReviewVotesInput>
  }

  export type ReviewCreateWithoutVotesInput = {
    id?: string
    overallRating: number
    difficultyRating?: number | null
    contentQuality?: number | null
    instructorRating?: number | null
    valueForMoney?: number | null
    wouldRecommend?: boolean | null
    title: string
    content: string
    pros?: ReviewCreateprosInput | string[]
    cons?: ReviewCreateconsInput | string[]
    isAnonymous?: boolean
    isVerified?: boolean
    helpfulCount?: number
    flagCount?: number
    isHidden?: boolean
    moderatorNotes?: string | null
    completionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
    course: CourseCreateNestedOneWithoutReviewsInput
    helpfulVotes?: ReviewHelpfulVoteCreateNestedManyWithoutReviewInput
    skillRatings?: ReviewSkillRatingCreateNestedManyWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutVotesInput = {
    id?: string
    userId: string
    courseId: string
    overallRating: number
    difficultyRating?: number | null
    contentQuality?: number | null
    instructorRating?: number | null
    valueForMoney?: number | null
    wouldRecommend?: boolean | null
    title: string
    content: string
    pros?: ReviewCreateprosInput | string[]
    cons?: ReviewCreateconsInput | string[]
    isAnonymous?: boolean
    isVerified?: boolean
    helpfulCount?: number
    flagCount?: number
    isHidden?: boolean
    moderatorNotes?: string | null
    completionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    helpfulVotes?: ReviewHelpfulVoteUncheckedCreateNestedManyWithoutReviewInput
    skillRatings?: ReviewSkillRatingUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewCreateOrConnectWithoutVotesInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutVotesInput, ReviewUncheckedCreateWithoutVotesInput>
  }

  export type UserUpsertWithoutReviewVotesInput = {
    update: XOR<UserUpdateWithoutReviewVotesInput, UserUncheckedUpdateWithoutReviewVotesInput>
    create: XOR<UserCreateWithoutReviewVotesInput, UserUncheckedCreateWithoutReviewVotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewVotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewVotesInput, UserUncheckedUpdateWithoutReviewVotesInput>
  }

  export type UserUpdateWithoutReviewVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    reviewStreak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    enrollments?: CourseEnrollmentUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutCreatedByNestedInput
    skillProficiencies?: UserSkillProficiencyUpdateManyWithoutUserNestedInput
    reviewHelpfulVotes?: ReviewHelpfulVoteUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    reviewStreak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatedByNestedInput
    skillProficiencies?: UserSkillProficiencyUncheckedUpdateManyWithoutUserNestedInput
    reviewHelpfulVotes?: ReviewHelpfulVoteUncheckedUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReviewUpsertWithoutVotesInput = {
    update: XOR<ReviewUpdateWithoutVotesInput, ReviewUncheckedUpdateWithoutVotesInput>
    create: XOR<ReviewCreateWithoutVotesInput, ReviewUncheckedCreateWithoutVotesInput>
    where?: ReviewWhereInput
  }

  export type ReviewUpdateToOneWithWhereWithoutVotesInput = {
    where?: ReviewWhereInput
    data: XOR<ReviewUpdateWithoutVotesInput, ReviewUncheckedUpdateWithoutVotesInput>
  }

  export type ReviewUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    difficultyRating?: NullableIntFieldUpdateOperationsInput | number | null
    contentQuality?: NullableIntFieldUpdateOperationsInput | number | null
    instructorRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueForMoney?: NullableIntFieldUpdateOperationsInput | number | null
    wouldRecommend?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    pros?: ReviewUpdateprosInput | string[]
    cons?: ReviewUpdateconsInput | string[]
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    flagCount?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    moderatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    course?: CourseUpdateOneRequiredWithoutReviewsNestedInput
    helpfulVotes?: ReviewHelpfulVoteUpdateManyWithoutReviewNestedInput
    skillRatings?: ReviewSkillRatingUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    difficultyRating?: NullableIntFieldUpdateOperationsInput | number | null
    contentQuality?: NullableIntFieldUpdateOperationsInput | number | null
    instructorRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueForMoney?: NullableIntFieldUpdateOperationsInput | number | null
    wouldRecommend?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    pros?: ReviewUpdateprosInput | string[]
    cons?: ReviewUpdateconsInput | string[]
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    flagCount?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    moderatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    helpfulVotes?: ReviewHelpfulVoteUncheckedUpdateManyWithoutReviewNestedInput
    skillRatings?: ReviewSkillRatingUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type UserCreateWithoutReviewHelpfulVotesInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    profileImage?: string | null
    bio?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationToken?: string | null
    passwordHash: string
    totalPoints?: number
    reviewStreak?: number
    lastActiveAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    enrollments?: CourseEnrollmentCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutCreatedByInput
    skillProficiencies?: UserSkillProficiencyCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewHelpfulVotesInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    profileImage?: string | null
    bio?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationToken?: string | null
    passwordHash: string
    totalPoints?: number
    reviewStreak?: number
    lastActiveAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatedByInput
    skillProficiencies?: UserSkillProficiencyUncheckedCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewHelpfulVotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewHelpfulVotesInput, UserUncheckedCreateWithoutReviewHelpfulVotesInput>
  }

  export type ReviewCreateWithoutHelpfulVotesInput = {
    id?: string
    overallRating: number
    difficultyRating?: number | null
    contentQuality?: number | null
    instructorRating?: number | null
    valueForMoney?: number | null
    wouldRecommend?: boolean | null
    title: string
    content: string
    pros?: ReviewCreateprosInput | string[]
    cons?: ReviewCreateconsInput | string[]
    isAnonymous?: boolean
    isVerified?: boolean
    helpfulCount?: number
    flagCount?: number
    isHidden?: boolean
    moderatorNotes?: string | null
    completionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
    course: CourseCreateNestedOneWithoutReviewsInput
    votes?: ReviewVoteCreateNestedManyWithoutReviewInput
    skillRatings?: ReviewSkillRatingCreateNestedManyWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutHelpfulVotesInput = {
    id?: string
    userId: string
    courseId: string
    overallRating: number
    difficultyRating?: number | null
    contentQuality?: number | null
    instructorRating?: number | null
    valueForMoney?: number | null
    wouldRecommend?: boolean | null
    title: string
    content: string
    pros?: ReviewCreateprosInput | string[]
    cons?: ReviewCreateconsInput | string[]
    isAnonymous?: boolean
    isVerified?: boolean
    helpfulCount?: number
    flagCount?: number
    isHidden?: boolean
    moderatorNotes?: string | null
    completionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: ReviewVoteUncheckedCreateNestedManyWithoutReviewInput
    skillRatings?: ReviewSkillRatingUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewCreateOrConnectWithoutHelpfulVotesInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutHelpfulVotesInput, ReviewUncheckedCreateWithoutHelpfulVotesInput>
  }

  export type UserUpsertWithoutReviewHelpfulVotesInput = {
    update: XOR<UserUpdateWithoutReviewHelpfulVotesInput, UserUncheckedUpdateWithoutReviewHelpfulVotesInput>
    create: XOR<UserCreateWithoutReviewHelpfulVotesInput, UserUncheckedCreateWithoutReviewHelpfulVotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewHelpfulVotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewHelpfulVotesInput, UserUncheckedUpdateWithoutReviewHelpfulVotesInput>
  }

  export type UserUpdateWithoutReviewHelpfulVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    reviewStreak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    enrollments?: CourseEnrollmentUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutCreatedByNestedInput
    skillProficiencies?: UserSkillProficiencyUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewHelpfulVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    reviewStreak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatedByNestedInput
    skillProficiencies?: UserSkillProficiencyUncheckedUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReviewUpsertWithoutHelpfulVotesInput = {
    update: XOR<ReviewUpdateWithoutHelpfulVotesInput, ReviewUncheckedUpdateWithoutHelpfulVotesInput>
    create: XOR<ReviewCreateWithoutHelpfulVotesInput, ReviewUncheckedCreateWithoutHelpfulVotesInput>
    where?: ReviewWhereInput
  }

  export type ReviewUpdateToOneWithWhereWithoutHelpfulVotesInput = {
    where?: ReviewWhereInput
    data: XOR<ReviewUpdateWithoutHelpfulVotesInput, ReviewUncheckedUpdateWithoutHelpfulVotesInput>
  }

  export type ReviewUpdateWithoutHelpfulVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    difficultyRating?: NullableIntFieldUpdateOperationsInput | number | null
    contentQuality?: NullableIntFieldUpdateOperationsInput | number | null
    instructorRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueForMoney?: NullableIntFieldUpdateOperationsInput | number | null
    wouldRecommend?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    pros?: ReviewUpdateprosInput | string[]
    cons?: ReviewUpdateconsInput | string[]
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    flagCount?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    moderatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    course?: CourseUpdateOneRequiredWithoutReviewsNestedInput
    votes?: ReviewVoteUpdateManyWithoutReviewNestedInput
    skillRatings?: ReviewSkillRatingUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutHelpfulVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    difficultyRating?: NullableIntFieldUpdateOperationsInput | number | null
    contentQuality?: NullableIntFieldUpdateOperationsInput | number | null
    instructorRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueForMoney?: NullableIntFieldUpdateOperationsInput | number | null
    wouldRecommend?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    pros?: ReviewUpdateprosInput | string[]
    cons?: ReviewUpdateconsInput | string[]
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    flagCount?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    moderatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: ReviewVoteUncheckedUpdateManyWithoutReviewNestedInput
    skillRatings?: ReviewSkillRatingUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewCreateWithoutSkillRatingsInput = {
    id?: string
    overallRating: number
    difficultyRating?: number | null
    contentQuality?: number | null
    instructorRating?: number | null
    valueForMoney?: number | null
    wouldRecommend?: boolean | null
    title: string
    content: string
    pros?: ReviewCreateprosInput | string[]
    cons?: ReviewCreateconsInput | string[]
    isAnonymous?: boolean
    isVerified?: boolean
    helpfulCount?: number
    flagCount?: number
    isHidden?: boolean
    moderatorNotes?: string | null
    completionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
    course: CourseCreateNestedOneWithoutReviewsInput
    votes?: ReviewVoteCreateNestedManyWithoutReviewInput
    helpfulVotes?: ReviewHelpfulVoteCreateNestedManyWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutSkillRatingsInput = {
    id?: string
    userId: string
    courseId: string
    overallRating: number
    difficultyRating?: number | null
    contentQuality?: number | null
    instructorRating?: number | null
    valueForMoney?: number | null
    wouldRecommend?: boolean | null
    title: string
    content: string
    pros?: ReviewCreateprosInput | string[]
    cons?: ReviewCreateconsInput | string[]
    isAnonymous?: boolean
    isVerified?: boolean
    helpfulCount?: number
    flagCount?: number
    isHidden?: boolean
    moderatorNotes?: string | null
    completionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: ReviewVoteUncheckedCreateNestedManyWithoutReviewInput
    helpfulVotes?: ReviewHelpfulVoteUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewCreateOrConnectWithoutSkillRatingsInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutSkillRatingsInput, ReviewUncheckedCreateWithoutSkillRatingsInput>
  }

  export type SkillCreateWithoutReviewRatingsInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseSkillCreateNestedManyWithoutSkillInput
    userProficiencies?: UserSkillProficiencyCreateNestedManyWithoutSkillInput
    prerequisiteFor?: SkillPrerequisiteCreateNestedManyWithoutPrerequisiteSkillInput
    prerequisites?: SkillPrerequisiteCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateWithoutReviewRatingsInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseSkillUncheckedCreateNestedManyWithoutSkillInput
    userProficiencies?: UserSkillProficiencyUncheckedCreateNestedManyWithoutSkillInput
    prerequisiteFor?: SkillPrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteSkillInput
    prerequisites?: SkillPrerequisiteUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillCreateOrConnectWithoutReviewRatingsInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutReviewRatingsInput, SkillUncheckedCreateWithoutReviewRatingsInput>
  }

  export type ReviewUpsertWithoutSkillRatingsInput = {
    update: XOR<ReviewUpdateWithoutSkillRatingsInput, ReviewUncheckedUpdateWithoutSkillRatingsInput>
    create: XOR<ReviewCreateWithoutSkillRatingsInput, ReviewUncheckedCreateWithoutSkillRatingsInput>
    where?: ReviewWhereInput
  }

  export type ReviewUpdateToOneWithWhereWithoutSkillRatingsInput = {
    where?: ReviewWhereInput
    data: XOR<ReviewUpdateWithoutSkillRatingsInput, ReviewUncheckedUpdateWithoutSkillRatingsInput>
  }

  export type ReviewUpdateWithoutSkillRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    difficultyRating?: NullableIntFieldUpdateOperationsInput | number | null
    contentQuality?: NullableIntFieldUpdateOperationsInput | number | null
    instructorRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueForMoney?: NullableIntFieldUpdateOperationsInput | number | null
    wouldRecommend?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    pros?: ReviewUpdateprosInput | string[]
    cons?: ReviewUpdateconsInput | string[]
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    flagCount?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    moderatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    course?: CourseUpdateOneRequiredWithoutReviewsNestedInput
    votes?: ReviewVoteUpdateManyWithoutReviewNestedInput
    helpfulVotes?: ReviewHelpfulVoteUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutSkillRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    difficultyRating?: NullableIntFieldUpdateOperationsInput | number | null
    contentQuality?: NullableIntFieldUpdateOperationsInput | number | null
    instructorRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueForMoney?: NullableIntFieldUpdateOperationsInput | number | null
    wouldRecommend?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    pros?: ReviewUpdateprosInput | string[]
    cons?: ReviewUpdateconsInput | string[]
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    flagCount?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    moderatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: ReviewVoteUncheckedUpdateManyWithoutReviewNestedInput
    helpfulVotes?: ReviewHelpfulVoteUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type SkillUpsertWithoutReviewRatingsInput = {
    update: XOR<SkillUpdateWithoutReviewRatingsInput, SkillUncheckedUpdateWithoutReviewRatingsInput>
    create: XOR<SkillCreateWithoutReviewRatingsInput, SkillUncheckedCreateWithoutReviewRatingsInput>
    where?: SkillWhereInput
  }

  export type SkillUpdateToOneWithWhereWithoutReviewRatingsInput = {
    where?: SkillWhereInput
    data: XOR<SkillUpdateWithoutReviewRatingsInput, SkillUncheckedUpdateWithoutReviewRatingsInput>
  }

  export type SkillUpdateWithoutReviewRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseSkillUpdateManyWithoutSkillNestedInput
    userProficiencies?: UserSkillProficiencyUpdateManyWithoutSkillNestedInput
    prerequisiteFor?: SkillPrerequisiteUpdateManyWithoutPrerequisiteSkillNestedInput
    prerequisites?: SkillPrerequisiteUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateWithoutReviewRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseSkillUncheckedUpdateManyWithoutSkillNestedInput
    userProficiencies?: UserSkillProficiencyUncheckedUpdateManyWithoutSkillNestedInput
    prerequisiteFor?: SkillPrerequisiteUncheckedUpdateManyWithoutPrerequisiteSkillNestedInput
    prerequisites?: SkillPrerequisiteUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type UserCreateWithoutEnrollmentsInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    profileImage?: string | null
    bio?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationToken?: string | null
    passwordHash: string
    totalPoints?: number
    reviewStreak?: number
    lastActiveAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutCreatedByInput
    skillProficiencies?: UserSkillProficiencyCreateNestedManyWithoutUserInput
    reviewHelpfulVotes?: ReviewHelpfulVoteCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    profileImage?: string | null
    bio?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationToken?: string | null
    passwordHash: string
    totalPoints?: number
    reviewStreak?: number
    lastActiveAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatedByInput
    skillProficiencies?: UserSkillProficiencyUncheckedCreateNestedManyWithoutUserInput
    reviewHelpfulVotes?: ReviewHelpfulVoteUncheckedCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEnrollmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEnrollmentsInput, UserUncheckedCreateWithoutEnrollmentsInput>
  }

  export type CourseCreateWithoutEnrollmentsInput = {
    id?: string
    title: string
    description: string
    shortDescription?: string | null
    imageUrl?: string | null
    thumbnailUrl?: string | null
    courseUrl: string
    instructor: string
    institution?: string | null
    duration?: string | null
    difficulty: $Enums.Difficulty
    status?: $Enums.CourseStatus
    price?: Decimal | DecimalJsLike | number | string | null
    isFree?: boolean
    language?: string
    rating?: Decimal | DecimalJsLike | number | string | null
    reviewCount?: number
    enrollmentCount?: number
    isActive?: boolean
    prerequisites?: CourseCreateprerequisitesInput | string[]
    learningOutcomes?: CourseCreatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCoursesInput
    reviews?: ReviewCreateNestedManyWithoutCourseInput
    skills?: CourseSkillCreateNestedManyWithoutCourseInput
    categories?: CourseCategoryCreateNestedManyWithoutCourseInput
    tags?: CourseTagCreateNestedManyWithoutCourseInput
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    title: string
    description: string
    shortDescription?: string | null
    imageUrl?: string | null
    thumbnailUrl?: string | null
    courseUrl: string
    instructor: string
    institution?: string | null
    duration?: string | null
    difficulty: $Enums.Difficulty
    status?: $Enums.CourseStatus
    price?: Decimal | DecimalJsLike | number | string | null
    isFree?: boolean
    language?: string
    rating?: Decimal | DecimalJsLike | number | string | null
    reviewCount?: number
    enrollmentCount?: number
    isActive?: boolean
    prerequisites?: CourseCreateprerequisitesInput | string[]
    learningOutcomes?: CourseCreatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    reviews?: ReviewUncheckedCreateNestedManyWithoutCourseInput
    skills?: CourseSkillUncheckedCreateNestedManyWithoutCourseInput
    categories?: CourseCategoryUncheckedCreateNestedManyWithoutCourseInput
    tags?: CourseTagUncheckedCreateNestedManyWithoutCourseInput
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutEnrollmentsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
  }

  export type UserUpsertWithoutEnrollmentsInput = {
    update: XOR<UserUpdateWithoutEnrollmentsInput, UserUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<UserCreateWithoutEnrollmentsInput, UserUncheckedCreateWithoutEnrollmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEnrollmentsInput, UserUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type UserUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    reviewStreak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutCreatedByNestedInput
    skillProficiencies?: UserSkillProficiencyUpdateManyWithoutUserNestedInput
    reviewHelpfulVotes?: ReviewHelpfulVoteUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    reviewStreak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatedByNestedInput
    skillProficiencies?: UserSkillProficiencyUncheckedUpdateManyWithoutUserNestedInput
    reviewHelpfulVotes?: ReviewHelpfulVoteUncheckedUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseUpsertWithoutEnrollmentsInput = {
    update: XOR<CourseUpdateWithoutEnrollmentsInput, CourseUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutEnrollmentsInput, CourseUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type CourseUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    courseUrl?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    enrollmentCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    prerequisites?: CourseUpdateprerequisitesInput | string[]
    learningOutcomes?: CourseUpdatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCoursesNestedInput
    reviews?: ReviewUpdateManyWithoutCourseNestedInput
    skills?: CourseSkillUpdateManyWithoutCourseNestedInput
    categories?: CourseCategoryUpdateManyWithoutCourseNestedInput
    tags?: CourseTagUpdateManyWithoutCourseNestedInput
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    courseUrl?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    enrollmentCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    prerequisites?: CourseUpdateprerequisitesInput | string[]
    learningOutcomes?: CourseUpdatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    reviews?: ReviewUncheckedUpdateManyWithoutCourseNestedInput
    skills?: CourseSkillUncheckedUpdateManyWithoutCourseNestedInput
    categories?: CourseCategoryUncheckedUpdateManyWithoutCourseNestedInput
    tags?: CourseTagUncheckedUpdateManyWithoutCourseNestedInput
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type UserCreateWithoutSkillProficienciesInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    profileImage?: string | null
    bio?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationToken?: string | null
    passwordHash: string
    totalPoints?: number
    reviewStreak?: number
    lastActiveAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    enrollments?: CourseEnrollmentCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutCreatedByInput
    reviewHelpfulVotes?: ReviewHelpfulVoteCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSkillProficienciesInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    profileImage?: string | null
    bio?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationToken?: string | null
    passwordHash: string
    totalPoints?: number
    reviewStreak?: number
    lastActiveAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatedByInput
    reviewHelpfulVotes?: ReviewHelpfulVoteUncheckedCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSkillProficienciesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSkillProficienciesInput, UserUncheckedCreateWithoutSkillProficienciesInput>
  }

  export type SkillCreateWithoutUserProficienciesInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseSkillCreateNestedManyWithoutSkillInput
    prerequisiteFor?: SkillPrerequisiteCreateNestedManyWithoutPrerequisiteSkillInput
    prerequisites?: SkillPrerequisiteCreateNestedManyWithoutSkillInput
    reviewRatings?: ReviewSkillRatingCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateWithoutUserProficienciesInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseSkillUncheckedCreateNestedManyWithoutSkillInput
    prerequisiteFor?: SkillPrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteSkillInput
    prerequisites?: SkillPrerequisiteUncheckedCreateNestedManyWithoutSkillInput
    reviewRatings?: ReviewSkillRatingUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillCreateOrConnectWithoutUserProficienciesInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutUserProficienciesInput, SkillUncheckedCreateWithoutUserProficienciesInput>
  }

  export type UserUpsertWithoutSkillProficienciesInput = {
    update: XOR<UserUpdateWithoutSkillProficienciesInput, UserUncheckedUpdateWithoutSkillProficienciesInput>
    create: XOR<UserCreateWithoutSkillProficienciesInput, UserUncheckedCreateWithoutSkillProficienciesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSkillProficienciesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSkillProficienciesInput, UserUncheckedUpdateWithoutSkillProficienciesInput>
  }

  export type UserUpdateWithoutSkillProficienciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    reviewStreak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    enrollments?: CourseEnrollmentUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutCreatedByNestedInput
    reviewHelpfulVotes?: ReviewHelpfulVoteUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSkillProficienciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    reviewStreak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatedByNestedInput
    reviewHelpfulVotes?: ReviewHelpfulVoteUncheckedUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SkillUpsertWithoutUserProficienciesInput = {
    update: XOR<SkillUpdateWithoutUserProficienciesInput, SkillUncheckedUpdateWithoutUserProficienciesInput>
    create: XOR<SkillCreateWithoutUserProficienciesInput, SkillUncheckedCreateWithoutUserProficienciesInput>
    where?: SkillWhereInput
  }

  export type SkillUpdateToOneWithWhereWithoutUserProficienciesInput = {
    where?: SkillWhereInput
    data: XOR<SkillUpdateWithoutUserProficienciesInput, SkillUncheckedUpdateWithoutUserProficienciesInput>
  }

  export type SkillUpdateWithoutUserProficienciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseSkillUpdateManyWithoutSkillNestedInput
    prerequisiteFor?: SkillPrerequisiteUpdateManyWithoutPrerequisiteSkillNestedInput
    prerequisites?: SkillPrerequisiteUpdateManyWithoutSkillNestedInput
    reviewRatings?: ReviewSkillRatingUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateWithoutUserProficienciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseSkillUncheckedUpdateManyWithoutSkillNestedInput
    prerequisiteFor?: SkillPrerequisiteUncheckedUpdateManyWithoutPrerequisiteSkillNestedInput
    prerequisites?: SkillPrerequisiteUncheckedUpdateManyWithoutSkillNestedInput
    reviewRatings?: ReviewSkillRatingUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type SkillCreateWithoutPrerequisitesInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseSkillCreateNestedManyWithoutSkillInput
    userProficiencies?: UserSkillProficiencyCreateNestedManyWithoutSkillInput
    prerequisiteFor?: SkillPrerequisiteCreateNestedManyWithoutPrerequisiteSkillInput
    reviewRatings?: ReviewSkillRatingCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateWithoutPrerequisitesInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseSkillUncheckedCreateNestedManyWithoutSkillInput
    userProficiencies?: UserSkillProficiencyUncheckedCreateNestedManyWithoutSkillInput
    prerequisiteFor?: SkillPrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteSkillInput
    reviewRatings?: ReviewSkillRatingUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillCreateOrConnectWithoutPrerequisitesInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutPrerequisitesInput, SkillUncheckedCreateWithoutPrerequisitesInput>
  }

  export type SkillCreateWithoutPrerequisiteForInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseSkillCreateNestedManyWithoutSkillInput
    userProficiencies?: UserSkillProficiencyCreateNestedManyWithoutSkillInput
    prerequisites?: SkillPrerequisiteCreateNestedManyWithoutSkillInput
    reviewRatings?: ReviewSkillRatingCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateWithoutPrerequisiteForInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseSkillUncheckedCreateNestedManyWithoutSkillInput
    userProficiencies?: UserSkillProficiencyUncheckedCreateNestedManyWithoutSkillInput
    prerequisites?: SkillPrerequisiteUncheckedCreateNestedManyWithoutSkillInput
    reviewRatings?: ReviewSkillRatingUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillCreateOrConnectWithoutPrerequisiteForInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutPrerequisiteForInput, SkillUncheckedCreateWithoutPrerequisiteForInput>
  }

  export type SkillUpsertWithoutPrerequisitesInput = {
    update: XOR<SkillUpdateWithoutPrerequisitesInput, SkillUncheckedUpdateWithoutPrerequisitesInput>
    create: XOR<SkillCreateWithoutPrerequisitesInput, SkillUncheckedCreateWithoutPrerequisitesInput>
    where?: SkillWhereInput
  }

  export type SkillUpdateToOneWithWhereWithoutPrerequisitesInput = {
    where?: SkillWhereInput
    data: XOR<SkillUpdateWithoutPrerequisitesInput, SkillUncheckedUpdateWithoutPrerequisitesInput>
  }

  export type SkillUpdateWithoutPrerequisitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseSkillUpdateManyWithoutSkillNestedInput
    userProficiencies?: UserSkillProficiencyUpdateManyWithoutSkillNestedInput
    prerequisiteFor?: SkillPrerequisiteUpdateManyWithoutPrerequisiteSkillNestedInput
    reviewRatings?: ReviewSkillRatingUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateWithoutPrerequisitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseSkillUncheckedUpdateManyWithoutSkillNestedInput
    userProficiencies?: UserSkillProficiencyUncheckedUpdateManyWithoutSkillNestedInput
    prerequisiteFor?: SkillPrerequisiteUncheckedUpdateManyWithoutPrerequisiteSkillNestedInput
    reviewRatings?: ReviewSkillRatingUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type SkillUpsertWithoutPrerequisiteForInput = {
    update: XOR<SkillUpdateWithoutPrerequisiteForInput, SkillUncheckedUpdateWithoutPrerequisiteForInput>
    create: XOR<SkillCreateWithoutPrerequisiteForInput, SkillUncheckedCreateWithoutPrerequisiteForInput>
    where?: SkillWhereInput
  }

  export type SkillUpdateToOneWithWhereWithoutPrerequisiteForInput = {
    where?: SkillWhereInput
    data: XOR<SkillUpdateWithoutPrerequisiteForInput, SkillUncheckedUpdateWithoutPrerequisiteForInput>
  }

  export type SkillUpdateWithoutPrerequisiteForInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseSkillUpdateManyWithoutSkillNestedInput
    userProficiencies?: UserSkillProficiencyUpdateManyWithoutSkillNestedInput
    prerequisites?: SkillPrerequisiteUpdateManyWithoutSkillNestedInput
    reviewRatings?: ReviewSkillRatingUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateWithoutPrerequisiteForInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseSkillUncheckedUpdateManyWithoutSkillNestedInput
    userProficiencies?: UserSkillProficiencyUncheckedUpdateManyWithoutSkillNestedInput
    prerequisites?: SkillPrerequisiteUncheckedUpdateManyWithoutSkillNestedInput
    reviewRatings?: ReviewSkillRatingUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type CategoryCreateWithoutChildrenInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    color?: string | null
    sortOrder?: number
    isActive?: boolean
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    courses?: CourseCategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutChildrenInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    color?: string | null
    parentId?: string | null
    sortOrder?: number
    isActive?: boolean
    courses?: CourseCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutChildrenInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
  }

  export type CategoryCreateWithoutParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    color?: string | null
    sortOrder?: number
    isActive?: boolean
    children?: CategoryCreateNestedManyWithoutParentInput
    courses?: CourseCategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    color?: string | null
    sortOrder?: number
    isActive?: boolean
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    courses?: CourseCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutParentInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryCreateManyParentInputEnvelope = {
    data: CategoryCreateManyParentInput | CategoryCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type CourseCategoryCreateWithoutCategoryInput = {
    id?: string
    isPrimary?: boolean
    course: CourseCreateNestedOneWithoutCategoriesInput
  }

  export type CourseCategoryUncheckedCreateWithoutCategoryInput = {
    id?: string
    courseId: string
    isPrimary?: boolean
  }

  export type CourseCategoryCreateOrConnectWithoutCategoryInput = {
    where: CourseCategoryWhereUniqueInput
    create: XOR<CourseCategoryCreateWithoutCategoryInput, CourseCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type CourseCategoryCreateManyCategoryInputEnvelope = {
    data: CourseCategoryCreateManyCategoryInput | CourseCategoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutChildrenInput = {
    update: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutChildrenInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type CategoryUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    courses?: CourseCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    courses?: CourseCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUpsertWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
  }

  export type CategoryUpdateManyWithWhereWithoutParentInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutParentInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    icon?: StringNullableFilter<"Category"> | string | null
    color?: StringNullableFilter<"Category"> | string | null
    parentId?: StringNullableFilter<"Category"> | string | null
    sortOrder?: IntFilter<"Category"> | number
    isActive?: BoolFilter<"Category"> | boolean
  }

  export type CourseCategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: CourseCategoryWhereUniqueInput
    update: XOR<CourseCategoryUpdateWithoutCategoryInput, CourseCategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<CourseCategoryCreateWithoutCategoryInput, CourseCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type CourseCategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: CourseCategoryWhereUniqueInput
    data: XOR<CourseCategoryUpdateWithoutCategoryInput, CourseCategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type CourseCategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: CourseCategoryScalarWhereInput
    data: XOR<CourseCategoryUpdateManyMutationInput, CourseCategoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type CourseCreateWithoutCategoriesInput = {
    id?: string
    title: string
    description: string
    shortDescription?: string | null
    imageUrl?: string | null
    thumbnailUrl?: string | null
    courseUrl: string
    instructor: string
    institution?: string | null
    duration?: string | null
    difficulty: $Enums.Difficulty
    status?: $Enums.CourseStatus
    price?: Decimal | DecimalJsLike | number | string | null
    isFree?: boolean
    language?: string
    rating?: Decimal | DecimalJsLike | number | string | null
    reviewCount?: number
    enrollmentCount?: number
    isActive?: boolean
    prerequisites?: CourseCreateprerequisitesInput | string[]
    learningOutcomes?: CourseCreatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCoursesInput
    reviews?: ReviewCreateNestedManyWithoutCourseInput
    skills?: CourseSkillCreateNestedManyWithoutCourseInput
    enrollments?: CourseEnrollmentCreateNestedManyWithoutCourseInput
    tags?: CourseTagCreateNestedManyWithoutCourseInput
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCategoriesInput = {
    id?: string
    title: string
    description: string
    shortDescription?: string | null
    imageUrl?: string | null
    thumbnailUrl?: string | null
    courseUrl: string
    instructor: string
    institution?: string | null
    duration?: string | null
    difficulty: $Enums.Difficulty
    status?: $Enums.CourseStatus
    price?: Decimal | DecimalJsLike | number | string | null
    isFree?: boolean
    language?: string
    rating?: Decimal | DecimalJsLike | number | string | null
    reviewCount?: number
    enrollmentCount?: number
    isActive?: boolean
    prerequisites?: CourseCreateprerequisitesInput | string[]
    learningOutcomes?: CourseCreatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    reviews?: ReviewUncheckedCreateNestedManyWithoutCourseInput
    skills?: CourseSkillUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutCourseInput
    tags?: CourseTagUncheckedCreateNestedManyWithoutCourseInput
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCategoriesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCategoriesInput, CourseUncheckedCreateWithoutCategoriesInput>
  }

  export type CategoryCreateWithoutCoursesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    color?: string | null
    sortOrder?: number
    isActive?: boolean
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
  }

  export type CategoryUncheckedCreateWithoutCoursesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    color?: string | null
    parentId?: string | null
    sortOrder?: number
    isActive?: boolean
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
  }

  export type CategoryCreateOrConnectWithoutCoursesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutCoursesInput, CategoryUncheckedCreateWithoutCoursesInput>
  }

  export type CourseUpsertWithoutCategoriesInput = {
    update: XOR<CourseUpdateWithoutCategoriesInput, CourseUncheckedUpdateWithoutCategoriesInput>
    create: XOR<CourseCreateWithoutCategoriesInput, CourseUncheckedCreateWithoutCategoriesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutCategoriesInput, CourseUncheckedUpdateWithoutCategoriesInput>
  }

  export type CourseUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    courseUrl?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    enrollmentCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    prerequisites?: CourseUpdateprerequisitesInput | string[]
    learningOutcomes?: CourseUpdatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCoursesNestedInput
    reviews?: ReviewUpdateManyWithoutCourseNestedInput
    skills?: CourseSkillUpdateManyWithoutCourseNestedInput
    enrollments?: CourseEnrollmentUpdateManyWithoutCourseNestedInput
    tags?: CourseTagUpdateManyWithoutCourseNestedInput
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    courseUrl?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    enrollmentCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    prerequisites?: CourseUpdateprerequisitesInput | string[]
    learningOutcomes?: CourseUpdatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    reviews?: ReviewUncheckedUpdateManyWithoutCourseNestedInput
    skills?: CourseSkillUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    tags?: CourseTagUncheckedUpdateManyWithoutCourseNestedInput
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CategoryUpsertWithoutCoursesInput = {
    update: XOR<CategoryUpdateWithoutCoursesInput, CategoryUncheckedUpdateWithoutCoursesInput>
    create: XOR<CategoryCreateWithoutCoursesInput, CategoryUncheckedCreateWithoutCoursesInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutCoursesInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutCoursesInput, CategoryUncheckedUpdateWithoutCoursesInput>
  }

  export type CategoryUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
  }

  export type CategoryUncheckedUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CourseTagCreateWithoutTagInput = {
    id?: string
    course: CourseCreateNestedOneWithoutTagsInput
  }

  export type CourseTagUncheckedCreateWithoutTagInput = {
    id?: string
    courseId: string
  }

  export type CourseTagCreateOrConnectWithoutTagInput = {
    where: CourseTagWhereUniqueInput
    create: XOR<CourseTagCreateWithoutTagInput, CourseTagUncheckedCreateWithoutTagInput>
  }

  export type CourseTagCreateManyTagInputEnvelope = {
    data: CourseTagCreateManyTagInput | CourseTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type CourseTagUpsertWithWhereUniqueWithoutTagInput = {
    where: CourseTagWhereUniqueInput
    update: XOR<CourseTagUpdateWithoutTagInput, CourseTagUncheckedUpdateWithoutTagInput>
    create: XOR<CourseTagCreateWithoutTagInput, CourseTagUncheckedCreateWithoutTagInput>
  }

  export type CourseTagUpdateWithWhereUniqueWithoutTagInput = {
    where: CourseTagWhereUniqueInput
    data: XOR<CourseTagUpdateWithoutTagInput, CourseTagUncheckedUpdateWithoutTagInput>
  }

  export type CourseTagUpdateManyWithWhereWithoutTagInput = {
    where: CourseTagScalarWhereInput
    data: XOR<CourseTagUpdateManyMutationInput, CourseTagUncheckedUpdateManyWithoutTagInput>
  }

  export type CourseCreateWithoutTagsInput = {
    id?: string
    title: string
    description: string
    shortDescription?: string | null
    imageUrl?: string | null
    thumbnailUrl?: string | null
    courseUrl: string
    instructor: string
    institution?: string | null
    duration?: string | null
    difficulty: $Enums.Difficulty
    status?: $Enums.CourseStatus
    price?: Decimal | DecimalJsLike | number | string | null
    isFree?: boolean
    language?: string
    rating?: Decimal | DecimalJsLike | number | string | null
    reviewCount?: number
    enrollmentCount?: number
    isActive?: boolean
    prerequisites?: CourseCreateprerequisitesInput | string[]
    learningOutcomes?: CourseCreatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCoursesInput
    reviews?: ReviewCreateNestedManyWithoutCourseInput
    skills?: CourseSkillCreateNestedManyWithoutCourseInput
    enrollments?: CourseEnrollmentCreateNestedManyWithoutCourseInput
    categories?: CourseCategoryCreateNestedManyWithoutCourseInput
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutTagsInput = {
    id?: string
    title: string
    description: string
    shortDescription?: string | null
    imageUrl?: string | null
    thumbnailUrl?: string | null
    courseUrl: string
    instructor: string
    institution?: string | null
    duration?: string | null
    difficulty: $Enums.Difficulty
    status?: $Enums.CourseStatus
    price?: Decimal | DecimalJsLike | number | string | null
    isFree?: boolean
    language?: string
    rating?: Decimal | DecimalJsLike | number | string | null
    reviewCount?: number
    enrollmentCount?: number
    isActive?: boolean
    prerequisites?: CourseCreateprerequisitesInput | string[]
    learningOutcomes?: CourseCreatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    reviews?: ReviewUncheckedCreateNestedManyWithoutCourseInput
    skills?: CourseSkillUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutCourseInput
    categories?: CourseCategoryUncheckedCreateNestedManyWithoutCourseInput
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutTagsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutTagsInput, CourseUncheckedCreateWithoutTagsInput>
  }

  export type TagCreateWithoutCoursesInput = {
    id?: string
    name: string
    color?: string | null
    createdAt?: Date | string
  }

  export type TagUncheckedCreateWithoutCoursesInput = {
    id?: string
    name: string
    color?: string | null
    createdAt?: Date | string
  }

  export type TagCreateOrConnectWithoutCoursesInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutCoursesInput, TagUncheckedCreateWithoutCoursesInput>
  }

  export type CourseUpsertWithoutTagsInput = {
    update: XOR<CourseUpdateWithoutTagsInput, CourseUncheckedUpdateWithoutTagsInput>
    create: XOR<CourseCreateWithoutTagsInput, CourseUncheckedCreateWithoutTagsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutTagsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutTagsInput, CourseUncheckedUpdateWithoutTagsInput>
  }

  export type CourseUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    courseUrl?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    enrollmentCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    prerequisites?: CourseUpdateprerequisitesInput | string[]
    learningOutcomes?: CourseUpdatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCoursesNestedInput
    reviews?: ReviewUpdateManyWithoutCourseNestedInput
    skills?: CourseSkillUpdateManyWithoutCourseNestedInput
    enrollments?: CourseEnrollmentUpdateManyWithoutCourseNestedInput
    categories?: CourseCategoryUpdateManyWithoutCourseNestedInput
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    courseUrl?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    enrollmentCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    prerequisites?: CourseUpdateprerequisitesInput | string[]
    learningOutcomes?: CourseUpdatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    reviews?: ReviewUncheckedUpdateManyWithoutCourseNestedInput
    skills?: CourseSkillUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    categories?: CourseCategoryUncheckedUpdateManyWithoutCourseNestedInput
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type TagUpsertWithoutCoursesInput = {
    update: XOR<TagUpdateWithoutCoursesInput, TagUncheckedUpdateWithoutCoursesInput>
    create: XOR<TagCreateWithoutCoursesInput, TagUncheckedCreateWithoutCoursesInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutCoursesInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutCoursesInput, TagUncheckedUpdateWithoutCoursesInput>
  }

  export type TagUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseCreateWithoutModulesInput = {
    id?: string
    title: string
    description: string
    shortDescription?: string | null
    imageUrl?: string | null
    thumbnailUrl?: string | null
    courseUrl: string
    instructor: string
    institution?: string | null
    duration?: string | null
    difficulty: $Enums.Difficulty
    status?: $Enums.CourseStatus
    price?: Decimal | DecimalJsLike | number | string | null
    isFree?: boolean
    language?: string
    rating?: Decimal | DecimalJsLike | number | string | null
    reviewCount?: number
    enrollmentCount?: number
    isActive?: boolean
    prerequisites?: CourseCreateprerequisitesInput | string[]
    learningOutcomes?: CourseCreatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCoursesInput
    reviews?: ReviewCreateNestedManyWithoutCourseInput
    skills?: CourseSkillCreateNestedManyWithoutCourseInput
    enrollments?: CourseEnrollmentCreateNestedManyWithoutCourseInput
    categories?: CourseCategoryCreateNestedManyWithoutCourseInput
    tags?: CourseTagCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutModulesInput = {
    id?: string
    title: string
    description: string
    shortDescription?: string | null
    imageUrl?: string | null
    thumbnailUrl?: string | null
    courseUrl: string
    instructor: string
    institution?: string | null
    duration?: string | null
    difficulty: $Enums.Difficulty
    status?: $Enums.CourseStatus
    price?: Decimal | DecimalJsLike | number | string | null
    isFree?: boolean
    language?: string
    rating?: Decimal | DecimalJsLike | number | string | null
    reviewCount?: number
    enrollmentCount?: number
    isActive?: boolean
    prerequisites?: CourseCreateprerequisitesInput | string[]
    learningOutcomes?: CourseCreatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    reviews?: ReviewUncheckedCreateNestedManyWithoutCourseInput
    skills?: CourseSkillUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutCourseInput
    categories?: CourseCategoryUncheckedCreateNestedManyWithoutCourseInput
    tags?: CourseTagUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutModulesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutModulesInput, CourseUncheckedCreateWithoutModulesInput>
  }

  export type CourseUpsertWithoutModulesInput = {
    update: XOR<CourseUpdateWithoutModulesInput, CourseUncheckedUpdateWithoutModulesInput>
    create: XOR<CourseCreateWithoutModulesInput, CourseUncheckedCreateWithoutModulesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutModulesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutModulesInput, CourseUncheckedUpdateWithoutModulesInput>
  }

  export type CourseUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    courseUrl?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    enrollmentCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    prerequisites?: CourseUpdateprerequisitesInput | string[]
    learningOutcomes?: CourseUpdatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCoursesNestedInput
    reviews?: ReviewUpdateManyWithoutCourseNestedInput
    skills?: CourseSkillUpdateManyWithoutCourseNestedInput
    enrollments?: CourseEnrollmentUpdateManyWithoutCourseNestedInput
    categories?: CourseCategoryUpdateManyWithoutCourseNestedInput
    tags?: CourseTagUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    courseUrl?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    enrollmentCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    prerequisites?: CourseUpdateprerequisitesInput | string[]
    learningOutcomes?: CourseUpdatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    reviews?: ReviewUncheckedUpdateManyWithoutCourseNestedInput
    skills?: CourseSkillUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    categories?: CourseCategoryUncheckedUpdateManyWithoutCourseNestedInput
    tags?: CourseTagUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type UserAchievementCreateWithoutAchievementInput = {
    id?: string
    earnedAt?: Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutAchievementsInput
  }

  export type UserAchievementUncheckedCreateWithoutAchievementInput = {
    id?: string
    userId: string
    earnedAt?: Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserAchievementCreateOrConnectWithoutAchievementInput = {
    where: UserAchievementWhereUniqueInput
    create: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput>
  }

  export type UserAchievementCreateManyAchievementInputEnvelope = {
    data: UserAchievementCreateManyAchievementInput | UserAchievementCreateManyAchievementInput[]
    skipDuplicates?: boolean
  }

  export type UserAchievementUpsertWithWhereUniqueWithoutAchievementInput = {
    where: UserAchievementWhereUniqueInput
    update: XOR<UserAchievementUpdateWithoutAchievementInput, UserAchievementUncheckedUpdateWithoutAchievementInput>
    create: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput>
  }

  export type UserAchievementUpdateWithWhereUniqueWithoutAchievementInput = {
    where: UserAchievementWhereUniqueInput
    data: XOR<UserAchievementUpdateWithoutAchievementInput, UserAchievementUncheckedUpdateWithoutAchievementInput>
  }

  export type UserAchievementUpdateManyWithWhereWithoutAchievementInput = {
    where: UserAchievementScalarWhereInput
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyWithoutAchievementInput>
  }

  export type UserCreateWithoutAchievementsInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    profileImage?: string | null
    bio?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationToken?: string | null
    passwordHash: string
    totalPoints?: number
    reviewStreak?: number
    lastActiveAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    enrollments?: CourseEnrollmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutCreatedByInput
    skillProficiencies?: UserSkillProficiencyCreateNestedManyWithoutUserInput
    reviewHelpfulVotes?: ReviewHelpfulVoteCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAchievementsInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    profileImage?: string | null
    bio?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationToken?: string | null
    passwordHash: string
    totalPoints?: number
    reviewStreak?: number
    lastActiveAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatedByInput
    skillProficiencies?: UserSkillProficiencyUncheckedCreateNestedManyWithoutUserInput
    reviewHelpfulVotes?: ReviewHelpfulVoteUncheckedCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAchievementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
  }

  export type AchievementCreateWithoutUsersInput = {
    id?: string
    name: string
    description: string
    icon?: string | null
    type: $Enums.AchievementType
    criteria: JsonNullValueInput | InputJsonValue
    points?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type AchievementUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description: string
    icon?: string | null
    type: $Enums.AchievementType
    criteria: JsonNullValueInput | InputJsonValue
    points?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type AchievementCreateOrConnectWithoutUsersInput = {
    where: AchievementWhereUniqueInput
    create: XOR<AchievementCreateWithoutUsersInput, AchievementUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutAchievementsInput = {
    update: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    reviewStreak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    enrollments?: CourseEnrollmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutCreatedByNestedInput
    skillProficiencies?: UserSkillProficiencyUpdateManyWithoutUserNestedInput
    reviewHelpfulVotes?: ReviewHelpfulVoteUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    reviewStreak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatedByNestedInput
    skillProficiencies?: UserSkillProficiencyUncheckedUpdateManyWithoutUserNestedInput
    reviewHelpfulVotes?: ReviewHelpfulVoteUncheckedUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AchievementUpsertWithoutUsersInput = {
    update: XOR<AchievementUpdateWithoutUsersInput, AchievementUncheckedUpdateWithoutUsersInput>
    create: XOR<AchievementCreateWithoutUsersInput, AchievementUncheckedCreateWithoutUsersInput>
    where?: AchievementWhereInput
  }

  export type AchievementUpdateToOneWithWhereWithoutUsersInput = {
    where?: AchievementWhereInput
    data: XOR<AchievementUpdateWithoutUsersInput, AchievementUncheckedUpdateWithoutUsersInput>
  }

  export type AchievementUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAchievementTypeFieldUpdateOperationsInput | $Enums.AchievementType
    criteria?: JsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAchievementTypeFieldUpdateOperationsInput | $Enums.AchievementType
    criteria?: JsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    profileImage?: string | null
    bio?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationToken?: string | null
    passwordHash: string
    totalPoints?: number
    reviewStreak?: number
    lastActiveAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    enrollments?: CourseEnrollmentCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutCreatedByInput
    skillProficiencies?: UserSkillProficiencyCreateNestedManyWithoutUserInput
    reviewHelpfulVotes?: ReviewHelpfulVoteCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    profileImage?: string | null
    bio?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationToken?: string | null
    passwordHash: string
    totalPoints?: number
    reviewStreak?: number
    lastActiveAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatedByInput
    skillProficiencies?: UserSkillProficiencyUncheckedCreateNestedManyWithoutUserInput
    reviewHelpfulVotes?: ReviewHelpfulVoteUncheckedCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    reviewStreak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    enrollments?: CourseEnrollmentUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutCreatedByNestedInput
    skillProficiencies?: UserSkillProficiencyUpdateManyWithoutUserNestedInput
    reviewHelpfulVotes?: ReviewHelpfulVoteUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    reviewStreak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatedByNestedInput
    skillProficiencies?: UserSkillProficiencyUncheckedUpdateManyWithoutUserNestedInput
    reviewHelpfulVotes?: ReviewHelpfulVoteUncheckedUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutProgressReportsInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    profileImage?: string | null
    bio?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationToken?: string | null
    passwordHash: string
    totalPoints?: number
    reviewStreak?: number
    lastActiveAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    enrollments?: CourseEnrollmentCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutCreatedByInput
    skillProficiencies?: UserSkillProficiencyCreateNestedManyWithoutUserInput
    reviewHelpfulVotes?: ReviewHelpfulVoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProgressReportsInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    profileImage?: string | null
    bio?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationToken?: string | null
    passwordHash: string
    totalPoints?: number
    reviewStreak?: number
    lastActiveAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatedByInput
    skillProficiencies?: UserSkillProficiencyUncheckedCreateNestedManyWithoutUserInput
    reviewHelpfulVotes?: ReviewHelpfulVoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProgressReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProgressReportsInput, UserUncheckedCreateWithoutProgressReportsInput>
  }

  export type UserUpsertWithoutProgressReportsInput = {
    update: XOR<UserUpdateWithoutProgressReportsInput, UserUncheckedUpdateWithoutProgressReportsInput>
    create: XOR<UserCreateWithoutProgressReportsInput, UserUncheckedCreateWithoutProgressReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProgressReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProgressReportsInput, UserUncheckedUpdateWithoutProgressReportsInput>
  }

  export type UserUpdateWithoutProgressReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    reviewStreak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    enrollments?: CourseEnrollmentUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutCreatedByNestedInput
    skillProficiencies?: UserSkillProficiencyUpdateManyWithoutUserNestedInput
    reviewHelpfulVotes?: ReviewHelpfulVoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProgressReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    reviewStreak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatedByNestedInput
    skillProficiencies?: UserSkillProficiencyUncheckedUpdateManyWithoutUserNestedInput
    reviewHelpfulVotes?: ReviewHelpfulVoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReviewCreateManyUserInput = {
    id?: string
    courseId: string
    overallRating: number
    difficultyRating?: number | null
    contentQuality?: number | null
    instructorRating?: number | null
    valueForMoney?: number | null
    wouldRecommend?: boolean | null
    title: string
    content: string
    pros?: ReviewCreateprosInput | string[]
    cons?: ReviewCreateconsInput | string[]
    isAnonymous?: boolean
    isVerified?: boolean
    helpfulCount?: number
    flagCount?: number
    isHidden?: boolean
    moderatorNotes?: string | null
    completionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewVoteCreateManyUserInput = {
    id?: string
    reviewId: string
    isUpvote: boolean
    createdAt?: Date | string
  }

  export type CourseEnrollmentCreateManyUserInput = {
    id?: string
    courseId: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    progress?: number
    lastAccessed?: Date | string
    status?: string
    certificateUrl?: string | null
  }

  export type UserAchievementCreateManyUserInput = {
    id?: string
    achievementId: string
    earnedAt?: Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    title: string
    message: string
    type: string
    isRead?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type CourseCreateManyCreatedByInput = {
    id?: string
    title: string
    description: string
    shortDescription?: string | null
    imageUrl?: string | null
    thumbnailUrl?: string | null
    courseUrl: string
    instructor: string
    institution?: string | null
    duration?: string | null
    difficulty: $Enums.Difficulty
    status?: $Enums.CourseStatus
    price?: Decimal | DecimalJsLike | number | string | null
    isFree?: boolean
    language?: string
    rating?: Decimal | DecimalJsLike | number | string | null
    reviewCount?: number
    enrollmentCount?: number
    isActive?: boolean
    prerequisites?: CourseCreateprerequisitesInput | string[]
    learningOutcomes?: CourseCreatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSkillProficiencyCreateManyUserInput = {
    id?: string
    skillId: string
    level: $Enums.SkillLevel
    yearsExperience?: number | null
    lastUsed?: Date | string | null
    isVerified?: boolean
    verificationSource?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewHelpfulVoteCreateManyUserInput = {
    id?: string
    reviewId: string
    isHelpful: boolean
    createdAt?: Date | string
  }

  export type ProgressReportCreateManyUserInput = {
    id?: string
    reportDate?: Date | string
    coursesCompleted?: number
    reviewsWritten?: number
    pointsEarned?: number
    skillsLearned?: ProgressReportCreateskillsLearnedInput | string[]
    weeklyGoalMet?: boolean
    monthlyGoalMet?: boolean
  }

  export type ReviewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    difficultyRating?: NullableIntFieldUpdateOperationsInput | number | null
    contentQuality?: NullableIntFieldUpdateOperationsInput | number | null
    instructorRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueForMoney?: NullableIntFieldUpdateOperationsInput | number | null
    wouldRecommend?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    pros?: ReviewUpdateprosInput | string[]
    cons?: ReviewUpdateconsInput | string[]
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    flagCount?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    moderatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutReviewsNestedInput
    votes?: ReviewVoteUpdateManyWithoutReviewNestedInput
    helpfulVotes?: ReviewHelpfulVoteUpdateManyWithoutReviewNestedInput
    skillRatings?: ReviewSkillRatingUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    difficultyRating?: NullableIntFieldUpdateOperationsInput | number | null
    contentQuality?: NullableIntFieldUpdateOperationsInput | number | null
    instructorRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueForMoney?: NullableIntFieldUpdateOperationsInput | number | null
    wouldRecommend?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    pros?: ReviewUpdateprosInput | string[]
    cons?: ReviewUpdateconsInput | string[]
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    flagCount?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    moderatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: ReviewVoteUncheckedUpdateManyWithoutReviewNestedInput
    helpfulVotes?: ReviewHelpfulVoteUncheckedUpdateManyWithoutReviewNestedInput
    skillRatings?: ReviewSkillRatingUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    difficultyRating?: NullableIntFieldUpdateOperationsInput | number | null
    contentQuality?: NullableIntFieldUpdateOperationsInput | number | null
    instructorRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueForMoney?: NullableIntFieldUpdateOperationsInput | number | null
    wouldRecommend?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    pros?: ReviewUpdateprosInput | string[]
    cons?: ReviewUpdateconsInput | string[]
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    flagCount?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    moderatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewVoteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUpvote?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ReviewUpdateOneRequiredWithoutVotesNestedInput
  }

  export type ReviewVoteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    isUpvote?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewVoteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    isUpvote?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseEnrollmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    course?: CourseUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type CourseEnrollmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourseEnrollmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserAchievementUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
    achievement?: AchievementUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserAchievementUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserAchievementUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CourseUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    courseUrl?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    enrollmentCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    prerequisites?: CourseUpdateprerequisitesInput | string[]
    learningOutcomes?: CourseUpdatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUpdateManyWithoutCourseNestedInput
    skills?: CourseSkillUpdateManyWithoutCourseNestedInput
    enrollments?: CourseEnrollmentUpdateManyWithoutCourseNestedInput
    categories?: CourseCategoryUpdateManyWithoutCourseNestedInput
    tags?: CourseTagUpdateManyWithoutCourseNestedInput
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    courseUrl?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    enrollmentCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    prerequisites?: CourseUpdateprerequisitesInput | string[]
    learningOutcomes?: CourseUpdatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUncheckedUpdateManyWithoutCourseNestedInput
    skills?: CourseSkillUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    categories?: CourseCategoryUncheckedUpdateManyWithoutCourseNestedInput
    tags?: CourseTagUncheckedUpdateManyWithoutCourseNestedInput
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    courseUrl?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    enrollmentCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    prerequisites?: CourseUpdateprerequisitesInput | string[]
    learningOutcomes?: CourseUpdatelearningOutcomesInput | string[]
    syllabus?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSkillProficiencyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    yearsExperience?: NullableIntFieldUpdateOperationsInput | number | null
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skill?: SkillUpdateOneRequiredWithoutUserProficienciesNestedInput
  }

  export type UserSkillProficiencyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    yearsExperience?: NullableIntFieldUpdateOperationsInput | number | null
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSkillProficiencyUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    yearsExperience?: NullableIntFieldUpdateOperationsInput | number | null
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewHelpfulVoteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isHelpful?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ReviewUpdateOneRequiredWithoutHelpfulVotesNestedInput
  }

  export type ReviewHelpfulVoteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    isHelpful?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewHelpfulVoteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    isHelpful?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgressReportUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coursesCompleted?: IntFieldUpdateOperationsInput | number
    reviewsWritten?: IntFieldUpdateOperationsInput | number
    pointsEarned?: IntFieldUpdateOperationsInput | number
    skillsLearned?: ProgressReportUpdateskillsLearnedInput | string[]
    weeklyGoalMet?: BoolFieldUpdateOperationsInput | boolean
    monthlyGoalMet?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProgressReportUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coursesCompleted?: IntFieldUpdateOperationsInput | number
    reviewsWritten?: IntFieldUpdateOperationsInput | number
    pointsEarned?: IntFieldUpdateOperationsInput | number
    skillsLearned?: ProgressReportUpdateskillsLearnedInput | string[]
    weeklyGoalMet?: BoolFieldUpdateOperationsInput | boolean
    monthlyGoalMet?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProgressReportUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coursesCompleted?: IntFieldUpdateOperationsInput | number
    reviewsWritten?: IntFieldUpdateOperationsInput | number
    pointsEarned?: IntFieldUpdateOperationsInput | number
    skillsLearned?: ProgressReportUpdateskillsLearnedInput | string[]
    weeklyGoalMet?: BoolFieldUpdateOperationsInput | boolean
    monthlyGoalMet?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReviewCreateManyCourseInput = {
    id?: string
    userId: string
    overallRating: number
    difficultyRating?: number | null
    contentQuality?: number | null
    instructorRating?: number | null
    valueForMoney?: number | null
    wouldRecommend?: boolean | null
    title: string
    content: string
    pros?: ReviewCreateprosInput | string[]
    cons?: ReviewCreateconsInput | string[]
    isAnonymous?: boolean
    isVerified?: boolean
    helpfulCount?: number
    flagCount?: number
    isHidden?: boolean
    moderatorNotes?: string | null
    completionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseSkillCreateManyCourseInput = {
    id?: string
    skillId: string
    level?: $Enums.SkillLevel
    isCore?: boolean
    percentage?: number | null
    createdAt?: Date | string
  }

  export type CourseEnrollmentCreateManyCourseInput = {
    id?: string
    userId: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    progress?: number
    lastAccessed?: Date | string
    status?: string
    certificateUrl?: string | null
  }

  export type CourseCategoryCreateManyCourseInput = {
    id?: string
    categoryId: string
    isPrimary?: boolean
  }

  export type CourseTagCreateManyCourseInput = {
    id?: string
    tagId: string
  }

  export type CourseModuleCreateManyCourseInput = {
    id?: string
    title: string
    description?: string | null
    sortOrder: number
    duration?: string | null
    isOptional?: boolean
  }

  export type ReviewUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    difficultyRating?: NullableIntFieldUpdateOperationsInput | number | null
    contentQuality?: NullableIntFieldUpdateOperationsInput | number | null
    instructorRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueForMoney?: NullableIntFieldUpdateOperationsInput | number | null
    wouldRecommend?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    pros?: ReviewUpdateprosInput | string[]
    cons?: ReviewUpdateconsInput | string[]
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    flagCount?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    moderatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    votes?: ReviewVoteUpdateManyWithoutReviewNestedInput
    helpfulVotes?: ReviewHelpfulVoteUpdateManyWithoutReviewNestedInput
    skillRatings?: ReviewSkillRatingUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    difficultyRating?: NullableIntFieldUpdateOperationsInput | number | null
    contentQuality?: NullableIntFieldUpdateOperationsInput | number | null
    instructorRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueForMoney?: NullableIntFieldUpdateOperationsInput | number | null
    wouldRecommend?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    pros?: ReviewUpdateprosInput | string[]
    cons?: ReviewUpdateconsInput | string[]
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    flagCount?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    moderatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: ReviewVoteUncheckedUpdateManyWithoutReviewNestedInput
    helpfulVotes?: ReviewHelpfulVoteUncheckedUpdateManyWithoutReviewNestedInput
    skillRatings?: ReviewSkillRatingUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    difficultyRating?: NullableIntFieldUpdateOperationsInput | number | null
    contentQuality?: NullableIntFieldUpdateOperationsInput | number | null
    instructorRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueForMoney?: NullableIntFieldUpdateOperationsInput | number | null
    wouldRecommend?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    pros?: ReviewUpdateprosInput | string[]
    cons?: ReviewUpdateconsInput | string[]
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    flagCount?: IntFieldUpdateOperationsInput | number
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    moderatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseSkillUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    isCore?: BoolFieldUpdateOperationsInput | boolean
    percentage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skill?: SkillUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseSkillUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    isCore?: BoolFieldUpdateOperationsInput | boolean
    percentage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseSkillUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    isCore?: BoolFieldUpdateOperationsInput | boolean
    percentage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseEnrollmentUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type CourseEnrollmentUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourseEnrollmentUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourseCategoryUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    category?: CategoryUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseCategoryUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseCategoryUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseTagUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: TagUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseTagUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseTagUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseModuleUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    isOptional?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseModuleUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    isOptional?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseModuleUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    isOptional?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseSkillCreateManySkillInput = {
    id?: string
    courseId: string
    level?: $Enums.SkillLevel
    isCore?: boolean
    percentage?: number | null
    createdAt?: Date | string
  }

  export type UserSkillProficiencyCreateManySkillInput = {
    id?: string
    userId: string
    level: $Enums.SkillLevel
    yearsExperience?: number | null
    lastUsed?: Date | string | null
    isVerified?: boolean
    verificationSource?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkillPrerequisiteCreateManyPrerequisiteSkillInput = {
    id?: string
    skillId: string
    isRequired?: boolean
    minimumLevel?: $Enums.SkillLevel
  }

  export type SkillPrerequisiteCreateManySkillInput = {
    id?: string
    prerequisiteSkillId: string
    isRequired?: boolean
    minimumLevel?: $Enums.SkillLevel
  }

  export type ReviewSkillRatingCreateManySkillInput = {
    id?: string
    reviewId: string
    rating: number
    createdAt?: Date | string
  }

  export type CourseSkillUpdateWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    isCore?: BoolFieldUpdateOperationsInput | boolean
    percentage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutSkillsNestedInput
  }

  export type CourseSkillUncheckedUpdateWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    isCore?: BoolFieldUpdateOperationsInput | boolean
    percentage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseSkillUncheckedUpdateManyWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    isCore?: BoolFieldUpdateOperationsInput | boolean
    percentage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSkillProficiencyUpdateWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    yearsExperience?: NullableIntFieldUpdateOperationsInput | number | null
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSkillProficienciesNestedInput
  }

  export type UserSkillProficiencyUncheckedUpdateWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    yearsExperience?: NullableIntFieldUpdateOperationsInput | number | null
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSkillProficiencyUncheckedUpdateManyWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    level?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    yearsExperience?: NullableIntFieldUpdateOperationsInput | number | null
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillPrerequisiteUpdateWithoutPrerequisiteSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    minimumLevel?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    skill?: SkillUpdateOneRequiredWithoutPrerequisitesNestedInput
  }

  export type SkillPrerequisiteUncheckedUpdateWithoutPrerequisiteSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    minimumLevel?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
  }

  export type SkillPrerequisiteUncheckedUpdateManyWithoutPrerequisiteSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    minimumLevel?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
  }

  export type SkillPrerequisiteUpdateWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    minimumLevel?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
    prerequisiteSkill?: SkillUpdateOneRequiredWithoutPrerequisiteForNestedInput
  }

  export type SkillPrerequisiteUncheckedUpdateWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    prerequisiteSkillId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    minimumLevel?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
  }

  export type SkillPrerequisiteUncheckedUpdateManyWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    prerequisiteSkillId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    minimumLevel?: EnumSkillLevelFieldUpdateOperationsInput | $Enums.SkillLevel
  }

  export type ReviewSkillRatingUpdateWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ReviewUpdateOneRequiredWithoutSkillRatingsNestedInput
  }

  export type ReviewSkillRatingUncheckedUpdateWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewSkillRatingUncheckedUpdateManyWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewVoteCreateManyReviewInput = {
    id?: string
    userId: string
    isUpvote: boolean
    createdAt?: Date | string
  }

  export type ReviewHelpfulVoteCreateManyReviewInput = {
    id?: string
    userId: string
    isHelpful: boolean
    createdAt?: Date | string
  }

  export type ReviewSkillRatingCreateManyReviewInput = {
    id?: string
    skillId: string
    rating: number
    createdAt?: Date | string
  }

  export type ReviewVoteUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUpvote?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewVotesNestedInput
  }

  export type ReviewVoteUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isUpvote?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewVoteUncheckedUpdateManyWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isUpvote?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewHelpfulVoteUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    isHelpful?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewHelpfulVotesNestedInput
  }

  export type ReviewHelpfulVoteUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isHelpful?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewHelpfulVoteUncheckedUpdateManyWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isHelpful?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewSkillRatingUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skill?: SkillUpdateOneRequiredWithoutReviewRatingsNestedInput
  }

  export type ReviewSkillRatingUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewSkillRatingUncheckedUpdateManyWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateManyParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    color?: string | null
    sortOrder?: number
    isActive?: boolean
  }

  export type CourseCategoryCreateManyCategoryInput = {
    id?: string
    courseId: string
    isPrimary?: boolean
  }

  export type CategoryUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    children?: CategoryUpdateManyWithoutParentNestedInput
    courses?: CourseCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    courses?: CourseCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseCategoryUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    course?: CourseUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type CourseCategoryUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseCategoryUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseTagCreateManyTagInput = {
    id?: string
    courseId: string
  }

  export type CourseTagUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    course?: CourseUpdateOneRequiredWithoutTagsNestedInput
  }

  export type CourseTagUncheckedUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseTagUncheckedUpdateManyWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type UserAchievementCreateManyAchievementInput = {
    id?: string
    userId: string
    earnedAt?: Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserAchievementUpdateWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutAchievementsNestedInput
  }

  export type UserAchievementUncheckedUpdateWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserAchievementUncheckedUpdateManyWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}